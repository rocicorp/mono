Based on my research, I'll design a complete storage solution for
  your streaming statistics. Here's the comprehensive design:

  Statistics Storage System Design

  1. Database Schema

  Following the existing _zero. prefix pattern for metadata tables:

  -- Main statistics table
  CREATE TABLE "_zero.column_statistics" (
    -- Primary key
    table_name TEXT NOT NULL,
    column_name TEXT NOT NULL,

    -- Exact counters (8 bytes each)
    row_count INTEGER NOT NULL DEFAULT 0,
    null_count INTEGER NOT NULL DEFAULT 0,

    -- Approximate distinct count (from HyperLogLog)
    distinct_count INTEGER NOT NULL DEFAULT 0,

    -- Min/Max values (stored as JSON for type flexibility)
    min_value TEXT,  -- JSON-encoded value
    max_value TEXT,  -- JSON-encoded value

    -- Sketches (JSON serialized, nullable for selective tracking)
    hll_sketch TEXT,       -- HyperLogLog: ~1-50 KB JSON
    tdigest_sketch TEXT,   -- T-Digest: ~1-10 KB JSON (reuse 
  existing impl)
    cms_sketch TEXT,       -- Count-Min Sketch: ~10-200 KB JSON 
  (optional)

    -- Metadata
    last_updated INTEGER NOT NULL,  -- Unix timestamp (ms)
    version INTEGER NOT NULL DEFAULT 1,  -- Schema version for 
  migrations

    PRIMARY KEY (table_name, column_name)
  ) WITHOUT ROWID;  -- Optimization for primary key lookups

  -- Index for finding stale statistics
  CREATE INDEX IF NOT EXISTS idx_column_statistics_updated
    ON "_zero.column_statistics"(last_updated);

  -- Index for table-level queries
  CREATE INDEX IF NOT EXISTS idx_column_statistics_table
    ON "_zero.column_statistics"(table_name);

  Design Decisions:
  - TEXT for sketches: Use JSON serialization (compatible with
  existing T-Digest pattern)
  - WITHOUT ROWID: Primary key-only table benefits from clustered
  index
  - Nullable sketches: Allow selective tracking (e.g., CMS only for
  high-cardinality columns)
  - JSON for min/max: Handles any type (numbers, strings,
  timestamps, booleans)

  2. Data Structure Implementations

  2.1 HyperLogLog

  // packages/zero-cache/src/services/change-streamer/statistics/hyp
  erloglog.ts

  /**
   * HyperLogLog implementation for cardinality estimation.
   * 
   * Memory: 2^precision bytes (default: 16 KB for p=14)
   * Error: ~1.04 / sqrt(2^precision) (default: ~0.81% for p=14)
   * 
   * Based on: "HyperLogLog: the analysis of a near-optimal 
  cardinality
   * estimation algorithm" by Flajolet et al.
   */
  export class HyperLogLog {
    private readonly registers: Uint8Array;
    private readonly precision: number;
    private readonly alpha: number;

    /**
     * @param precision - Number of bits for bucket addressing 
  (4-16)
     *   p=12: 4 KB, ~1.625% error
     *   p=14: 16 KB, ~0.81% error (recommended)
     *   p=16: 64 KB, ~0.41% error
     */
    constructor(precision: number = 14) {
      if (precision < 4 || precision > 16) {
        throw new Error('Precision must be between 4 and 16');
      }

      this.precision = precision;
      this.registers = new Uint8Array(1 << precision); // 2^p 
  buckets

      // Alpha constant for bias correction
      const m = 1 << precision;
      if (m >= 128) {
        this.alpha = 0.7213 / (1 + 1.079 / m);
      } else if (m >= 64) {
        this.alpha = 0.709;
      } else if (m >= 32) {
        this.alpha = 0.697;
      } else {
        this.alpha = 0.5;
      }
    }

    /**
     * Add a value to the sketch
     */
    add(value: unknown): void {
      const hash = this.hash64(this.serialize(value));
      const bucketIndex = hash & ((1 << this.precision) - 1);
      const leadingZeros = this.countLeadingZeros(hash >>>
  this.precision) + 1;

      this.registers[bucketIndex] = Math.max(
        this.registers[bucketIndex],
        leadingZeros
      );
    }

    /**
     * Estimate the number of distinct values
     */
    cardinality(): number {
      const m = 1 << this.precision;
      let sum = 0;
      let zeros = 0;

      for (let i = 0; i < m; i++) {
        sum += Math.pow(2, -this.registers[i]);
        if (this.registers[i] === 0) zeros++;
      }

      let estimate = this.alpha * m * m / sum;

      // Small range correction
      if (estimate <= 2.5 * m) {
        if (zeros !== 0) {
          estimate = m * Math.log(m / zeros);
        }
      }
      // Large range correction (for 32-bit hashes)
      else if (estimate > (1 << 32) / 30) {
        estimate = -(1 << 32) * Math.log(1 - estimate / (1 << 32));
      }

      return Math.round(estimate);
    }

    /**
     * Merge multiple HyperLogLog sketches
     */
    static merge(hlls: HyperLogLog[]): HyperLogLog {
      if (hlls.length === 0) {
        throw new Error('Cannot merge empty array');
      }

      const precision = hlls[0].precision;
      if (!hlls.every(h => h.precision === precision)) {
        throw new Error('Cannot merge HLLs with different 
  precision');
      }

      const merged = new HyperLogLog(precision);
      const m = 1 << precision;

      for (let i = 0; i < m; i++) {
        merged.registers[i] = Math.max(...hlls.map(h =>
  h.registers[i]));
      }

      return merged;
    }

    /**
     * Serialize to JSON for storage
     */
    toJSON(): HyperLogLogJSON {
      return {
        version: 1,
        precision: this.precision,
        registers: Array.from(this.registers)
      };
    }

    /**
     * Deserialize from JSON
     */
    static fromJSON(json: HyperLogLogJSON): HyperLogLog {
      if (json.version !== 1) {
        throw new Error(`Unsupported HLL version: ${json.version}`);
      }

      const hll = new HyperLogLog(json.precision);
      hll.registers.set(json.registers);
      return hll;
    }

    /**
     * Serialize value to bytes for hashing
     */
    private serialize(value: unknown): string {
      if (value === null) return '\0null';
      if (value === undefined) return '\0undefined';

      const type = typeof value;

      if (type === 'string') return `s:${value}`;
      if (type === 'number') return `n:${value}`;
      if (type === 'boolean') return `b:${value}`;
      if (type === 'bigint') return `i:${value}`;

      // For objects/arrays, use JSON
      return `j:${JSON.stringify(value)}`;
    }

    /**
     * 64-bit MurmurHash3 (simplified for JavaScript)
     */
    private hash64(key: string): number {
      let h = 0;
      for (let i = 0; i < key.length; i++) {
        h = Math.imul(h ^ key.charCodeAt(i), 2654435761);
      }
      return (h ^ (h >>> 16)) >>> 0;
    }

    /**
     * Count leading zeros in 32-bit integer
     */
    private countLeadingZeros(n: number): number {
      if (n === 0) return 32;
      let count = 0;
      if ((n & 0xFFFF0000) === 0) { count += 16; n <<= 16; }
      if ((n & 0xFF000000) === 0) { count += 8; n <<= 8; }
      if ((n & 0xF0000000) === 0) { count += 4; n <<= 4; }
      if ((n & 0xC0000000) === 0) { count += 2; n <<= 2; }
      if ((n & 0x80000000) === 0) { count += 1; }
      return count;
    }
  }

  export interface HyperLogLogJSON {
    version: 1;
    precision: number;
    registers: number[];
  }

  2.2 Count-Min Sketch

  // packages/zero-cache/src/services/change-streamer/statistics/cou
  nt-min-sketch.ts

  /**
   * Count-Min Sketch for frequency estimation.
   * 
   * Memory: width × depth × 4 bytes (default: ~20 KB for ε=0.01, 
  δ=0.001)
   * Error: ε with probability 1-δ
   * 
   * Based on: "An improved data stream summary: the count-min 
  sketch and its
   * applications" by Cormode and Muthukrishnan
   */
  export class CountMinSketch {
    private readonly counters: Uint32Array[];
    private readonly width: number;
    private readonly depth: number;
    private readonly seeds: number[];

    /**
     * @param epsilon - Error bound (e.g., 0.01 for 1% error)
     * @param delta - Failure probability (e.g., 0.001 for 99.9% 
  confidence)
     */
    constructor(epsilon: number = 0.01, delta: number = 0.001) {
      this.width = Math.ceil(Math.E / epsilon);
      this.depth = Math.ceil(Math.log(1 / delta));

      // Initialize counter arrays
      this.counters = Array.from({ length: this.depth }, () =>
        new Uint32Array(this.width)
      );

      // Generate random seeds for hash functions
      this.seeds = Array.from({ length: this.depth }, (_, i) =>
        Math.floor(Math.random() * 0x7FFFFFFF) + i
      );
    }

    /**
     * Add a value (increment its count)
     */
    add(value: unknown, count: number = 1): void {
      const key = this.serialize(value);

      for (let i = 0; i < this.depth; i++) {
        const hash = this.hash(key, this.seeds[i]);
        const index = hash % this.width;
        this.counters[i][index] += count;
      }
    }

    /**
     * Query the estimated count for a value
     */
    query(value: unknown): number {
      const key = this.serialize(value);
      let min = Infinity;

      for (let i = 0; i < this.depth; i++) {
        const hash = this.hash(key, this.seeds[i]);
        const index = hash % this.width;
        min = Math.min(min, this.counters[i][index]);
      }

      return min === Infinity ? 0 : min;
    }

    /**
     * Merge multiple Count-Min Sketches
     */
    static merge(sketches: CountMinSketch[]): CountMinSketch {
      if (sketches.length === 0) {
        throw new Error('Cannot merge empty array');
      }

      const first = sketches[0];
      if (!sketches.every(s =>
        s.width === first.width &&
        s.depth === first.depth
      )) {
        throw new Error('Cannot merge CMS with different 
  dimensions');
      }

      // Create new sketch with same dimensions
      const merged = Object.create(CountMinSketch.prototype);
      merged.width = first.width;
      merged.depth = first.depth;
      merged.seeds = [...first.seeds];
      merged.counters = Array.from({ length: first.depth }, () =>
        new Uint32Array(first.width)
      );

      // Sum all counters
      for (let i = 0; i < first.depth; i++) {
        for (let j = 0; j < first.width; j++) {
          merged.counters[i][j] = sketches.reduce(
            (sum, s) => sum + s.counters[i][j],
            0
          );
        }
      }

      return merged;
    }

    /**
     * Serialize to JSON for storage
     */
    toJSON(): CountMinSketchJSON {
      return {
        version: 1,
        width: this.width,
        depth: this.depth,
        seeds: this.seeds,
        counters: this.counters.map(row => Array.from(row))
      };
    }

    /**
     * Deserialize from JSON
     */
    static fromJSON(json: CountMinSketchJSON): CountMinSketch {
      if (json.version !== 1) {
        throw new Error(`Unsupported CMS version: ${json.version}`);
      }

      const cms = Object.create(CountMinSketch.prototype);
      cms.width = json.width;
      cms.depth = json.depth;
      cms.seeds = json.seeds;
      cms.counters = json.counters.map(row => new Uint32Array(row));
      return cms;
    }

    /**
     * Get approximate memory usage in bytes
     */
    memoryUsage(): number {
      return this.width * this.depth * 4 + // Counters (4 bytes 
  each)
             this.depth * 8;                // Seeds (8 bytes each)
    }

    private serialize(value: unknown): string {
      if (value === null) return '\0null';
      if (value === undefined) return '\0undefined';

      const type = typeof value;

      if (type === 'string') return `s:${value}`;
      if (type === 'number') return `n:${value}`;
      if (type === 'boolean') return `b:${value}`;
      if (type === 'bigint') return `i:${value}`;

      return `j:${JSON.stringify(value)}`;
    }

    private hash(key: string, seed: number): number {
      let h = seed;
      for (let i = 0; i < key.length; i++) {
        h = Math.imul(h ^ key.charCodeAt(i), 2654435761);
      }
      return ((h ^ (h >>> 16)) >>> 0) % this.width;
    }
  }

  export interface CountMinSketchJSON {
    version: 1;
    width: number;
    depth: number;
    seeds: number[];
    counters: number[][];
  }

  3. Column Statistics Container

  // packages/zero-cache/src/services/change-streamer/statistics/col
  umn-statistics.ts

  import {HyperLogLog} from './hyperloglog.js';
  import {CountMinSketch} from './count-min-sketch.js';
  import {TDigest} from '../../../../shared/src/tdigest.js';
  import type {JSONValue} from
  '../../../../shared/src/bigint-json.js';

  /**
   * Statistics for a single column
   */
  export class ColumnStatistics {
    // Exact counters
    rowCount = 0;
    nullCount = 0;

    // Min/Max tracking
    minValue: JSONValue | undefined = undefined;
    maxValue: JSONValue | undefined = undefined;

    // Sketches (created on first use)
    private _hll: HyperLogLog | undefined;
    private _tdigest: TDigest | undefined;
    private _cms: CountMinSketch | undefined;

    constructor(
      private readonly config: ColumnStatisticsConfig
    ) {}

    /**
     * Update statistics with a new value
     */
    update(value: JSONValue): void {
      this.rowCount++;

      if (value === null) {
        this.nullCount++;
        return; // Don't track null in sketches
      }

      // Update min/max
      this.updateMinMax(value);

      // Update HyperLogLog (always enabled for NDV)
      if (this.config.trackNDV) {
        this.hll.add(value);
      }

      // Update T-Digest (for numeric/timestamp columns)
      if (this.config.trackRanges && this.isNumeric(value)) {
        this.tdigest.add(Number(value));
      }

      // Update Count-Min Sketch (for high-cardinality columns)
      if (this.config.trackFrequencies) {
        this.cms.add(value);
      }
    }

    /**
     * Remove a value (for DELETE operations)
     */
    remove(value: JSONValue): void {
      this.rowCount--;

      if (value === null) {
        this.nullCount--;
        return;
      }

      // Note: HyperLogLog and T-Digest don't support deletion
      // We accept slight inaccuracy here (over-estimation of NDV)

      // Count-Min Sketch can subtract
      if (this.config.trackFrequencies) {
        this.cms.add(value, -1);
      }
    }

    /**
     * Get estimated distinct count
     */
    getDistinctCount(): number {
      if (!this._hll) return 0;
      return this._hll.cardinality();
    }

    /**
     * Get estimated frequency of a value
     */
    getFrequency(value: JSONValue): number {
      if (!this._cms) return 0;
      return this._cms.query(value);
    }

    /**
     * Get percentile from T-Digest
     */
    getPercentile(value: number): number {
      if (!this._tdigest) return 0;
      return this._tdigest.cdf(value);
    }

    /**
     * Serialize to JSON for persistence
     */
    toJSON(): ColumnStatisticsJSON {
      return {
        version: 1,
        rowCount: this.rowCount,
        nullCount: this.nullCount,
        distinctCount: this.getDistinctCount(),
        minValue: this.minValue,
        maxValue: this.maxValue,
        hll: this._hll?.toJSON(),
        tdigest: this._tdigest?.toJSON(),
        cms: this._cms?.toJSON(),
      };
    }

    /**
     * Deserialize from JSON
     */
    static fromJSON(
      json: ColumnStatisticsJSON,
      config: ColumnStatisticsConfig
    ): ColumnStatistics {
      const stats = new ColumnStatistics(config);
      stats.rowCount = json.rowCount;
      stats.nullCount = json.nullCount;
      stats.minValue = json.minValue;
      stats.maxValue = json.maxValue;

      if (json.hll) {
        stats._hll = HyperLogLog.fromJSON(json.hll);
      }
      if (json.tdigest) {
        stats._tdigest = TDigest.fromJSON(json.tdigest);
      }
      if (json.cms) {
        stats._cms = CountMinSketch.fromJSON(json.cms);
      }

      return stats;
    }

    // Lazy initialization of sketches
    private get hll(): HyperLogLog {
      if (!this._hll) {
        this._hll = new HyperLogLog(this.config.hllPrecision);
      }
      return this._hll;
    }

    private get tdigest(): TDigest {
      if (!this._tdigest) {
        this._tdigest = new TDigest(this.config.tdigestCompression);
      }
      return this._tdigest;
    }

    private get cms(): CountMinSketch {
      if (!this._cms) {
        this._cms = new CountMinSketch(
          this.config.cmsEpsilon,
          this.config.cmsDelta
        );
      }
      return this._cms;
    }

    private updateMinMax(value: JSONValue): void {
      if (this.minValue === undefined || this.compare(value,
  this.minValue) < 0) {
        this.minValue = value;
      }
      if (this.maxValue === undefined || this.compare(value,
  this.maxValue) > 0) {
        this.maxValue = value;
      }
    }

    private compare(a: JSONValue, b: JSONValue): number {
      if (a === b) return 0;
      if (a === null) return -1;
      if (b === null) return 1;

      const typeA = typeof a;
      const typeB = typeof b;

      if (typeA !== typeB) {
        return typeA < typeB ? -1 : 1;
      }

      return a < b ? -1 : 1;
    }

    private isNumeric(value: JSONValue): boolean {
      return typeof value === 'number' || typeof value === 'bigint';
    }
  }

  export interface ColumnStatisticsConfig {
    trackNDV: boolean;
    trackRanges: boolean;
    trackFrequencies: boolean;
    hllPrecision: number;
    tdigestCompression: number;
    cmsEpsilon: number;
    cmsDelta: number;
  }

  export interface ColumnStatisticsJSON {
    version: 1;
    rowCount: number;
    nullCount: number;
    distinctCount: number;
    minValue: JSONValue | undefined;
    maxValue: JSONValue | undefined;
    hll?: unknown;
    tdigest?: unknown;
    cms?: unknown;
  }

  4. Storage Layer

  // packages/zero-cache/src/services/change-streamer/statistics/sta
  tistics-store.ts

  import type {Database} from '../../../db/db.js';
  import type {LogContext} from '@rocicorp/logger';
  import {ColumnStatistics, type ColumnStatisticsJSON} from
  './column-statistics.js';

  /**
   * Persistent storage for column statistics
   * Follows the ColumnMetadataStore pattern
   */
  export class StatisticsStore {
    private upsertStmt: ReturnType<Database['prepare']> | undefined;
    private selectStmt: ReturnType<Database['prepare']> | undefined;
    private selectTableStmt: ReturnType<Database['prepare']> |
  undefined;
    private deleteStmt: ReturnType<Database['prepare']> | undefined;

    constructor(
      private readonly db: Database,
      private readonly lc: LogContext
    ) {}

    /**
     * Save statistics for a column
     */
    async save(
      tableName: string,
      columnName: string,
      stats: ColumnStatistics
    ): Promise<void> {
      if (!this.upsertStmt) {
        this.upsertStmt = this.db.prepare(`
          INSERT INTO "_zero.column_statistics" (
            table_name, column_name, row_count, null_count, 
  distinct_count,
            min_value, max_value, hll_sketch, tdigest_sketch, 
  cms_sketch,
            last_updated, version
          ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
          ON CONFLICT(table_name, column_name) DO UPDATE SET
            row_count = excluded.row_count,
            null_count = excluded.null_count,
            distinct_count = excluded.distinct_count,
            min_value = excluded.min_value,
            max_value = excluded.max_value,
            hll_sketch = excluded.hll_sketch,
            tdigest_sketch = excluded.tdigest_sketch,
            cms_sketch = excluded.cms_sketch,
            last_updated = excluded.last_updated,
            version = excluded.version
        `);
      }

      const json = stats.toJSON();

      this.upsertStmt.run(
        tableName,
        columnName,
        json.rowCount,
        json.nullCount,
        json.distinctCount,
        json.minValue !== undefined ? JSON.stringify(json.minValue)
  : null,
        json.maxValue !== undefined ? JSON.stringify(json.maxValue)
  : null,
        json.hll ? JSON.stringify(json.hll) : null,
        json.tdigest ? JSON.stringify(json.tdigest) : null,
        json.cms ? JSON.stringify(json.cms) : null,
        Date.now(),
        1
      );
    }

    /**
     * Load statistics for a column
     */
    load(tableName: string, columnName: string):
  ColumnStatisticsJSON | undefined {
      if (!this.selectStmt) {
        this.selectStmt = this.db.prepare(`
          SELECT * FROM "_zero.column_statistics"
          WHERE table_name = ? AND column_name = ?
        `);
      }

      const row = this.selectStmt.get(tableName, columnName) as
  Record<string, unknown> | undefined;
      if (!row) return undefined;

      return {
        version: 1,
        rowCount: row.row_count as number,
        nullCount: row.null_count as number,
        distinctCount: row.distinct_count as number,
        minValue: row.min_value ? JSON.parse(row.min_value as
  string) : undefined,
        maxValue: row.max_value ? JSON.parse(row.max_value as
  string) : undefined,
        hll: row.hll_sketch ? JSON.parse(row.hll_sketch as string) :
   undefined,
        tdigest: row.tdigest_sketch ? JSON.parse(row.tdigest_sketch
  as string) : undefined,
        cms: row.cms_sketch ? JSON.parse(row.cms_sketch as string) :
   undefined,
      };
    }

    /**
     * Load all statistics for a table
     */
    loadTable(tableName: string): Map<string, ColumnStatisticsJSON>
  {
      if (!this.selectTableStmt) {
        this.selectTableStmt = this.db.prepare(`
          SELECT * FROM "_zero.column_statistics"
          WHERE table_name = ?
        `);
      }

      const rows = this.selectTableStmt.all(tableName) as
  Array<Record<string, unknown>>;
      const result = new Map<string, ColumnStatisticsJSON>();

      for (const row of rows) {
        result.set(row.column_name as string, {
          version: 1,
          rowCount: row.row_count as number,
          nullCount: row.null_count as number,
          distinctCount: row.distinct_count as number,
          minValue: row.min_value ? JSON.parse(row.min_value as
  string) : undefined,
          maxValue: row.max_value ? JSON.parse(row.max_value as
  string) : undefined,
          hll: row.hll_sketch ? JSON.parse(row.hll_sketch as string)
   : undefined,
          tdigest: row.tdigest_sketch ?
  JSON.parse(row.tdigest_sketch as string) : undefined,
          cms: row.cms_sketch ? JSON.parse(row.cms_sketch as string)
   : undefined,
        });
      }

      return result;
    }

    /**
     * Delete statistics for a column
     */
    delete(tableName: string, columnName: string): void {
      if (!this.deleteStmt) {
        this.deleteStmt = this.db.prepare(`
          DELETE FROM "_zero.column_statistics"
          WHERE table_name = ? AND column_name = ?
        `);
      }

      this.deleteStmt.run(tableName, columnName);
    }

    /**
     * Delete all statistics for a table
     */
    deleteTable(tableName: string): void {
      this.db.prepare(`
        DELETE FROM "_zero.column_statistics"
        WHERE table_name = ?
      `).run(tableName);
    }

    /**
     * Clean up prepared statements
     */
    close(): void {
      this.upsertStmt?.finalize();
      this.selectStmt?.finalize();
      this.selectTableStmt?.finalize();
      this.deleteStmt?.finalize();
    }
  }

  5. Migration

  // Add to packages/zero-cache/src/db/migration-lite.ts

  const statisticsMigration: Migration = {
    migrateSchema: (db: Database) => {
      db.exec(`
        CREATE TABLE IF NOT EXISTS "_zero.column_statistics" (
          table_name TEXT NOT NULL,
          column_name TEXT NOT NULL,
          
          row_count INTEGER NOT NULL DEFAULT 0,
          null_count INTEGER NOT NULL DEFAULT 0,
          distinct_count INTEGER NOT NULL DEFAULT 0,
          
          min_value TEXT,
          max_value TEXT,
          
          hll_sketch TEXT,
          tdigest_sketch TEXT,
          cms_sketch TEXT,
          
          last_updated INTEGER NOT NULL,
          version INTEGER NOT NULL DEFAULT 1,
          
          PRIMARY KEY (table_name, column_name)
        ) WITHOUT ROWID;

        CREATE INDEX IF NOT EXISTS idx_column_statistics_updated 
          ON "_zero.column_statistics"(last_updated);

        CREATE INDEX IF NOT EXISTS idx_column_statistics_table 
          ON "_zero.column_statistics"(table_name);
      `);
    },
  };

  // Add to migrations array at appropriate version

  6. Configuration

  // Add to packages/zero-cache/src/config/zero-config.ts

  streamingStatistics: {
    enabled: {
      type: v.boolean().default(false),
      desc: [
        'Enable streaming statistics collection for query 
  planning.',
        'Tracks NDV, min/max, and distributions for all columns.',
      ],
    },
    flushIntervalMs: {
      type: v.number().default(60_000),
      desc: [
        'How often to persist statistics to disk (milliseconds).',
        'Lower values = more durability, higher I/O overhead.',
      ],
    },
    trackRanges: {
      type: v.boolean().default(false),
      desc: [
        'Enable T-Digest for range query selectivity (numeric 
  columns).',
        'Adds ~5 KB per numeric/timestamp column.',
      ],
    },
    trackFrequencies: {
      type: v.boolean().default(false),
      desc: [
        'Enable Count-Min Sketch for value frequency estimation.',
        'Adds ~50-100 KB per tracked column. Use selectively.',
      ],
    },
    hllPrecision: {
      type: v.number().default(14),
      desc: [
        'HyperLogLog precision (4-16).',
        'p=12: 4 KB/col, 1.6% error',
        'p=14: 16 KB/col, 0.8% error (default)',
        'p=16: 64 KB/col, 0.4% error',
      ],
    },
  },

  7. Memory Footprint Summary

  Per-column memory (with default config):

  // Configuration: hllPrecision=14, trackRanges=false, 
  trackFrequencies=false
  const memory = {
    hll: 16_384,        // 2^14 bytes
    minMax: 16,         // 2 pointers
    counters: 16,       // 2 int64
    overhead: 100,      // Object overhead
    total: 16_516       // ~16 KB per column
  };

  // For 500 columns:
  // 500 × 16 KB = 8 MB baseline

  // With T-Digest enabled (trackRanges=true):
  // Add ~5 KB per numeric column
  // If 100 numeric columns: +500 KB

  // With Count-Min Sketch (trackFrequencies=true, ε=0.01, δ=0.001):
  // Add ~20 KB per tracked column
  // If tracking 50 high-cardinality columns: +1 MB

  Total for 500 columns:
  - Baseline (NDV only): ~8 MB
  - With ranges: ~8.5 MB
  - With selective frequencies (50 cols): ~9.5 MB
  - Everything on everything: ~60 MB (overkill)

  Next Steps

  This design provides:
  ✅ Complete database schema following existing patterns✅
  Production-ready data structure implementations✅ Persistent
  storage with prepared statements✅ Configurable tracking
  (selective per-column)✅ Migration strategy✅ Memory-efficient
  design

  Would you like me to proceed with implementing this design?