╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌
IVM Pipeline Allocation Reduction Plan

Overview

This plan addresses allocation-heavy patterns in the IVM pipeline that slow down data processing. Focus is on CRITICAL + HIGH priority items affecting server-side hot paths. Client-only code (view-apply-change.ts) is excluded since data sizes are
small there.

---

CRITICAL Priority (Per-Row/Per-Change Hot Paths)

1.  Object.fromEntries + .map() Pattern (Multiple Files)

Locations:

- join.ts:218-220, 314-319 - per child change
- flipped-join.ts:304-310, 318-323, 402-404 - per child change
- take.ts:225-229 - per push with partition key
- table-source.ts:255-260 (toSQLiteRow) - per row insert/update

Current Pattern:
constraint: Object.fromEntries(
this.#parentKey.map((key, i) => [key, childRow[this.#childKey[i]]]),
)

Fix: Direct loop-based object construction
const constraint: Record<string, Value> = {};
for (let i = 0; i < this.#parentKey.length; i++) {
constraint[this.#parentKey[i]] = childRow[this.#childKey[i]];
}

---

3.  Node Relationship Object Spreads

Locations:

- join.ts:345-351 - per parent node processed
- flipped-join.ts:260-266 - per output node yielded
- join-utils.ts:66-77 - per modified node in overlay
- push-accumulated.ts:257-299 - per merged change

Current Pattern:
return {
row: parentNodeRow,
relationships: {
...parentNodeRelations, // SPREAD
[this.#relationshipName]: childStream,
},
};

Fix: Use Object.assign or direct property assignment
// Option A: Object.assign (slightly faster than spread)
const relationships = Object.assign({}, parentNodeRelations);
relationships[this.#relationshipName] = childStream;
return { row: parentNodeRow, relationships };

// Option B: Mutate if safe (when we own the object)
parentNodeRelations[this.#relationshipName] = childStream;
return { row: parentNodeRow, relationships: parentNodeRelations };

---

4.  fromSQLiteTypes - table-source.ts:544-560

Impact: Called for every row fetched from SQLite

Current:
for (const key of Object.keys(row)) {
newRow[key] = fromSQLiteType(...);
}

Fix: Use for...in loop
for (const key in row) {
newRow[key] = fromSQLiteType(...);
}

---

5.  toSQLiteTypes - table-source.ts:521-527

Impact: Called for every row being modified

Current:
return columns.map(col => toSQLiteType(row[col], columnTypes[col].type));

Fix: Reuse result array or build in-place
// Option A: Pre-allocated array
const result = new Array(columns.length);
for (let i = 0; i < columns.length; i++) {
result[i] = toSQLiteType(row[columns[i]], columnTypes[columns[i]].type);
}
return result;

---

HIGH Priority

6.  constraint.ts - Object.keys and Array Spread

Line 49: Object.keys(constraint) in constraint matching
// Current
return keyMatchesPrimaryKey(Object.keys(constraint), primary);

// Fix: Pass constraint directly, iterate with for...in

Line 56: Array spread in keyMatchesPrimaryKey
// Current
const constraintKeys = [...key];
constraintKeys.sort(stringCompare);

// Fix: Avoid spread for small iterables, count directly

---

7.  makeStorageKey - join.ts:377

// Current
const values: Value[] = key.map(k => row[k]);

// Fix: Single loop construction
const values: Value[] = [];
for (const k of key) values.push(row[k]);
for (const k of primaryKey) values.push(row[k]);

---

Implementation Order

1.  Object.fromEntries pattern - 4 files, highest impact on server
2.  Node relationship spreads - 4 files, high impact
3.  fromSQLiteTypes/toSQLiteTypes - 1 file, per-row impact
4.  constraint.ts optimizations - 1 file
5.  makeStorageKey - 1 file

---

Files to Modify

| File                                 | Changes                                                                                    |
| ------------------------------------ | ------------------------------------------------------------------------------------------ |
| packages/zql/src/ivm/join.ts         | constraint creation (lines 218-220, 314-319), node spreads (345-351), makeStorageKey (377) |
| packages/zql/src/ivm/flipped-join.ts | constraint creation (304-310, 318-323, 402-404), node spreads (260-266)                    |
| packages/zql/src/ivm/take.ts         | constraint creation (225-229)                                                              |
| packages/zql/src/ivm/join-utils.ts   | relationship spread (66-77)                                                                |
| packages/zql/src/ivm/constraint.ts   | keyMatchesPrimaryKey (49, 56)                                                              |
| packages/zqlite/src/table-source.ts  | fromSQLiteTypes (550), toSQLiteTypes (526), toSQLiteRow (255-260)                          |

---

Testing Strategy

- Run existing test suites: npm -w packages/zql test and npm -w packages/zqlite test
- Run zbugs benchmark to measure performance improvement: npm -w packages/zql-benchmarks run bench -- zbugs
