/**
 * WebSocket client helpers for pentest suite.
 *
 * Provides utilities for creating WebSocket connections with various
 * protocol encodings to test authentication edge cases.
 */

import {resolver} from '@rocicorp/resolver';
import {SignJWT} from 'jose';
import WebSocket from 'ws';
import {PROTOCOL_VERSION} from '../../../../zero-protocol/src/protocol-version.ts';
import {encodeSecProtocols} from '../../../../zero-protocol/src/connect.ts';

export interface ConnectOptions {
  port: number;
  clientGroupID?: string | undefined;
  clientID?: string | undefined;
  wsID?: string | undefined;
  userID?: string | undefined;
  authToken?: string | undefined;
  /** Raw sec-websocket-protocol value (bypasses encoding) */
  rawProtocol?: string | undefined;
  /** Whether to skip the protocol header entirely */
  skipProtocol?: boolean | undefined;
}

export interface ConnectResult {
  ws: WebSocket;
  /** Resolves when 'open' event fires */
  opened: Promise<void>;
  /** Resolves with close code/reason when 'close' event fires */
  closed: Promise<{code: number; reason: string}>;
  /** Resolves with first error if 'error' event fires */
  error: Promise<Error>;
  /** Resolves with first message received */
  firstMessage: Promise<unknown>;
}

/**
 * Creates a WebSocket connection to the sync endpoint.
 * Does NOT wait for connection to open - use result.opened if needed.
 *
 * Note: Some malformed protocols will cause WebSocket constructor to throw
 * immediately. Use tryConnectSync for testing those cases.
 */
export function connectSync(options: ConnectOptions): ConnectResult {
  const {
    port,
    clientGroupID = 'test-cg',
    clientID = 'test-client',
    wsID = 'test-ws',
    userID = '',
    authToken,
    rawProtocol,
    skipProtocol,
  } = options;

  const url =
    `ws://localhost:${port}/sync/v${PROTOCOL_VERSION}/connect` +
    `?clientGroupID=${encodeURIComponent(clientGroupID)}` +
    `&clientID=${encodeURIComponent(clientID)}` +
    `&wsid=${encodeURIComponent(wsID)}` +
    `&userID=${encodeURIComponent(userID)}` +
    `&schemaVersion=1` +
    `&baseCookie=` +
    `&ts=${Date.now()}` +
    `&lmid=0`;

  let protocol: string | undefined;
  if (skipProtocol) {
    protocol = undefined;
  } else if (rawProtocol !== undefined) {
    protocol = rawProtocol;
  } else {
    protocol = encodeSecProtocols(undefined, authToken);
  }

  const ws = new WebSocket(url, protocol);

  const {promise: opened, resolve: onOpen} = resolver<void>();
  const {promise: closed, resolve: onClose} = resolver<{
    code: number;
    reason: string;
  }>();
  const {promise: error, resolve: onError} = resolver<Error>();
  const {promise: firstMessage, resolve: onMessage} = resolver<unknown>();

  ws.on('open', () => onOpen());
  ws.on('close', (code, reason) => onClose({code, reason: reason.toString()}));
  ws.on('error', err => onError(err));
  ws.on('message', data => {
    try {
      onMessage(JSON.parse(data.toString()));
    } catch {
      onMessage(data.toString());
    }
  });

  return {ws, opened, closed, error, firstMessage};
}

/**
 * Tries to create a WebSocket connection, catching constructor errors.
 * Returns error if the WebSocket library rejects the connection parameters.
 */
export function tryConnectSync(
  options: ConnectOptions,
): ConnectResult | {constructorError: Error} {
  try {
    return connectSync(options);
  } catch (e) {
    return {constructorError: e as Error};
  }
}

/**
 * Creates a valid JWT for testing.
 */
export async function createValidJWT(
  secret: string,
  claims: Record<string, unknown> & {
    sub?: string;
    exp?: number;
    iat?: number;
    nbf?: number;
  } = {},
): Promise<string> {
  const secretKey = new TextEncoder().encode(secret);
  const now = Math.floor(Date.now() / 1000);

  let builder = new SignJWT(claims)
    .setProtectedHeader({alg: 'HS256'})
    .setIssuedAt(claims.iat ?? now)
    .setExpirationTime(claims.exp ?? now + 3600); // 1 hour default

  if (claims.sub) {
    builder = builder.setSubject(claims.sub);
  }
  if (claims.nbf !== undefined) {
    builder = builder.setNotBefore(claims.nbf);
  }

  return await builder.sign(secretKey);
}

/**
 * Creates various malformed JWTs for testing.
 */
export function createMalformedTokens(
  validToken: string,
): Record<string, string> {
  const parts = validToken.split('.');
  if (parts.length !== 3) {
    throw new Error('Expected valid JWT with 3 parts');
  }

  const [header, payload, signature] = parts;

  return {
    // Truncated tokens
    truncatedHeader: header.slice(0, 10),
    truncatedPayload: `${header}.${payload.slice(0, 10)}`,
    truncatedSignature: `${header}.${payload}.${signature.slice(0, 10)}`,
    missingSignature: `${header}.${payload}`,
    missingPayload: `${header}..${signature}`,

    // Malformed structure
    emptyString: '',
    singleDot: '.',
    doubleDot: '..',
    tripleDot: '...',
    fourParts: `${header}.${payload}.${signature}.extra`,
    noDots: 'nodots',

    // Invalid base64
    invalidBase64Header: `!!!.${payload}.${signature}`,
    invalidBase64Payload: `${header}.!!!.${signature}`,
    invalidBase64Signature: `${header}.${payload}.!!!`,

    // Wrong signature (tampered)
    tamperedPayload: `${header}.${btoa('{"sub":"hacked"}')}.${signature}`,

    // Unicode edge cases (use base64 encoding that handles Unicode)
    unicodeInToken: `${header}.${Buffer.from('{"sub":"テスト"}').toString('base64')}.${signature}`,

    // Very long token (potential DoS)
    veryLongToken: `${header}.${btoa(JSON.stringify({data: 'x'.repeat(100000)}))}.${signature}`,
  };
}

/**
 * Creates malformed sec-websocket-protocol values for testing.
 */
export function createMalformedProtocols(): Record<string, string> {
  return {
    // Invalid base64
    invalidBase64: '!!!not-base64!!!',
    partialBase64: 'aGVsbG8', // 'hello' - valid base64 but not JSON

    // Invalid JSON after decode
    invalidJson: btoa('{not json}'),
    truncatedJson: btoa('{"authToken":'),
    unclosedString: btoa('{"authToken":"unclosed'),

    // Missing fields (valid JSON but wrong structure)
    emptyObject: btoa('{}'),
    nullAuthToken: btoa('{"authToken":null}'),
    numberAuthToken: btoa('{"authToken":12345}'),
    arrayAuthToken: btoa('{"authToken":["a","b"]}'),
    objectAuthToken: btoa('{"authToken":{"nested":"value"}}'),

    // Unicode edge cases (use Buffer for proper encoding)
    unicodeValue: Buffer.from('{"authToken":"日本語"}').toString('base64'),

    // Very large payload
    largePayload: btoa(JSON.stringify({authToken: 'x'.repeat(100000)})),

    // Prototype pollution attempts
    protoPayload: btoa('{"__proto__":{"admin":true},"authToken":"test"}'),
    constructorPayload: btoa(
      '{"constructor":{"prototype":{"admin":true}},"authToken":"test"}',
    ),
  };
}

/**
 * Waits for connection result with timeout.
 *
 * Note: WebSocket connections may open before auth is validated.
 * The error is sent after open, then connection closes.
 */
export async function waitForConnection(
  result: ConnectResult,
  timeoutMs: number = 5000,
): Promise<
  | {type: 'opened'; message?: unknown}
  | {type: 'closed'; code: number; reason: string}
  | {type: 'error'; error: Error}
  | {type: 'timeout'}
> {
  const timeout = new Promise<{type: 'timeout'}>(resolve =>
    setTimeout(() => resolve({type: 'timeout'}), timeoutMs),
  );

  const openedWithMessage = result.opened.then(async () => {
    // Wait a bit for first message
    const msgTimeout = new Promise<undefined>(resolve =>
      setTimeout(() => resolve(undefined), 1000),
    );
    const msg = await Promise.race([result.firstMessage, msgTimeout]);
    return {type: 'opened' as const, message: msg};
  });

  const closed = result.closed.then(({code, reason}) => ({
    type: 'closed' as const,
    code,
    reason,
  }));

  const errored = result.error.then(error => ({
    type: 'error' as const,
    error,
  }));

  return await Promise.race([openedWithMessage, closed, errored, timeout]);
}

/**
 * Waits for connection to open, receive a message, then close.
 * Useful for testing auth failures where WS opens, sends error, then closes.
 */
export async function waitForOpenThenClose(
  result: ConnectResult,
  timeoutMs: number = 5000,
): Promise<
  | {
      type: 'openedThenClosed';
      message?: unknown;
      closeCode: number;
      closeReason: string;
    }
  | {type: 'opened'; message?: unknown}
  | {type: 'closed'; code: number; reason: string}
  | {type: 'error'; error: Error}
  | {type: 'timeout'}
> {
  const timeout = new Promise<{type: 'timeout'}>(resolve =>
    setTimeout(() => resolve({type: 'timeout'}), timeoutMs),
  );

  const openedThenClosed = result.opened.then(async () => {
    // Wait for first message
    const msgTimeout = new Promise<undefined>(resolve =>
      setTimeout(() => resolve(undefined), 2000),
    );
    const msg = await Promise.race([result.firstMessage, msgTimeout]);

    // Now wait for close
    const closeTimeout = new Promise<undefined>(resolve =>
      setTimeout(() => resolve(undefined), 2000),
    );
    const close = await Promise.race([result.closed, closeTimeout]);

    if (close) {
      return {
        type: 'openedThenClosed' as const,
        message: msg,
        closeCode: close.code,
        closeReason: close.reason,
      };
    }
    return {type: 'opened' as const, message: msg};
  });

  const closedWithoutOpen = result.closed.then(({code, reason}) => ({
    type: 'closed' as const,
    code,
    reason,
  }));

  const errored = result.error.then(error => ({
    type: 'error' as const,
    error,
  }));

  return await Promise.race([
    openedThenClosed,
    closedWithoutOpen,
    errored,
    timeout,
  ]);
}
