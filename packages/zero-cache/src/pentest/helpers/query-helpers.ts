/**
 * Query Helpers - Utilities for submitting queries in pentest suite.
 *
 * Provides methods to:
 * - Send changeDesiredQueries messages
 * - Wait for query results/errors
 * - Create properly structured query patches
 */

import {resolver} from '@rocicorp/resolver';
import type WebSocket from 'ws';
import type {AST} from '../../../../zero-protocol/src/ast.ts';
import type {ChangeDesiredQueriesMessage} from '../../../../zero-protocol/src/change-desired-queries.ts';
import type {InitConnectionMessage} from '../../../../zero-protocol/src/connect.ts';
import type {Downstream} from '../../../../zero-protocol/src/down.ts';
import {hashOfAST} from '../../../../zero-protocol/src/query-hash.ts';

/**
 * Result of a query submission.
 */
export type QueryResult =
  | {type: 'success'; data: unknown}
  | {type: 'error'; error: unknown; errorKind?: string | undefined}
  | {type: 'timeout'}
  | {type: 'closed'; code: number; reason: string};

/**
 * Creates a query hash for the given AST.
 * Used to generate unique query IDs for the patch.
 */
export function createQueryHash(ast: AST): string {
  return hashOfAST(ast);
}

/**
 * Creates an initConnection message with the given queries.
 */
export function createInitConnectionMessage(
  queries: Array<{ast: AST; hash?: string}>,
): InitConnectionMessage {
  const desiredQueriesPatch = queries.map(({ast, hash}) => ({
    op: 'put' as const,
    hash: hash ?? createQueryHash(ast),
    ast,
  }));

  return [
    'initConnection',
    {
      desiredQueriesPatch,
    },
  ];
}

/**
 * Creates a changeDesiredQueries message to add queries.
 */
export function createAddQueryMessage(
  queries: Array<{ast: AST; hash?: string; ttl?: number}>,
): ChangeDesiredQueriesMessage {
  const desiredQueriesPatch = queries.map(({ast, hash, ttl}) => ({
    op: 'put' as const,
    hash: hash ?? createQueryHash(ast),
    ast,
    ttl,
  }));

  return ['changeDesiredQueries', {desiredQueriesPatch}];
}

/**
 * Creates a changeDesiredQueries message to remove a query.
 */
export function createRemoveQueryMessage(
  hashes: string[],
): ChangeDesiredQueriesMessage {
  const desiredQueriesPatch = hashes.map(hash => ({
    op: 'del' as const,
    hash,
  }));

  return ['changeDesiredQueries', {desiredQueriesPatch}];
}

/**
 * Creates a changeDesiredQueries message to clear all queries.
 */
export function createClearQueriesMessage(): ChangeDesiredQueriesMessage {
  return ['changeDesiredQueries', {desiredQueriesPatch: [{op: 'clear'}]}];
}

/**
 * Sends a message over the WebSocket.
 */
export function sendMessage(
  ws: WebSocket,
  message: InitConnectionMessage | ChangeDesiredQueriesMessage,
): void {
  ws.send(JSON.stringify(message));
}

/**
 * Collects messages from WebSocket until timeout or close.
 */
export async function collectMessages(
  ws: WebSocket,
  timeoutMs: number = 5000,
): Promise<{messages: Downstream[]; closed?: {code: number; reason: string}}> {
  const messages: Downstream[] = [];
  const {promise, resolve} = resolver<{
    messages: Downstream[];
    closed?: {code: number; reason: string};
  }>();

  const timeout = setTimeout(() => {
    resolve({messages});
  }, timeoutMs);

  const messageHandler = (data: WebSocket.Data) => {
    try {
      const parsed = JSON.parse(data.toString()) as Downstream;
      messages.push(parsed);
    } catch {
      // Ignore parse errors
    }
  };

  const closeHandler = (code: number, reason: Buffer) => {
    clearTimeout(timeout);
    resolve({messages, closed: {code, reason: reason.toString()}});
  };

  ws.on('message', messageHandler);
  ws.on('close', closeHandler);

  const result = await promise;

  ws.off('message', messageHandler);
  ws.off('close', closeHandler);

  return result;
}

/**
 * Waits for a specific message type.
 */
export async function waitForMessageType(
  ws: WebSocket,
  messageType: string,
  timeoutMs: number = 5000,
): Promise<Downstream | null> {
  const {promise, resolve} = resolver<Downstream | null>();

  const timeout = setTimeout(() => {
    resolve(null);
  }, timeoutMs);

  const messageHandler = (data: WebSocket.Data) => {
    try {
      const parsed = JSON.parse(data.toString()) as Downstream;
      if (parsed[0] === messageType) {
        clearTimeout(timeout);
        resolve(parsed);
      }
    } catch {
      // Ignore parse errors
    }
  };

  ws.on('message', messageHandler);

  const result = await promise;

  ws.off('message', messageHandler);

  return result;
}

/**
 * Waits for either a poke (success) or error message.
 */
export async function waitForQueryResult(
  ws: WebSocket,
  timeoutMs: number = 5000,
): Promise<QueryResult> {
  const {promise, resolve} = resolver<QueryResult>();

  const timeout = setTimeout(() => {
    resolve({type: 'timeout'});
  }, timeoutMs);

  const messageHandler = (data: WebSocket.Data) => {
    try {
      const parsed = JSON.parse(data.toString()) as Downstream;
      const msgType = parsed[0];

      if (
        msgType === 'pokeStart' ||
        msgType === 'pokePart' ||
        msgType === 'pokeEnd'
      ) {
        clearTimeout(timeout);
        resolve({type: 'success', data: parsed});
      } else if (msgType === 'error') {
        clearTimeout(timeout);
        const errorBody = parsed[1] as {kind?: string; message?: string};
        resolve({
          type: 'error',
          error: errorBody,
          errorKind: errorBody?.kind ?? undefined,
        });
      }
    } catch {
      // Ignore parse errors
    }
  };

  const closeHandler = (code: number, reason: Buffer) => {
    clearTimeout(timeout);
    resolve({type: 'closed', code, reason: reason.toString()});
  };

  ws.on('message', messageHandler);
  ws.on('close', closeHandler);

  const result = await promise;

  ws.off('message', messageHandler);
  ws.off('close', closeHandler);

  return result;
}

/**
 * Sends a query and waits for the result.
 */
export function sendQueryAndWait(
  ws: WebSocket,
  ast: AST,
  timeoutMs: number = 5000,
): Promise<QueryResult> {
  const message = createAddQueryMessage([{ast}]);
  sendMessage(ws, message);
  return waitForQueryResult(ws, timeoutMs);
}

/**
 * Initializes connection and sends initial queries.
 */
export async function initConnectionWithQueries(
  ws: WebSocket,
  queries: Array<{ast: AST; hash?: string}>,
  timeoutMs: number = 5000,
): Promise<{connected: boolean; messages: Downstream[]}> {
  // Wait for 'connected' message first
  const connectedMsg = await waitForMessageType(ws, 'connected', timeoutMs);
  if (!connectedMsg) {
    return {connected: false, messages: []};
  }

  // Send initConnection
  const initMessage = createInitConnectionMessage(queries);
  sendMessage(ws, initMessage);

  // Collect subsequent messages
  const {messages} = await collectMessages(ws, timeoutMs);

  return {connected: true, messages};
}

/**
 * Creates malformed query patches to test validation.
 */
export function createMalformedQueryPatches(): Record<string, unknown> {
  return {
    // Invalid op
    invalidOp: {
      op: 'exec',
      hash: 'test',
      ast: {table: 'pentest_data'},
    },

    // Missing hash
    missingHash: {
      op: 'put',
      ast: {table: 'pentest_data'},
    },

    // Null hash
    nullHash: {
      op: 'put',
      hash: null,
      ast: {table: 'pentest_data'},
    },

    // Hash as number
    hashAsNumber: {
      op: 'put',
      hash: 12345,
      ast: {table: 'pentest_data'},
    },

    // SQL injection in hash
    sqlInHash: {
      op: 'put',
      hash: "'; DROP TABLE queries;--",
      ast: {table: 'pentest_data'},
    },

    // Empty patch array
    emptyPatch: [],

    // Null patch
    nullPatch: null,

    // Patch as string
    patchAsString: 'invalid',

    // Nested array
    nestedArray: [[{op: 'put', hash: 'test', ast: {table: 'pentest_data'}}]],

    // Very large number of patches
    manyPatches: Array.from({length: 10000}, (_, i) => ({
      op: 'put' as const,
      hash: `hash_${i}`,
      ast: {table: 'pentest_data'},
    })),

    // Negative TTL
    negativeTTL: {
      op: 'put',
      hash: 'test',
      ast: {table: 'pentest_data'},
      ttl: -1,
    },

    // Very large TTL
    largeTTL: {
      op: 'put',
      hash: 'test',
      ast: {table: 'pentest_data'},
      ttl: Number.MAX_SAFE_INTEGER,
    },

    // Infinity TTL
    infinityTTL: {
      op: 'put',
      hash: 'test',
      ast: {table: 'pentest_data'},
      ttl: Infinity,
    },
  };
}

/**
 * Sends a raw message (for testing malformed messages).
 */
export function sendRawMessage(ws: WebSocket, message: unknown): void {
  ws.send(JSON.stringify(message));
}

/**
 * Checks if a message indicates a security issue.
 */
export function isSecurityConcern(result: QueryResult): boolean {
  // Timeout might indicate server crash
  if (result.type === 'timeout') {
    return true;
  }

  // Connection closed unexpectedly might indicate crash
  if (result.type === 'closed' && result.code !== 1000 && result.code < 3000) {
    return true;
  }

  return false;
}

/**
 * Formats a query result for logging.
 */
export function formatQueryResult(result: QueryResult): string {
  switch (result.type) {
    case 'success':
      return `SUCCESS: ${JSON.stringify(result.data).slice(0, 100)}...`;
    case 'error':
      return `ERROR (${result.errorKind}): ${JSON.stringify(result.error)}`;
    case 'timeout':
      return 'TIMEOUT';
    case 'closed':
      return `CLOSED: code=${result.code}, reason=${result.reason}`;
  }
}
