import {resolver} from '@rocicorp/resolver';
import {expect} from 'vitest';
import {randInt} from '../../../../shared/src/rand.ts';
import type {PermissionsConfig} from '../../../../zero-schema/src/compiled-permissions.ts';
import {getConnectionURI, type TestDBs} from '../../test/db.ts';
import {DbFile} from '../../test/lite.ts';
import type {PostgresDB} from '../../types/pg.ts';
import {childWorker} from '../../types/processes.ts';

export interface AuthOptions {
  /** Symmetric secret for HS256/HS384/HS512 JWT verification */
  secret?: string | undefined;
  /** JWK (JSON Web Key) for asymmetric JWT verification */
  jwk?: string | undefined;
  /** URL to fetch JWKS (JSON Web Key Set) */
  jwksUrl?: string | undefined;
}

/**
 * Schema mode for pentest server.
 * - 'minimal': Single table (pentest_data) with no permissions
 * - 'multi-permission': Multiple tables with different permission levels
 * - 'mutation-test': Tables with read/write permissions for mutation testing
 */
export type SchemaMode = 'minimal' | 'multi-permission' | 'mutation-test';

export interface PentestServerOptions {
  adminPassword?: string | undefined;
  nodeEnv?: 'development' | 'production' | undefined;
  logLevel?: string | undefined;
  /** JWT authentication configuration */
  auth?: AuthOptions | undefined;
  /** Schema mode - 'minimal' or 'multi-permission' */
  schemaMode?: SchemaMode | undefined;
}

export interface PentestServer {
  /** Main HTTP port (sync, admin endpoints) */
  port: number;
  /** Replication HTTP port (change-streamer) - typically port + 1 */
  replicationPort: number;
  /** Clean shutdown - stops server and drops databases */
  cleanup: () => Promise<void>;
}

/**
 * Starts a zero-cache server for pentest/integration testing.
 *
 * Based on the pattern from integration.pg.test.ts:473-498.
 */
export async function startPentestServer(
  testDBs: TestDBs,
  options?: PentestServerOptions,
): Promise<PentestServer> {
  const port = randInt(5000, 16000);

  // Create test databases
  const upDB = await testDBs.create('pentest_upstream');
  const cvrDB = await testDBs.create('pentest_cvr');
  const changeDB = await testDBs.create('pentest_change');

  // Create SQLite replica file
  const replicaDbFile = new DbFile('pentest_replica');

  // Set up PostgreSQL schema based on mode
  const schemaMode = options?.schemaMode ?? 'minimal';
  if (schemaMode === 'multi-permission') {
    await setupMultiPermissionSchema(upDB);
  } else if (schemaMode === 'mutation-test') {
    await setupMutationTestSchema(upDB);
  } else {
    await setupMinimalSchema(upDB);
  }

  // Start zero-cache server
  const {promise: ready, resolve: onReady} = resolver<unknown>();
  const {promise: done, resolve: onClose} = resolver<number>();

  // Enable single-process mode so childWorker runs in-process (required for tsx loader)
  process.env['SINGLE_PROCESS'] = '1';

  const env: Record<string, string> = {
    ZERO_PORT: String(port),
    ZERO_LOG_LEVEL: options?.logLevel ?? 'error',
    ZERO_UPSTREAM_DB: getConnectionURI(upDB),
    ZERO_UPSTREAM_MAX_CONNS: '3',
    ZERO_CVR_DB: getConnectionURI(cvrDB),
    ZERO_CVR_MAX_CONNS: '3',
    ZERO_APP_ID: 'pentest',
    ZERO_APP_PUBLICATIONS: 'zero_pentest',
    ZERO_CHANGE_DB: getConnectionURI(changeDB),
    ZERO_REPLICA_FILE: replicaDbFile.path,
    ZERO_NUM_SYNC_WORKERS: '1',
  };

  if (options?.adminPassword) {
    env.ZERO_ADMIN_PASSWORD = options.adminPassword;
  }

  if (options?.nodeEnv) {
    env.NODE_ENV = options.nodeEnv;
  }

  // Auth configuration
  if (options?.auth?.secret) {
    env.ZERO_AUTH_SECRET = options.auth.secret;
  }
  if (options?.auth?.jwk) {
    env.ZERO_AUTH_JWK = options.auth.jwk;
  }
  if (options?.auth?.jwksUrl) {
    env.ZERO_AUTH_JWKS_URL = options.auth.jwksUrl;
  }

  const zero = childWorker(
    new URL('../../server/runner/main.ts', import.meta.url),
    env,
  );
  zero.onMessageType('ready', onReady);
  zero.on('close', onClose);

  await ready;

  return {
    port,
    replicationPort: port + 1,
    cleanup: async () => {
      zero.kill('SIGTERM');
      const exitCode = await done;
      expect(exitCode).toBe(0);
      await testDBs.drop(upDB, cvrDB, changeDB);
      replicaDbFile.delete();
    },
  };
}

/**
 * Sets up minimal PostgreSQL schema required for zero-cache to start.
 */
async function setupMinimalSchema(db: PostgresDB): Promise<void> {
  await db.unsafe(`
    -- Minimal table for zero-cache to replicate
    CREATE TABLE pentest_data (
      id TEXT PRIMARY KEY,
      value TEXT
    );

    -- Publication for logical replication
    CREATE PUBLICATION zero_pentest FOR TABLE pentest_data;

    -- Permissions schema (required by zero-cache)
    CREATE SCHEMA IF NOT EXISTS "pentest";
    CREATE TABLE "pentest".permissions (
      permissions JSON,
      hash TEXT
    );
    INSERT INTO "pentest".permissions (permissions, hash)
    VALUES ('{}', '0');
  `);
}

/**
 * Permissions config for multi-permission schema.
 *
 * Tables:
 * - readable: ANYONE_CAN read (allows all users)
 * - writable: ANYONE_CAN read (for testing writes later)
 * - protected: Only admin role can read
 * - unreadable: No permissions (default deny)
 */
export const MULTI_PERMISSION_CONFIG: PermissionsConfig = {
  tables: {
    readable: {
      row: {
        // ANYONE_CAN read - allow with true condition (OR of empty is false, so use always-true)
        select: [
          [
            'allow',
            {
              type: 'simple',
              op: '=',
              left: {type: 'literal', value: 1},
              right: {type: 'literal', value: 1},
            },
          ],
        ],
      },
    },
    writable: {
      row: {
        // ANYONE_CAN read
        select: [
          [
            'allow',
            {
              type: 'simple',
              op: '=',
              left: {type: 'literal', value: 1},
              right: {type: 'literal', value: 1},
            },
          ],
        ],
      },
    },
    protected: {
      row: {
        // Only admin can read
        select: [
          [
            'allow',
            {
              type: 'simple',
              op: '=',
              left: {type: 'static', anchor: 'authData', field: 'role'},
              right: {type: 'literal', value: 'admin'},
            },
          ],
        ],
      },
    },
    // unreadable: no rules = default deny (all queries return empty)
  },
};

/**
 * Sets up PostgreSQL schema with multiple tables having different permission levels.
 * Used for testing RLS bypass attempts and permission edge cases.
 */
async function setupMultiPermissionSchema(db: PostgresDB): Promise<void> {
  await db.unsafe(`
    -- Table anyone can read
    CREATE TABLE readable (
      id TEXT PRIMARY KEY,
      value TEXT
    );
    INSERT INTO readable (id, value) VALUES
      ('r1', 'readable-value-1'),
      ('r2', 'readable-value-2');

    -- Table anyone can read (for write tests later)
    CREATE TABLE writable (
      id TEXT PRIMARY KEY,
      value TEXT
    );
    INSERT INTO writable (id, value) VALUES
      ('w1', 'writable-value-1'),
      ('w2', 'writable-value-2');

    -- Table only admin can read
    CREATE TABLE protected (
      id TEXT PRIMARY KEY,
      secret TEXT
    );
    INSERT INTO protected (id, secret) VALUES
      ('p1', 'admin-secret-1'),
      ('p2', 'admin-secret-2');

    -- Table with no read permissions (default deny)
    CREATE TABLE unreadable (
      id TEXT PRIMARY KEY,
      data TEXT
    );
    INSERT INTO unreadable (id, data) VALUES
      ('u1', 'hidden-data-1'),
      ('u2', 'hidden-data-2');

    -- Also include pentest_data for backwards compatibility
    CREATE TABLE pentest_data (
      id TEXT PRIMARY KEY,
      value TEXT
    );
    INSERT INTO pentest_data (id, value) VALUES
      ('d1', 'pentest-value-1'),
      ('d2', 'pentest-value-2');

    -- Publication for logical replication (all tables)
    CREATE PUBLICATION zero_pentest FOR TABLE
      readable, writable, protected, unreadable, pentest_data;

    -- Permissions schema with multi-permission config
    CREATE SCHEMA IF NOT EXISTS "pentest";
    CREATE TABLE "pentest".permissions (
      permissions JSON,
      hash TEXT
    );
    INSERT INTO "pentest".permissions (permissions, hash)
    VALUES ('${JSON.stringify(MULTI_PERMISSION_CONFIG).replace(/'/g, "''")}', '1');
  `);
}

/**
 * Permissions config for mutation testing schema.
 *
 * Tables:
 * - public_table: Anyone can read/write/update/delete
 * - auth_required: Requires authentication for writes
 * - owner_only: Can only modify rows you own (authData.sub === row.owner_id)
 * - admin_only: Only admin role can write
 * - readonly_table: No write permissions (read-only)
 */
export const MUTATION_TEST_PERMISSIONS: PermissionsConfig = {
  tables: {
    public_table: {
      row: {
        // Anyone can read
        select: [
          [
            'allow',
            {
              type: 'simple',
              op: '=',
              left: {type: 'literal', value: 1},
              right: {type: 'literal', value: 1},
            },
          ],
        ],
        // Anyone can insert
        insert: [
          [
            'allow',
            {
              type: 'simple',
              op: '=',
              left: {type: 'literal', value: 1},
              right: {type: 'literal', value: 1},
            },
          ],
        ],
        // Anyone can update
        update: {
          preMutation: [
            [
              'allow',
              {
                type: 'simple',
                op: '=',
                left: {type: 'literal', value: 1},
                right: {type: 'literal', value: 1},
              },
            ],
          ],
          postMutation: [
            [
              'allow',
              {
                type: 'simple',
                op: '=',
                left: {type: 'literal', value: 1},
                right: {type: 'literal', value: 1},
              },
            ],
          ],
        },
        // Anyone can delete
        delete: [
          [
            'allow',
            {
              type: 'simple',
              op: '=',
              left: {type: 'literal', value: 1},
              right: {type: 'literal', value: 1},
            },
          ],
        ],
      },
    },
    auth_required: {
      row: {
        // Anyone can read
        select: [
          [
            'allow',
            {
              type: 'simple',
              op: '=',
              left: {type: 'literal', value: 1},
              right: {type: 'literal', value: 1},
            },
          ],
        ],
        // Insert requires auth (authData.sub IS NOT NULL)
        insert: [
          [
            'allow',
            {
              type: 'simple',
              op: 'IS NOT',
              left: {type: 'static', anchor: 'authData', field: 'sub'},
              right: {type: 'literal', value: null},
            },
          ],
        ],
        // Update requires auth
        update: {
          preMutation: [
            [
              'allow',
              {
                type: 'simple',
                op: 'IS NOT',
                left: {type: 'static', anchor: 'authData', field: 'sub'},
                right: {type: 'literal', value: null},
              },
            ],
          ],
          postMutation: [
            [
              'allow',
              {
                type: 'simple',
                op: 'IS NOT',
                left: {type: 'static', anchor: 'authData', field: 'sub'},
                right: {type: 'literal', value: null},
              },
            ],
          ],
        },
        // Delete requires auth
        delete: [
          [
            'allow',
            {
              type: 'simple',
              op: 'IS NOT',
              left: {type: 'static', anchor: 'authData', field: 'sub'},
              right: {type: 'literal', value: null},
            },
          ],
        ],
      },
    },
    owner_only: {
      row: {
        // Anyone can read
        select: [
          [
            'allow',
            {
              type: 'simple',
              op: '=',
              left: {type: 'literal', value: 1},
              right: {type: 'literal', value: 1},
            },
          ],
        ],
        // Insert: owner_id must match authData.sub
        // Note: column must be on left, static parameter on right
        insert: [
          [
            'allow',
            {
              type: 'simple',
              op: '=',
              left: {type: 'column', name: 'owner_id'},
              right: {type: 'static', anchor: 'authData', field: 'sub'},
            },
          ],
        ],
        // Update: owner_id must match authData.sub (pre and post)
        update: {
          preMutation: [
            [
              'allow',
              {
                type: 'simple',
                op: '=',
                left: {type: 'column', name: 'owner_id'},
                right: {type: 'static', anchor: 'authData', field: 'sub'},
              },
            ],
          ],
          postMutation: [
            [
              'allow',
              {
                type: 'simple',
                op: '=',
                left: {type: 'column', name: 'owner_id'},
                right: {type: 'static', anchor: 'authData', field: 'sub'},
              },
            ],
          ],
        },
        // Delete: owner_id must match authData.sub
        delete: [
          [
            'allow',
            {
              type: 'simple',
              op: '=',
              left: {type: 'column', name: 'owner_id'},
              right: {type: 'static', anchor: 'authData', field: 'sub'},
            },
          ],
        ],
      },
    },
    admin_only: {
      row: {
        // Anyone can read
        select: [
          [
            'allow',
            {
              type: 'simple',
              op: '=',
              left: {type: 'literal', value: 1},
              right: {type: 'literal', value: 1},
            },
          ],
        ],
        // Insert requires admin role
        insert: [
          [
            'allow',
            {
              type: 'simple',
              op: '=',
              left: {type: 'static', anchor: 'authData', field: 'role'},
              right: {type: 'literal', value: 'admin'},
            },
          ],
        ],
        // Update requires admin role
        update: {
          preMutation: [
            [
              'allow',
              {
                type: 'simple',
                op: '=',
                left: {type: 'static', anchor: 'authData', field: 'role'},
                right: {type: 'literal', value: 'admin'},
              },
            ],
          ],
          postMutation: [
            [
              'allow',
              {
                type: 'simple',
                op: '=',
                left: {type: 'static', anchor: 'authData', field: 'role'},
                right: {type: 'literal', value: 'admin'},
              },
            ],
          ],
        },
        // Delete requires admin role
        delete: [
          [
            'allow',
            {
              type: 'simple',
              op: '=',
              left: {type: 'static', anchor: 'authData', field: 'role'},
              right: {type: 'literal', value: 'admin'},
            },
          ],
        ],
      },
    },
    // readonly_table: no write rules = default deny for all writes
    readonly_table: {
      row: {
        // Anyone can read
        select: [
          [
            'allow',
            {
              type: 'simple',
              op: '=',
              left: {type: 'literal', value: 1},
              right: {type: 'literal', value: 1},
            },
          ],
        ],
        // No insert/update/delete rules = default deny
      },
    },
  },
};

/**
 * Sets up PostgreSQL schema for mutation security testing.
 * Tables have various permission configurations to test authorization bypass.
 */
async function setupMutationTestSchema(db: PostgresDB): Promise<void> {
  await db.unsafe(`
    -- Table anyone can read/write (no auth required)
    CREATE TABLE public_table (
      id TEXT PRIMARY KEY,
      value TEXT
    );
    INSERT INTO public_table (id, value) VALUES
      ('pub1', 'public-value-1'),
      ('pub2', 'public-value-2');

    -- Table that requires authentication for writes
    CREATE TABLE auth_required (
      id TEXT PRIMARY KEY,
      value TEXT,
      created_by TEXT
    );
    INSERT INTO auth_required (id, value, created_by) VALUES
      ('auth1', 'auth-value-1', 'user-1'),
      ('auth2', 'auth-value-2', 'user-2');

    -- Table where users can only modify their own rows
    CREATE TABLE owner_only (
      id TEXT PRIMARY KEY,
      owner_id TEXT NOT NULL,
      value TEXT
    );
    INSERT INTO owner_only (id, owner_id, value) VALUES
      ('own1', 'user-1', 'owner-value-1'),
      ('own2', 'user-2', 'owner-value-2'),
      ('own3', 'admin', 'admin-value');

    -- Table only admin role can write
    CREATE TABLE admin_only (
      id TEXT PRIMARY KEY,
      secret TEXT
    );
    INSERT INTO admin_only (id, secret) VALUES
      ('adm1', 'admin-secret-1'),
      ('adm2', 'admin-secret-2');

    -- Read-only table (no write permissions)
    CREATE TABLE readonly_table (
      id TEXT PRIMARY KEY,
      value TEXT
    );
    INSERT INTO readonly_table (id, value) VALUES
      ('ro1', 'readonly-value-1'),
      ('ro2', 'readonly-value-2');

    -- Publication for logical replication (all tables)
    CREATE PUBLICATION zero_pentest FOR TABLE
      public_table, auth_required, owner_only, admin_only, readonly_table;

    -- Permissions schema with mutation test config
    CREATE SCHEMA IF NOT EXISTS "pentest";
    CREATE TABLE "pentest".permissions (
      permissions JSON,
      hash TEXT
    );
    INSERT INTO "pentest".permissions (permissions, hash)
    VALUES ('${JSON.stringify(MUTATION_TEST_PERMISSIONS).replace(/'/g, "''")}', '1');
  `);
}
