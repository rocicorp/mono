import {resolver} from '@rocicorp/resolver';
import {expect} from 'vitest';
import {randInt} from '../../../../shared/src/rand.ts';
import {getConnectionURI, type TestDBs} from '../../test/db.ts';
import {DbFile} from '../../test/lite.ts';
import type {PostgresDB} from '../../types/pg.ts';
import {childWorker, type Worker} from '../../types/processes.ts';

export interface PentestServerOptions {
  adminPassword?: string | undefined;
  nodeEnv?: 'development' | 'production' | undefined;
  logLevel?: string | undefined;
}

export interface PentestServer {
  /** Main HTTP port (sync, admin endpoints) */
  port: number;
  /** Replication HTTP port (change-streamer) - typically port + 1 */
  replicationPort: number;
  /** Clean shutdown - stops server and drops databases */
  cleanup: () => Promise<void>;
}

/**
 * Starts a zero-cache server for pentest/integration testing.
 *
 * Based on the pattern from integration.pg.test.ts:473-498.
 */
export async function startPentestServer(
  testDBs: TestDBs,
  options?: PentestServerOptions,
): Promise<PentestServer> {
  const port = randInt(5000, 16000);

  // Create test databases
  const upDB = await testDBs.create('pentest_upstream');
  const cvrDB = await testDBs.create('pentest_cvr');
  const changeDB = await testDBs.create('pentest_change');

  // Create SQLite replica file
  const replicaDbFile = new DbFile('pentest_replica');

  // Set up minimal PostgreSQL schema for zero-cache
  await setupMinimalSchema(upDB);

  // Start zero-cache server
  const {promise: ready, resolve: onReady} = resolver<unknown>();
  const {promise: done, resolve: onClose} = resolver<number>();

  // Enable single-process mode so childWorker runs in-process (required for tsx loader)
  process.env['SINGLE_PROCESS'] = '1';

  const env: Record<string, string> = {
    ZERO_PORT: String(port),
    ZERO_LOG_LEVEL: options?.logLevel ?? 'error',
    ZERO_UPSTREAM_DB: getConnectionURI(upDB),
    ZERO_UPSTREAM_MAX_CONNS: '3',
    ZERO_CVR_DB: getConnectionURI(cvrDB),
    ZERO_CVR_MAX_CONNS: '3',
    ZERO_APP_ID: 'pentest',
    ZERO_APP_PUBLICATIONS: 'zero_pentest',
    ZERO_CHANGE_DB: getConnectionURI(changeDB),
    ZERO_REPLICA_FILE: replicaDbFile.path,
    ZERO_NUM_SYNC_WORKERS: '1',
  };

  if (options?.adminPassword) {
    env.ZERO_ADMIN_PASSWORD = options.adminPassword;
  }

  if (options?.nodeEnv) {
    env.NODE_ENV = options.nodeEnv;
  }

  const zero = childWorker(
    new URL('../../server/runner/main.ts', import.meta.url),
    env,
  );
  zero.onMessageType('ready', onReady);
  zero.on('close', onClose);

  await ready;

  return {
    port,
    replicationPort: port + 1,
    cleanup: async () => {
      zero.kill('SIGTERM');
      const exitCode = await done;
      expect(exitCode).toBe(0);
      await testDBs.drop(upDB, cvrDB, changeDB);
      replicaDbFile.delete();
    },
  };
}

/**
 * Sets up minimal PostgreSQL schema required for zero-cache to start.
 */
async function setupMinimalSchema(db: PostgresDB): Promise<void> {
  await db.unsafe(`
    -- Minimal table for zero-cache to replicate
    CREATE TABLE pentest_data (
      id TEXT PRIMARY KEY,
      value TEXT
    );

    -- Publication for logical replication
    CREATE PUBLICATION zero_pentest FOR TABLE pentest_data;

    -- Permissions schema (required by zero-cache)
    CREATE SCHEMA IF NOT EXISTS "pentest";
    CREATE TABLE "pentest".permissions (
      permissions JSON,
      hash TEXT
    );
    INSERT INTO "pentest".permissions (permissions, hash)
    VALUES ('{}', '0');
  `);
}
