/**
 * SSRF Testing Helpers
 *
 * Utilities for testing Server-Side Request Forgery vulnerabilities
 * in Zero's custom endpoint handling.
 *
 * Key attack vectors:
 * - Private IP bypass (127.0.0.1, 169.254.x.x, 10.x.x.x)
 * - DNS rebinding simulation
 * - HTTP redirect chain following
 * - URL parsing edge cases (unicode, punycode)
 */

import {createServer, type IncomingMessage, type ServerResponse} from 'http';
import {resolver} from '@rocicorp/resolver';

/**
 * SSRF test URL patterns.
 */
export const SSRF_TEST_URLS = {
  // Private IP addresses
  privateIPs: {
    localhost: 'http://localhost/test',
    loopback: 'http://127.0.0.1/test',
    loopbackVariants: [
      'http://127.0.0.1/test',
      'http://127.0.0.2/test',
      'http://127.255.255.255/test',
      'http://0.0.0.0/test',
      'http://0/test',
    ],
    privateA: 'http://10.0.0.1/test',
    privateB: 'http://172.16.0.1/test',
    privateC: 'http://192.168.1.1/test',
    linkLocal: 'http://169.254.169.254/test', // AWS metadata endpoint
    linkLocalAlias: 'http://169.254.169.254/latest/meta-data/',
  },

  // URL parsing tricks
  urlParsing: {
    // @ symbol tricks
    atSymbol: 'http://google.com@127.0.0.1/test',
    multipleAt: 'http://a@b@127.0.0.1/test',
    // Decimal IP encoding
    decimalIP: 'http://2130706433/test', // 127.0.0.1 as decimal
    // Octal IP encoding
    octalIP: 'http://0177.0.0.1/test', // 127.0.0.1 in octal
    octalFull: 'http://0177.0000.0000.0001/test',
    // Hex IP encoding
    hexIP: 'http://0x7f.0x0.0x0.0x1/test', // 127.0.0.1 in hex
    hexFull: 'http://0x7f000001/test',
    // Mixed encoding
    mixedIP: 'http://0x7f.0.0.1/test',
  },

  // Unicode tricks
  unicode: {
    homoglyph: 'http://ⓔⓧⓐⓜⓟⓛⓔ.com/test', // Circled letters
    punycode: 'http://xn--exmple-cua.com/test', // Punycode
    fullwidth: 'http://ｅｘａｍｐｌｅ．ｃｏｍ/test', // Fullwidth
    rtlOverride: 'http://example.com\u202emoc.live/test', // RTL override
  },

  // DNS rebinding simulation URLs (conceptual - require actual DNS setup)
  dnsRebinding: {
    // These would need actual DNS rebinding setup to work
    rebindService: 'http://rebind.127.0.0.1.nip.io/test',
    rebindLocal: 'http://127.0.0.1.nip.io/test',
    rebindMetadata: 'http://169.254.169.254.nip.io/test',
  },

  // Path traversal in URL
  pathTraversal: {
    dotDot: 'http://example.com/../../../etc/passwd',
    encoded: 'http://example.com/%2e%2e/%2e%2e/etc/passwd',
    doubleEncoded: 'http://example.com/%252e%252e/%252e%252e/etc/passwd',
  },

  // Protocol tricks
  protocols: {
    file: 'file:///etc/passwd',
    gopher: 'gopher://127.0.0.1:9000/_test',
    dict: 'dict://127.0.0.1:11211/info',
    ftp: 'ftp://127.0.0.1/test',
    ldap: 'ldap://127.0.0.1/test',
    ssh: 'ssh://127.0.0.1/test',
  },
};

/**
 * Creates a mock HTTP server for SSRF testing.
 * Can be configured to redirect to specific URLs.
 */
export interface MockSSRFServer {
  port: number;
  baseUrl: string;
  /** Close the server */
  close: () => Promise<void>;
  /** Set response for next request */
  setNextResponse: (response: MockResponse) => void;
  /** Get request log */
  getRequests: () => RecordedRequest[];
  /** Clear request log */
  clearRequests: () => void;
}

export interface MockResponse {
  status?: number | undefined;
  headers?: Record<string, string> | undefined;
  body?: string | undefined;
  /** If set, redirects to this URL */
  redirectTo?: string | undefined;
  /** Delay before responding (ms) */
  delay?: number | undefined;
}

export interface RecordedRequest {
  method: string;
  url: string;
  headers: Record<string, string | string[] | undefined>;
  body: string;
  timestamp: number;
}

export async function createMockSSRFServer(): Promise<MockSSRFServer> {
  const requests: RecordedRequest[] = [];
  let nextResponse: MockResponse = {status: 200, body: '{}'};

  const server = createServer(async (req: IncomingMessage, res: ServerResponse) => {
    // Collect request body
    const chunks: Buffer[] = [];
    for await (const chunk of req) {
      chunks.push(chunk as Buffer);
    }
    const body = Buffer.concat(chunks).toString();

    // Record request
    requests.push({
      method: req.method ?? 'GET',
      url: req.url ?? '/',
      headers: req.headers as Record<string, string | string[] | undefined>,
      body,
      timestamp: Date.now(),
    });

    // Apply delay if configured
    if (nextResponse.delay) {
      await new Promise(resolve => setTimeout(resolve, nextResponse.delay));
    }

    // Handle redirect
    if (nextResponse.redirectTo) {
      res.writeHead(302, {
        Location: nextResponse.redirectTo,
        ...nextResponse.headers,
      });
      res.end();
      return;
    }

    // Send configured response
    res.writeHead(nextResponse.status ?? 200, {
      'Content-Type': 'application/json',
      ...nextResponse.headers,
    });
    res.end(nextResponse.body ?? '{}');
  });

  // Start server on random port
  const {promise: started, resolve: onStarted} = resolver<number>();
  server.listen(0, '127.0.0.1', () => {
    const addr = server.address();
    if (addr && typeof addr === 'object') {
      onStarted(addr.port);
    }
  });

  const port = await started;

  return {
    port,
    baseUrl: `http://127.0.0.1:${port}`,
    close: async () => {
      return new Promise((resolve, reject) => {
        server.close(err => {
          if (err) reject(err);
          else resolve();
        });
      });
    },
    setNextResponse: (response: MockResponse) => {
      nextResponse = response;
    },
    getRequests: () => [...requests],
    clearRequests: () => {
      requests.length = 0;
    },
  };
}

/**
 * URL patterns that should be blocked by a secure SSRF filter.
 */
export const BLOCKED_URL_PATTERNS = [
  // Loopback
  /^https?:\/\/(localhost|127\.\d+\.\d+\.\d+|0\.0\.0\.0|\[::1\])/i,
  // Private networks
  /^https?:\/\/(10\.\d+\.\d+\.\d+|172\.(1[6-9]|2\d|3[01])\.\d+\.\d+|192\.168\.\d+\.\d+)/i,
  // Link-local
  /^https?:\/\/169\.254\.\d+\.\d+/i,
  // Decimal/octal/hex IP encoding
  /^https?:\/\/(0x[0-9a-f]+|\d{8,}|0\d+\.)/i,
];

/**
 * Checks if a URL should be blocked by SSRF protection.
 */
export function shouldBeBlocked(url: string): boolean {
  for (const pattern of BLOCKED_URL_PATTERNS) {
    if (pattern.test(url)) {
      return true;
    }
  }
  return false;
}

/**
 * Generates URLs with various encoding tricks for a target host.
 */
export function generateEncodedURLs(host: string, path: string = '/test'): string[] {
  // Convert IP to different representations
  const urls: string[] = [`http://${host}${path}`];

  // Try to parse as IP
  const ipMatch = host.match(/^(\d+)\.(\d+)\.(\d+)\.(\d+)$/);
  if (ipMatch) {
    const [, a, b, c, d] = ipMatch.map(Number);

    // Decimal encoding
    const decimal = ((a << 24) >>> 0) + (b << 16) + (c << 8) + d;
    urls.push(`http://${decimal}${path}`);

    // Octal encoding
    urls.push(`http://${toOctal(a)}.${toOctal(b)}.${toOctal(c)}.${toOctal(d)}${path}`);

    // Hex encoding
    urls.push(`http://0x${toHex(a)}.0x${toHex(b)}.0x${toHex(c)}.0x${toHex(d)}${path}`);

    // Full hex
    urls.push(`http://0x${decimal.toString(16)}${path}`);

    // Mixed encoding
    urls.push(`http://0x${toHex(a)}.${b}.${toOctal(c)}.${d}${path}`);
  }

  return urls;
}

function toOctal(n: number): string {
  return '0' + n.toString(8);
}

function toHex(n: number): string {
  return n.toString(16).padStart(2, '0');
}

/**
 * Creates a redirect chain for testing redirect following.
 * Returns an array of mock responses that, when applied in sequence,
 * form a redirect chain ending at the target URL.
 */
export function createRedirectChain(
  intermediateCount: number,
  finalTarget: string,
): MockResponse[] {
  const responses: MockResponse[] = [];

  for (let i = 0; i < intermediateCount; i++) {
    responses.push({
      status: 302,
      redirectTo: i === intermediateCount - 1 ? finalTarget : `/redirect-${i + 1}`,
    });
  }

  return responses;
}

/**
 * Test vectors for header injection via SSRF.
 */
export const HEADER_INJECTION_PAYLOADS = {
  // CRLF injection attempts in URL
  crlfInPath: '/test%0d%0aX-Injected: malicious',
  crlfInQuery: '/test?param=value%0d%0aX-Injected: malicious',
  // Host header injection
  hostOverride: {
    path: '/test',
    headers: {'Host': '127.0.0.1'},
  },
  // X-Forwarded-* injection
  xForwarded: {
    path: '/test',
    headers: {
      'X-Forwarded-For': '127.0.0.1',
      'X-Forwarded-Host': '127.0.0.1',
      'X-Forwarded-Proto': 'http',
    },
  },
};
