/**
 * AST Fuzzer - Generates malformed AST variants for security testing.
 *
 * Tests for:
 * - Valita validation bypass
 * - SQL injection via malformed structures
 * - Type confusion attacks
 * - Resource exhaustion
 */

import type {
  AST,
  Condition,
  SimpleCondition,
} from '../../../../zero-protocol/src/ast.ts';

// ============================================================================
// SQL Injection Payloads
// ============================================================================

/**
 * SQL injection payloads for testing parameterization and escaping.
 */
export const SQL_INJECTION_PAYLOADS = {
  // Classic SQL injection
  basicInjection: "'; DROP TABLE users;--",
  unionSelect: "' UNION SELECT * FROM users--",
  commentTermination: "admin'--",
  orAlwaysTrue: "' OR '1'='1",
  semicolonBreak: "test'; DELETE FROM users;--",

  // Quoted variations
  doubleQuote: '" OR "1"="1',
  backtick: '`; DROP TABLE users;--',
  mixedQuotes: `"'; DROP TABLE--`,

  // Unicode/encoding attacks
  nullByte: "test\x00' OR '1'='1",
  unicodeQuote: 'test\u0027 OR 1=1--', // Unicode single quote
  utf8Overlong: 'test\xc0\x27 OR 1=1--', // Overlong UTF-8 for '

  // PostgreSQL-specific
  dollarQuote: '$tag$; DROP TABLE users;$tag$',
  escapeSequence: "E'\\'; DROP TABLE users;--",
  copyCommand: "COPY users TO '/tmp/data';--",
  pgSleep: "'; SELECT pg_sleep(10);--",

  // Stacked queries
  stackedQuery: "test'; INSERT INTO users VALUES('hacked');--",
  multiStatement: '1; UPDATE users SET admin=true;--',

  // Time-based blind injection
  timeBlind: "' AND (SELECT CASE WHEN (1=1) THEN pg_sleep(5) ELSE 1 END);--",

  // Error-based injection
  errorBased: "' AND 1=CONVERT(int, (SELECT TOP 1 password FROM users));--",

  // JSON injection (for JSONB columns)
  jsonInjection: '{"key": "value", "$where": "this.password"}',
} as const;

/**
 * Table names that could be injection vectors if not properly escaped.
 */
export const MALICIOUS_TABLE_NAMES = [
  'users"; DROP TABLE users--',
  "test'; DELETE FROM test--",
  'pg_tables',
  'information_schema.tables',
  '__proto__',
  'constructor',
  'prototype',
  '../../../etc/passwd',
  'UNION SELECT * FROM users',
];

/**
 * Column names that could be injection vectors.
 */
export const MALICIOUS_COLUMN_NAMES = [
  'id OR 1=1--',
  '1; DROP TABLE users;--',
  '*',
  'password FROM users--',
  '__proto__',
  'constructor',
];

// ============================================================================
// Boundary Value Payloads
// ============================================================================

export const BOUNDARY_VALUES = {
  // Number boundaries
  maxSafeInteger: Number.MAX_SAFE_INTEGER,
  minSafeInteger: Number.MIN_SAFE_INTEGER,
  maxValue: Number.MAX_VALUE,
  minValue: Number.MIN_VALUE,
  negativeOne: -1,
  negativeZero: -0,
  infinity: Infinity,
  negativeInfinity: -Infinity,
  nan: NaN,
  epsilon: Number.EPSILON,

  // String boundaries
  emptyString: '',
  nullChar: '\x00',
  maxLengthString: 'x'.repeat(100000),
  unicodeString: '\u0000\u0001\u0002\uFFFF',
  newlines: '\n\r\n\r',
  tabs: '\t\t\t',
  spaces: ' '.repeat(10000),
} as const;

// ============================================================================
// AST Structure Generators
// ============================================================================

/**
 * Creates a valid base AST for testing.
 */
export function createValidAST(table: string = 'pentest_data'): AST {
  return {
    table,
    where: {
      type: 'simple',
      op: '=',
      left: {type: 'column', name: 'id'},
      right: {type: 'literal', value: 'test'},
    },
  };
}

/**
 * Creates malformed AST structures that might bypass validation.
 */
export function createMalformedASTs(): Record<string, unknown> {
  const validAST = createValidAST();

  return {
    // Missing required fields
    missingTable: {
      where: validAST.where,
    },

    // Empty table name
    emptyTable: {
      table: '',
    },

    // Null table
    nullTable: {
      table: null,
    },

    // Undefined table
    undefinedTable: {
      table: undefined,
    },

    // Wrong types
    tableAsNumber: {
      table: 12345,
    },
    tableAsArray: {
      table: ['users'],
    },
    tableAsObject: {
      table: {name: 'users'},
    },

    // Prototype pollution attempts
    protoInjection: {
      table: 'pentest_data',
      __proto__: {admin: true},
    },
    constructorInjection: {
      table: 'pentest_data',
      constructor: {prototype: {admin: true}},
    },

    // Extra unexpected fields
    extraFields: {
      table: 'pentest_data',
      unknownField: 'malicious',
      anotherField: {nested: 'value'},
    },

    // Array instead of object
    astAsArray: ['pentest_data', {where: validAST.where}],

    // Nested table reference
    nestedTableRef: {
      table: {table: 'pentest_data'},
    },

    // SQL in table name
    sqlInTable: {
      table: SQL_INJECTION_PAYLOADS.basicInjection,
    },
  };
}

/**
 * Creates ASTs with malformed WHERE conditions.
 */
export function createMalformedConditions(): Record<string, AST> {
  return {
    // Invalid condition type
    invalidConditionType: {
      table: 'pentest_data',
      where: {
        type: 'EXEC' as 'simple',
        op: '=',
        left: {type: 'column', name: 'id'},
        right: {type: 'literal', value: 'test'},
      },
    },

    // Invalid operator
    invalidOperator: {
      table: 'pentest_data',
      where: {
        type: 'simple',
        op: 'EXEC' as '=',
        left: {type: 'column', name: 'id'},
        right: {type: 'literal', value: 'test'},
      },
    },

    // SQL injection in operator
    sqlInOperator: {
      table: 'pentest_data',
      where: {
        type: 'simple',
        op: "='; DROP TABLE--" as '=',
        left: {type: 'column', name: 'id'},
        right: {type: 'literal', value: 'test'},
      },
    },

    // Missing left side
    missingLeft: {
      table: 'pentest_data',
      where: {
        type: 'simple',
        op: '=',
        right: {type: 'literal', value: 'test'},
      } as unknown as SimpleCondition,
    },

    // Missing right side
    missingRight: {
      table: 'pentest_data',
      where: {
        type: 'simple',
        op: '=',
        left: {type: 'column', name: 'id'},
      } as unknown as SimpleCondition,
    },

    // Null in condition values
    nullLeft: {
      table: 'pentest_data',
      where: {
        type: 'simple',
        op: '=',
        left: null as unknown as {type: 'column'; name: string},
        right: {type: 'literal', value: 'test'},
      },
    },

    // Empty AND conditions
    emptyAnd: {
      table: 'pentest_data',
      where: {
        type: 'and',
        conditions: [],
      },
    },

    // Empty OR conditions
    emptyOr: {
      table: 'pentest_data',
      where: {
        type: 'or',
        conditions: [],
      },
    },

    // SQL injection in column name
    sqlInColumn: {
      table: 'pentest_data',
      where: {
        type: 'simple',
        op: '=',
        left: {type: 'column', name: 'id; DROP TABLE users--'},
        right: {type: 'literal', value: 'test'},
      },
    },

    // SQL injection in literal value
    sqlInLiteral: {
      table: 'pentest_data',
      where: {
        type: 'simple',
        op: '=',
        left: {type: 'column', name: 'id'},
        right: {type: 'literal', value: SQL_INJECTION_PAYLOADS.basicInjection},
      },
    },

    // Array with SQL injection
    sqlInArray: {
      table: 'pentest_data',
      where: {
        type: 'simple',
        op: 'IN',
        left: {type: 'column', name: 'id'},
        right: {
          type: 'literal',
          value: ['normal', SQL_INJECTION_PAYLOADS.basicInjection, 'test'],
        },
      },
    },

    // Invalid value type in literal
    objectAsLiteralValue: {
      table: 'pentest_data',
      where: {
        type: 'simple',
        op: '=',
        left: {type: 'column', name: 'id'},
        right: {
          type: 'literal',
          value: {nested: 'object'} as unknown as string,
        },
      },
    },

    // Negative array in IN clause
    negativeArrayIndex: {
      table: 'pentest_data',
      where: {
        type: 'simple',
        op: 'IN',
        left: {type: 'column', name: 'id'},
        right: {type: 'literal', value: []},
      },
    },
  };
}

/**
 * Creates deeply nested conditions for recursion testing.
 */
export function createDeepNesting(depth: number): Condition {
  if (depth <= 0) {
    return {
      type: 'simple',
      op: '=',
      left: {type: 'column', name: 'id'},
      right: {type: 'literal', value: 'test'},
    };
  }

  return {
    type: 'and',
    conditions: [createDeepNesting(depth - 1)],
  };
}

/**
 * Creates deeply nested related subqueries.
 */
export function createDeepRelatedNesting(table: string, depth: number): AST {
  if (depth <= 0) {
    return {table};
  }

  return {
    table,
    alias: `level_${depth}`,
    related: [
      {
        correlation: {
          parentField: ['id'],
          childField: ['parentId'],
        },
        subquery: createDeepRelatedNesting(table, depth - 1),
      },
    ],
  };
}

/**
 * Creates ASTs that might cause resource exhaustion.
 */
export function createResourceExhaustionASTs(): Record<string, AST> {
  return {
    // Many conditions in single WHERE
    manyConditions: {
      table: 'pentest_data',
      where: {
        type: 'and',
        conditions: Array.from({length: 1000}, (_, i) => ({
          type: 'simple' as const,
          op: '=' as const,
          left: {type: 'column' as const, name: 'id'},
          right: {type: 'literal' as const, value: `val${i}`},
        })),
      },
    },

    // Large IN clause
    largeInClause: {
      table: 'pentest_data',
      where: {
        type: 'simple',
        op: 'IN',
        left: {type: 'column', name: 'id'},
        right: {
          type: 'literal',
          value: Array.from({length: 10000}, (_, i) => `val${i}`),
        },
      },
    },

    // Very long string literal
    longStringLiteral: {
      table: 'pentest_data',
      where: {
        type: 'simple',
        op: '=',
        left: {type: 'column', name: 'id'},
        right: {type: 'literal', value: 'x'.repeat(1000000)},
      },
    },

    // Deep nesting
    deepNesting: {
      table: 'pentest_data',
      where: createDeepNesting(100),
    },

    // Deep related nesting
    deepRelatedNesting: createDeepRelatedNesting('pentest_data', 50),

    // Many related subqueries
    manyRelated: {
      table: 'pentest_data',
      related: Array.from({length: 100}, (_, i) => ({
        correlation: {
          parentField: ['id'] as [string],
          childField: ['parentId'] as [string],
        },
        subquery: {
          table: 'pentest_data',
          alias: `subq_${i}`,
        },
      })),
    },
  };
}

// ============================================================================
// RLS Bypass Attempts
// ============================================================================

/**
 * Creates ASTs that attempt to bypass Row-Level Security.
 */
export function createRLSBypassASTs(): Record<string, AST | unknown> {
  return {
    // Query unreadable table directly
    queryUnreadable: {
      table: 'unreadable',
    },

    // Try to access protected table
    queryProtected: {
      table: 'protected',
    },

    // EXISTS subquery to oracle protected data
    existsOracle: {
      table: 'readable',
      where: {
        type: 'correlatedSubquery',
        op: 'EXISTS',
        related: {
          correlation: {
            parentField: ['id'],
            childField: ['id'],
          },
          subquery: {
            table: 'protected',
            alias: 'p',
            where: {
              type: 'simple',
              op: '=',
              left: {type: 'column', name: 'secret'},
              right: {type: 'literal', value: 'password123'},
            },
          },
        },
      },
    },

    // Try to use internalQuery flag (should be stripped)
    internalQueryInjection: {
      table: 'unreadable',
      internalQuery: true,
    },

    // Reserved query ID attempt
    reservedQueryId: {
      table: 'readable',
      alias: 'lmids', // Reserved internal query name
    },

    // Static parameter injection attempt
    authDataInjection: {
      table: 'protected',
      where: {
        type: 'simple',
        op: '=',
        left: {
          type: 'static',
          anchor: 'authData',
          field: 'role',
        },
        right: {type: 'literal', value: 'admin'},
      },
    },

    // Nested EXISTS to probe unreadable
    nestedExistsOracle: {
      table: 'readable',
      where: {
        type: 'and',
        conditions: [
          {
            type: 'correlatedSubquery',
            op: 'EXISTS',
            related: {
              correlation: {
                parentField: ['id'],
                childField: ['readableId'],
              },
              subquery: {
                table: 'unreadable',
                alias: 'unread',
                where: {
                  type: 'simple',
                  op: 'LIKE',
                  left: {type: 'column', name: 'data'},
                  right: {type: 'literal', value: 'secret%'},
                },
              },
            },
          },
        ],
      },
    },

    // System flag injection
    systemFlagInjection: {
      table: 'readable',
      related: [
        {
          correlation: {
            parentField: ['id'],
            childField: ['id'],
          },
          subquery: {
            table: 'protected',
            alias: 'prot',
          },
          system: 'permissions', // Try to mark as system query
        },
      ],
    },
  };
}

// ============================================================================
// authData Edge Cases
// ============================================================================

/**
 * Creates various authData structures for testing permission evaluation.
 */
export function createAuthDataVariants(): Record<string, unknown> {
  return {
    // Normal case
    normal: {sub: 'user123', role: 'user'},

    // Empty object
    empty: {},

    // Null value
    nullValue: null,

    // Undefined
    undefinedValue: undefined,

    // Admin role
    admin: {sub: 'admin', role: 'admin'},

    // Array instead of object
    array: ['user', 'admin'],

    // Deeply nested
    deeplyNested: {
      user: {
        profile: {
          permissions: {
            role: 'admin',
          },
        },
      },
    },

    // Array in claims
    arrayClaims: {
      sub: 'user',
      roles: ['user', 'admin'],
      permissions: ['read', 'write'],
    },

    // SQL injection in claim values
    sqlInClaims: {
      sub: SQL_INJECTION_PAYLOADS.basicInjection,
      role: "admin'; DROP TABLE users;--",
    },

    // Prototype pollution in authData
    protoInAuth: {
      __proto__: {role: 'admin'},
      sub: 'user',
    },

    // Very large authData
    largeAuthData: {
      sub: 'user',
      data: 'x'.repeat(100000),
      claims: Array.from({length: 1000}, (_, i) => `claim${i}`),
    },

    // Numeric string that looks like injection
    numericInjection: {
      sub: '1 OR 1=1',
      id: '0; DROP TABLE users',
    },
  };
}

// ============================================================================
// Limit/Ordering Edge Cases
// ============================================================================

/**
 * Creates ASTs with edge case limit values.
 */
export function createLimitEdgeCases(): Record<string, AST> {
  return {
    // Negative limit
    negativeLimit: {
      table: 'pentest_data',
      limit: -1,
    },

    // Zero limit
    zeroLimit: {
      table: 'pentest_data',
      limit: 0,
    },

    // Very large limit
    largeLimit: {
      table: 'pentest_data',
      limit: Number.MAX_SAFE_INTEGER,
    },

    // Infinity limit
    infinityLimit: {
      table: 'pentest_data',
      limit: Infinity as unknown as number,
    },

    // NaN limit
    nanLimit: {
      table: 'pentest_data',
      limit: NaN as unknown as number,
    },

    // Float limit
    floatLimit: {
      table: 'pentest_data',
      limit: 10.5,
    },

    // String limit (type confusion)
    stringLimit: {
      table: 'pentest_data',
      limit: '10; DROP TABLE' as unknown as number,
    },
  };
}

/**
 * Creates ASTs with edge case ordering.
 */
export function createOrderingEdgeCases(): Record<string, AST> {
  return {
    // SQL injection in order column
    sqlInOrderColumn: {
      table: 'pentest_data',
      orderBy: [['id; DROP TABLE--', 'asc']],
    },

    // Invalid direction
    invalidDirection: {
      table: 'pentest_data',
      orderBy: [['id', 'EXEC' as 'asc']],
    },

    // Empty string column
    emptyColumnOrder: {
      table: 'pentest_data',
      orderBy: [['', 'asc']],
    },

    // Many order columns
    manyOrderColumns: {
      table: 'pentest_data',
      orderBy: Array.from(
        {length: 100},
        (_, i) =>
          [`col${i}`, i % 2 === 0 ? 'asc' : 'desc'] as [string, 'asc' | 'desc'],
      ),
    },

    // Duplicate order columns
    duplicateOrderColumns: {
      table: 'pentest_data',
      orderBy: [
        ['id', 'asc'],
        ['id', 'desc'],
      ],
    },
  };
}

// ============================================================================
// Start/Cursor Edge Cases
// ============================================================================

/**
 * Creates ASTs with edge case start/cursor values.
 */
export function createStartEdgeCases(): Record<string, AST> {
  return {
    // SQL injection in start row
    sqlInStartRow: {
      table: 'pentest_data',
      start: {
        row: {id: SQL_INJECTION_PAYLOADS.basicInjection},
        exclusive: true,
      },
    },

    // Empty start row
    emptyStartRow: {
      table: 'pentest_data',
      start: {
        row: {},
        exclusive: true,
      },
    },

    // Null values in start row
    nullInStartRow: {
      table: 'pentest_data',
      start: {
        row: {id: null},
        exclusive: true,
      },
    },

    // Prototype pollution in start row
    protoInStartRow: {
      table: 'pentest_data',
      start: {
        row: {id: 'test', __proto__: {admin: true}} as {id: string},
        exclusive: true,
      },
    },

    // Non-boolean exclusive
    nonBooleanExclusive: {
      table: 'pentest_data',
      start: {
        row: {id: 'test'},
        exclusive: 'yes' as unknown as boolean,
      },
    },
  };
}

// ============================================================================
// Export all generators
// ============================================================================

export const fuzzers = {
  malformedASTs: createMalformedASTs,
  malformedConditions: createMalformedConditions,
  deepNesting: createDeepNesting,
  deepRelatedNesting: createDeepRelatedNesting,
  resourceExhaustion: createResourceExhaustionASTs,
  rlsBypass: createRLSBypassASTs,
  authDataVariants: createAuthDataVariants,
  limitEdgeCases: createLimitEdgeCases,
  orderingEdgeCases: createOrderingEdgeCases,
  startEdgeCases: createStartEdgeCases,
  sqlInjection: SQL_INJECTION_PAYLOADS,
  maliciousTableNames: MALICIOUS_TABLE_NAMES,
  maliciousColumnNames: MALICIOUS_COLUMN_NAMES,
  boundaryValues: BOUNDARY_VALUES,
};
