/**
 * Mutation Security Testing Helpers
 *
 * Utilities for generating mutation payloads to test authorization,
 * credential handling, and mutation routing in zero-cache.
 */

import {SignJWT} from 'jose';
import type {ReadonlyJSONValue} from '../../../../shared/src/json.ts';
import type {PrimaryKey} from '../../../../zero-protocol/src/primary-key.ts';
import type {Upstream} from '../../../../zero-protocol/src/up.ts';
import {
  CRUD_MUTATION_NAME,
  type CRUDMutation,
  type CRUDOp,
  type CustomMutation,
  type InsertOp,
  type UpdateOp,
  type DeleteOp,
  type UpsertOp,
} from '../../../../zero-protocol/src/push.ts';

type MutationValue = Readonly<Record<string, ReadonlyJSONValue | undefined>>;

// ============================================================================
// CRUD Mutation Generators
// ============================================================================

/**
 * Creates a valid CRUD mutation with insert operation.
 */
export function createInsertMutation(
  clientID: string,
  mutationID: number,
  tableName: string,
  value: Record<string, unknown>,
  primaryKey: PrimaryKey = ['id'] as const,
): CRUDMutation {
  return {
    type: 'crud',
    id: mutationID,
    clientID,
    name: CRUD_MUTATION_NAME,
    args: [
      {
        ops: [
          {
            op: 'insert',
            tableName,
            primaryKey,
            value: value as MutationValue,
          } satisfies InsertOp,
        ],
      },
    ],
    timestamp: Date.now(),
  };
}

/**
 * Creates a valid CRUD mutation with update operation.
 */
export function createUpdateMutation(
  clientID: string,
  mutationID: number,
  tableName: string,
  value: Record<string, unknown>,
  primaryKey: PrimaryKey = ['id'] as const,
): CRUDMutation {
  return {
    type: 'crud',
    id: mutationID,
    clientID,
    name: CRUD_MUTATION_NAME,
    args: [
      {
        ops: [
          {
            op: 'update',
            tableName,
            primaryKey,
            value: value as MutationValue,
          } satisfies UpdateOp,
        ],
      },
    ],
    timestamp: Date.now(),
  };
}

/**
 * Creates a valid CRUD mutation with delete operation.
 */
export function createDeleteMutation(
  clientID: string,
  mutationID: number,
  tableName: string,
  value: Record<string, unknown>,
  primaryKey: PrimaryKey = ['id'] as const,
): CRUDMutation {
  return {
    type: 'crud',
    id: mutationID,
    clientID,
    name: CRUD_MUTATION_NAME,
    args: [
      {
        ops: [
          {
            op: 'delete',
            tableName,
            primaryKey,
            value: value as Readonly<Record<string, string | number | boolean>>,
          } satisfies DeleteOp,
        ],
      },
    ],
    timestamp: Date.now(),
  };
}

/**
 * Creates a valid CRUD mutation with upsert operation.
 */
export function createUpsertMutation(
  clientID: string,
  mutationID: number,
  tableName: string,
  value: Record<string, unknown>,
  primaryKey: PrimaryKey = ['id'] as const,
): CRUDMutation {
  return {
    type: 'crud',
    id: mutationID,
    clientID,
    name: CRUD_MUTATION_NAME,
    args: [
      {
        ops: [
          {
            op: 'upsert',
            tableName,
            primaryKey,
            value: value as MutationValue,
          } satisfies UpsertOp,
        ],
      },
    ],
    timestamp: Date.now(),
  };
}

/**
 * Creates a CRUD mutation with multiple operations.
 */
export function createMultiOpMutation(
  clientID: string,
  mutationID: number,
  ops: CRUDOp[],
): CRUDMutation {
  return {
    type: 'crud',
    id: mutationID,
    clientID,
    name: CRUD_MUTATION_NAME,
    args: [{ops}],
    timestamp: Date.now(),
  };
}

// ============================================================================
// Custom Mutation Generators
// ============================================================================

/**
 * Creates a custom mutation.
 */
export function createCustomMutation(
  clientID: string,
  mutationID: number,
  name: string,
  args: ReadonlyJSONValue[] = [],
): CustomMutation {
  return {
    type: 'custom',
    id: mutationID,
    clientID,
    name,
    args,
    timestamp: Date.now(),
  };
}

// ============================================================================
// Push Message Generators
// ============================================================================

/**
 * Creates a push message with CRUD mutations.
 */
export function createCRUDPushMessage(
  clientGroupID: string,
  mutations: CRUDMutation[],
  requestID?: string | undefined,
): Upstream {
  return [
    'push',
    {
      clientGroupID,
      mutations,
      pushVersion: 1,
      schemaVersion: 1,
      timestamp: Date.now(),
      requestID: requestID ?? `push-${Date.now()}-${Math.random()}`,
    },
  ];
}

/**
 * Creates a push message with custom mutations.
 */
export function createCustomPushMessage(
  clientGroupID: string,
  mutations: CustomMutation[],
  requestID?: string | undefined,
): Upstream {
  return [
    'push',
    {
      clientGroupID,
      mutations,
      pushVersion: 1,
      schemaVersion: 1,
      timestamp: Date.now(),
      requestID: requestID ?? `push-${Date.now()}-${Math.random()}`,
    },
  ];
}

/**
 * Creates a push message with mixed CRUD and custom mutations.
 * Used to test routing logic when mutations[0].type is used to decide the path.
 */
export function createMixedPushMessage(
  clientGroupID: string,
  mutations: (CRUDMutation | CustomMutation)[],
  requestID?: string | undefined,
): Upstream {
  return [
    'push',
    {
      clientGroupID,
      mutations,
      pushVersion: 1,
      schemaVersion: 1,
      timestamp: Date.now(),
      requestID: requestID ?? `push-${Date.now()}-${Math.random()}`,
    },
  ];
}

/**
 * Creates a push message with empty mutations array.
 */
export function createEmptyPushMessage(
  clientGroupID: string,
  requestID?: string | undefined,
): Upstream {
  return [
    'push',
    {
      clientGroupID,
      mutations: [],
      pushVersion: 1,
      schemaVersion: 1,
      timestamp: Date.now(),
      requestID: requestID ?? `push-${Date.now()}-${Math.random()}`,
    },
  ];
}

// ============================================================================
// JWT/Auth Token Generators
// ============================================================================

/**
 * Creates a valid JWT for testing mutations.
 */
export async function createMutationAuthToken(
  secret: string,
  claims: {
    sub?: string | undefined;
    role?: string | undefined;
    [key: string]: unknown;
  } = {},
): Promise<string> {
  const secretKey = new TextEncoder().encode(secret);
  const now = Math.floor(Date.now() / 1000);

  // Cast claims to JWTPayload compatible type
  const jwtClaims = claims as Record<string, unknown>;
  let builder = new SignJWT(jwtClaims)
    .setProtectedHeader({alg: 'HS256'})
    .setIssuedAt(now)
    .setExpirationTime(now + 3600); // 1 hour default

  if (claims.sub) {
    builder = builder.setSubject(claims.sub);
  }

  return await builder.sign(secretKey);
}

/**
 * Creates an expired JWT for testing auth bypass.
 */
export async function createExpiredAuthToken(
  secret: string,
  claims: Record<string, unknown> = {},
): Promise<string> {
  const secretKey = new TextEncoder().encode(secret);
  const now = Math.floor(Date.now() / 1000);

  return await new SignJWT(claims)
    .setProtectedHeader({alg: 'HS256'})
    .setIssuedAt(now - 7200) // Issued 2 hours ago
    .setExpirationTime(now - 3600) // Expired 1 hour ago
    .sign(secretKey);
}

/**
 * Creates a JWT with invalid signature.
 */
export function createInvalidSignatureToken(validToken: string): string {
  const parts = validToken.split('.');
  if (parts.length !== 3) {
    throw new Error('Expected valid JWT with 3 parts');
  }
  // Return token with mangled signature
  return `${parts[0]}.${parts[1]}.${parts[2].split('').reverse().join('')}`;
}

/**
 * Creates auth tokens with various missing claims.
 */
export async function createTokensWithMissingClaims(
  secret: string,
): Promise<Record<string, string>> {
  const secretKey = new TextEncoder().encode(secret);
  const now = Math.floor(Date.now() / 1000);

  // Token with no sub claim
  const noSub = await new SignJWT({})
    .setProtectedHeader({alg: 'HS256'})
    .setIssuedAt(now)
    .setExpirationTime(now + 3600)
    .sign(secretKey);

  // Token with null sub
  const nullSub = await new SignJWT({sub: null as unknown as string})
    .setProtectedHeader({alg: 'HS256'})
    .setIssuedAt(now)
    .setExpirationTime(now + 3600)
    .sign(secretKey);

  // Token with empty sub
  const emptySub = await new SignJWT({sub: ''})
    .setProtectedHeader({alg: 'HS256'})
    .setIssuedAt(now)
    .setExpirationTime(now + 3600)
    .sign(secretKey);

  // Token with object sub (should be string)
  const objectSub = await new SignJWT({
    sub: {nested: 'value'} as unknown as string,
  })
    .setProtectedHeader({alg: 'HS256'})
    .setIssuedAt(now)
    .setExpirationTime(now + 3600)
    .sign(secretKey);

  // Token with array sub (should be string)
  const arraySub = await new SignJWT({sub: ['a', 'b'] as unknown as string})
    .setProtectedHeader({alg: 'HS256'})
    .setIssuedAt(now)
    .setExpirationTime(now + 3600)
    .sign(secretKey);

  return {
    noSub,
    nullSub,
    emptySub,
    objectSub,
    arraySub,
  };
}

// ============================================================================
// LMID (Last Mutation ID) Attack Payloads
// ============================================================================

/**
 * Creates mutations with specific LMID values for replay/ordering attacks.
 */
export function createLMIDTestMutations(
  clientID: string,
  tableName: string = 'pentest_data',
): Record<string, CRUDMutation> {
  return {
    // Normal LMID = 1
    normal: createInsertMutation(clientID, 1, tableName, {
      id: 'lmid-normal',
      value: 'test',
    }),
    // Replay with same LMID
    replay: createInsertMutation(clientID, 1, tableName, {
      id: 'lmid-replay',
      value: 'test',
    }),
    // Skip ahead (LMID = 100 when expecting 2)
    skipAhead: createInsertMutation(clientID, 100, tableName, {
      id: 'lmid-skip',
      value: 'test',
    }),
    // Zero LMID (invalid)
    zero: createInsertMutation(clientID, 0, tableName, {
      id: 'lmid-zero',
      value: 'test',
    }),
    // Negative LMID (invalid)
    negative: createInsertMutation(clientID, -1, tableName, {
      id: 'lmid-negative',
      value: 'test',
    }),
    // Very large LMID
    veryLarge: createInsertMutation(
      clientID,
      Number.MAX_SAFE_INTEGER,
      tableName,
      {
        id: 'lmid-large',
        value: 'test',
      },
    ),
    // LMID beyond safe integer
    beyondSafe: createInsertMutation(
      clientID,
      Number.MAX_SAFE_INTEGER + 1,
      tableName,
      {id: 'lmid-beyond', value: 'test'},
    ),
    // Float LMID (should be integer)
    float: createInsertMutation(clientID, 1.5, tableName, {
      id: 'lmid-float',
      value: 'test',
    }),
  };
}

// ============================================================================
// Table Name Attack Payloads
// ============================================================================

/**
 * Creates mutations with potentially dangerous table names.
 */
export function createTableNameAttacks(
  clientID: string,
  mutationID: number = 1,
): Record<string, CRUDMutation> {
  return {
    // SQL injection attempt
    sqlInjection: createInsertMutation(
      clientID,
      mutationID,
      'users; DROP TABLE users; --',
      {id: 'attack', value: 'test'},
    ),
    // Path traversal
    pathTraversal: createInsertMutation(
      clientID,
      mutationID,
      '../../../etc/passwd',
      {id: 'attack', value: 'test'},
    ),
    // Null byte injection
    nullByte: createInsertMutation(clientID, mutationID, 'users\x00admin', {
      id: 'attack',
      value: 'test',
    }),
    // Unicode confusable
    unicodeTable: createInsertMutation(clientID, mutationID, 'us\u0435rs', {
      id: 'attack',
      value: 'test',
    }),
    // Empty table name
    empty: createInsertMutation(clientID, mutationID, '', {
      id: 'attack',
      value: 'test',
    }),
    // Whitespace only
    whitespace: createInsertMutation(clientID, mutationID, '   ', {
      id: 'attack',
      value: 'test',
    }),
    // Very long table name
    veryLong: createInsertMutation(clientID, mutationID, 'a'.repeat(10000), {
      id: 'attack',
      value: 'test',
    }),
    // Reserved SQL keyword
    reservedKeyword: createInsertMutation(clientID, mutationID, 'SELECT', {
      id: 'attack',
      value: 'test',
    }),
    // Schema-qualified name attempt
    schemaQualified: createInsertMutation(
      clientID,
      mutationID,
      'pg_catalog.pg_authid',
      {id: 'attack', value: 'test'},
    ),
  };
}

// ============================================================================
// Prototype Pollution Attack Payloads
// ============================================================================

/**
 * Creates mutations with prototype pollution attempts in values.
 */
export function createPrototypePollutionAttacks(
  clientID: string,
  tableName: string = 'pentest_data',
): Record<string, CRUDMutation> {
  return {
    // __proto__ in value
    protoInValue: createInsertMutation(clientID, 1, tableName, {
      id: 'proto-attack',
      __proto__: {admin: true},
    }),
    // constructor.prototype
    constructorPrototype: createInsertMutation(clientID, 1, tableName, {
      id: 'constructor-attack',
      constructor: {prototype: {admin: true}},
    }),
    // Nested __proto__
    nestedProto: createInsertMutation(clientID, 1, tableName, {
      id: 'nested-proto',
      data: {__proto__: {admin: true}},
    }),
    // __proto__ as id
    protoAsId: createInsertMutation(clientID, 1, tableName, {
      id: '__proto__',
      value: 'test',
    }),
    // Object.prototype pollution via toString
    toStringPollution: createInsertMutation(clientID, 1, tableName, {
      id: 'tostring-attack',
      toString: () => 'hacked',
    } as unknown as Record<string, unknown>),
  };
}

// ============================================================================
// Header Injection Payloads (for custom mutations)
// ============================================================================

/**
 * Creates payloads that could be used to test header injection.
 * These are meant to be used as token or cookie values.
 */
export function createHeaderInjectionPayloads(): Record<string, string> {
  return {
    // Newline injection in Authorization header
    newlineInToken: 'Bearer token\r\nX-Injected: malicious',
    // Carriage return injection
    crInjection: 'Bearer token\rX-Injected: value',
    // Line feed injection
    lfInjection: 'Bearer token\nX-Injected: value',
    // CRLF sequence
    crlfInjection: 'Bearer token\r\n\r\n<html>injected</html>',
    // Unicode line separator
    unicodeLineSep: 'Bearer token\u2028X-Injected: value',
    // Unicode paragraph separator
    unicodeParagraph: 'Bearer token\u2029X-Injected: value',
    // Null byte
    nullByteInToken: 'Bearer token\x00X-Injected: value',
    // Very long header value (potential DoS)
    veryLongToken: 'Bearer ' + 'x'.repeat(100000),
  };
}

/**
 * Creates cookie values that could be used to test injection.
 */
export function createCookieInjectionPayloads(): Record<string, string> {
  return {
    // Cookie injection via semicolon
    semicolonInjection: 'session=abc; admin=true',
    // Cookie injection via newline
    newlineInjection: 'session=abc\r\nSet-Cookie: admin=true',
    // Path manipulation
    pathManipulation: 'session=abc; Path=/',
    // Domain manipulation
    domainManipulation: 'session=abc; Domain=.evil.com',
    // HttpOnly flag injection
    httpOnlyInjection: 'session=abc; HttpOnly',
    // Very long cookie
    veryLongCookie: 'session=' + 'x'.repeat(100000),
  };
}

// ============================================================================
// Batch Attack Payloads
// ============================================================================

/**
 * Creates a large batch of mutations for DoS testing.
 */
export function createLargeMutationBatch(
  clientID: string,
  tableName: string,
  count: number,
): CRUDMutation[] {
  const mutations: CRUDMutation[] = [];
  for (let i = 1; i <= count; i++) {
    mutations.push(
      createInsertMutation(clientID, i, tableName, {
        id: `batch-${i}`,
        value: `value-${i}`,
      }),
    );
  }
  return mutations;
}

/**
 * Creates a mutation with many operations.
 */
export function createMutationWithManyOps(
  clientID: string,
  mutationID: number,
  tableName: string,
  opCount: number,
): CRUDMutation {
  const ops: InsertOp[] = [];
  for (let i = 0; i < opCount; i++) {
    ops.push({
      op: 'insert',
      tableName,
      primaryKey: ['id'],
      value: {id: `op-${i}`, value: `value-${i}`},
    });
  }
  return createMultiOpMutation(clientID, mutationID, ops);
}

// ============================================================================
// Type Confusion Mutations
// ============================================================================

/**
 * Creates mutations with type confusion in the type field.
 */
export function createTypeConfusionMutations(): unknown[] {
  return [
    // Type as number instead of string
    {
      type: 1,
      id: 1,
      clientID: 'test',
      name: '_zero_crud',
      args: [{ops: []}],
      timestamp: Date.now(),
    },
    // Type as boolean
    {
      type: true,
      id: 1,
      clientID: 'test',
      name: '_zero_crud',
      args: [{ops: []}],
      timestamp: Date.now(),
    },
    // Type as object
    {
      type: {type: 'crud'},
      id: 1,
      clientID: 'test',
      name: '_zero_crud',
      args: [{ops: []}],
      timestamp: Date.now(),
    },
    // Type as null
    {
      type: null,
      id: 1,
      clientID: 'test',
      name: '_zero_crud',
      args: [{ops: []}],
      timestamp: Date.now(),
    },
    // Type as undefined
    {
      type: undefined,
      id: 1,
      clientID: 'test',
      name: '_zero_crud',
      args: [{ops: []}],
      timestamp: Date.now(),
    },
    // Type as array
    {
      type: ['crud'],
      id: 1,
      clientID: 'test',
      name: '_zero_crud',
      args: [{ops: []}],
      timestamp: Date.now(),
    },
    // Invalid type string
    {
      type: 'CRUD', // uppercase
      id: 1,
      clientID: 'test',
      name: '_zero_crud',
      args: [{ops: []}],
      timestamp: Date.now(),
    },
    // Unknown type string
    {
      type: 'unknown',
      id: 1,
      clientID: 'test',
      name: '_zero_crud',
      args: [{ops: []}],
      timestamp: Date.now(),
    },
  ];
}

// ============================================================================
// Permission Test Helpers
// ============================================================================

/**
 * Configuration for multi-permission schema tests.
 */
export const PERMISSION_TEST_TABLES = {
  /** Anyone can read/write */
  public: 'writable',
  /** Only admin role can read */
  adminOnly: 'protected',
  /** No permissions defined (default deny) */
  noPermissions: 'unreadable',
  /** Read-only for most users */
  readable: 'readable',
} as const;

/**
 * Creates mutations targeting different permission levels.
 */
export function createPermissionTestMutations(
  clientID: string,
): Record<string, CRUDMutation> {
  return {
    // Write to public table (should succeed)
    writePublic: createInsertMutation(
      clientID,
      1,
      PERMISSION_TEST_TABLES.public,
      {id: 'perm-test-1', value: 'test'},
    ),
    // Write to admin-only table (should fail without admin role)
    writeAdminOnly: createInsertMutation(
      clientID,
      1,
      PERMISSION_TEST_TABLES.adminOnly,
      {id: 'perm-test-2', secret: 'should-fail'},
    ),
    // Write to table with no permissions (should fail)
    writeNoPermissions: createInsertMutation(
      clientID,
      1,
      PERMISSION_TEST_TABLES.noPermissions,
      {id: 'perm-test-3', data: 'should-fail'},
    ),
    // Write to read-only table (should fail)
    writeReadOnly: createInsertMutation(
      clientID,
      1,
      PERMISSION_TEST_TABLES.readable,
      {id: 'perm-test-4', value: 'should-fail'},
    ),
  };
}
