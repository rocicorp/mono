/**
 * Race Condition Testing Helpers
 *
 * Utilities for testing concurrency vulnerabilities in zero-cache:
 * - Concurrent mutation submission
 * - TOCTOU (Time-of-Check-Time-of-Use) attacks
 * - Permission reload race conditions
 * - Connection replacement races
 */

import WebSocket from 'ws';
import type {CRUDMutation} from '../../../../zero-protocol/src/push.ts';
import {
  createInsertMutation,
  createUpdateMutation,
  createCRUDPushMessage,
} from './mutation-helpers.ts';
import {connectSync, type ConnectResult} from './ws-client.ts';

/**
 * Creates multiple concurrent WebSocket connections.
 */
export interface ConcurrentConnections {
  connections: ConnectResult[];
  /** Close all connections */
  closeAll: () => void;
}

export async function createConcurrentConnections(
  count: number,
  port: number,
  clientGroupID: string,
  authToken?: string | undefined,
): Promise<ConcurrentConnections> {
  const connections: ConnectResult[] = [];

  for (let i = 0; i < count; i++) {
    const conn = connectSync({
      port,
      clientGroupID,
      clientID: `race-client-${i}`,
      wsID: `race-ws-${i}`,
      userID: `race-user-${i}`,
      authToken,
    });
    connections.push(conn);
  }

  // Wait for all to open or fail
  await Promise.all(
    connections.map(async conn => {
      const timeout = new Promise<'timeout'>(r =>
        setTimeout(() => r('timeout'), 5000),
      );
      const opened = conn.opened.then(() => 'opened' as const);
      const closed = conn.closed.then(c => ({closed: c}));
      await Promise.race([opened, closed, timeout]);
    }),
  );

  return {
    connections,
    closeAll: () => {
      for (const conn of connections) {
        try {
          conn.ws.close();
        } catch {
          // Ignore close errors
        }
      }
    },
  };
}

/**
 * Sends mutations concurrently from multiple connections.
 */
export interface ConcurrentMutationResult {
  index: number;
  sent: boolean;
  error?: string | undefined;
}

export async function sendConcurrentMutations(
  connections: ConnectResult[],
  clientGroupID: string,
  mutations: CRUDMutation[],
): Promise<ConcurrentMutationResult[]> {
  // Send all mutations simultaneously
  const sendPromises = connections.map((conn, i) => {
    return new Promise<ConcurrentMutationResult>(resolve => {
      try {
        if (conn.ws.readyState === WebSocket.OPEN) {
          const mutation = mutations[i % mutations.length];
          const pushMsg = createCRUDPushMessage(clientGroupID, [mutation]);
          conn.ws.send(JSON.stringify(pushMsg));
          resolve({index: i, sent: true});
        } else {
          resolve({
            index: i,
            sent: false,
            error: `WebSocket not open (state: ${conn.ws.readyState})`,
          });
        }
      } catch (e) {
        resolve({index: i, sent: false, error: String(e)});
      }
    });
  });

  return Promise.all(sendPromises);
}

/**
 * Creates mutations targeting the same row from different clients.
 * Used to test concurrent same-row mutation handling.
 */
export function createSameRowMutations(
  rowId: string,
  tableName: string,
  clientCount: number,
): CRUDMutation[] {
  return Array.from({length: clientCount}, (_, i) =>
    createUpdateMutation(`race-client-${i}`, 1, tableName, {
      id: rowId,
      value: `updated-by-client-${i}`,
    }),
  );
}

/**
 * Creates mutations with sequential LMID values from the same client.
 * Used to test LMID race conditions.
 */
export function createSequentialLMIDMutations(
  clientID: string,
  tableName: string,
  startLMID: number,
  count: number,
): CRUDMutation[] {
  return Array.from({length: count}, (_, i) =>
    createInsertMutation(clientID, startLMID + i, tableName, {
      id: `lmid-race-${startLMID + i}`,
      value: `value-${i}`,
    }),
  );
}

/**
 * Submits mutations in rapid succession without waiting for responses.
 * Tests server's handling of burst traffic.
 */
export function submitMutationBurst(
  ws: WebSocket,
  clientGroupID: string,
  mutations: CRUDMutation[],
  delayMs: number = 0,
): Promise<void> {
  return new Promise<void>((resolve, reject) => {
    let i = 0;
    const send = () => {
      if (i >= mutations.length) {
        resolve();
        return;
      }
      try {
        const pushMsg = createCRUDPushMessage(clientGroupID, [mutations[i]]);
        ws.send(JSON.stringify(pushMsg));
        i++;
        if (delayMs > 0) {
          setTimeout(send, delayMs);
        } else {
          setImmediate(send);
        }
      } catch (e) {
        reject(e);
      }
    };
    send();
  });
}

/**
 * TOCTOU attack simulation: sends a mutation, then immediately tries to
 * modify the condition that was checked during authorization.
 */
export interface TOCTOUAttackConfig {
  /** Connection for the initial mutation */
  attackerConn: ConnectResult;
  /** Connection for changing the condition (e.g., admin changing permissions) */
  adminConn: ConnectResult;
  clientGroupID: string;
  /** Mutation to send first (that should be blocked after permission change) */
  initialMutation: CRUDMutation;
  /** Mutation that changes the authorization state */
  permissionChangeMutation: CRUDMutation;
}

export async function executeTOCTOUAttack(
  config: TOCTOUAttackConfig,
): Promise<{
  initialSent: boolean;
  permissionChangeSent: boolean;
  timingMs: number;
}> {
  const {
    attackerConn,
    adminConn,
    clientGroupID,
    initialMutation,
    permissionChangeMutation,
  } = config;

  const startTime = performance.now();

  // Send both mutations as close together as possible
  const [initialResult, permissionResult] = await Promise.all([
    new Promise<boolean>(resolve => {
      try {
        if (attackerConn.ws.readyState === WebSocket.OPEN) {
          const msg = createCRUDPushMessage(clientGroupID, [initialMutation]);
          attackerConn.ws.send(JSON.stringify(msg));
          resolve(true);
        } else {
          resolve(false);
        }
      } catch {
        resolve(false);
      }
    }),
    new Promise<boolean>(resolve => {
      // Small delay to try to hit the window between check and apply
      setTimeout(() => {
        try {
          if (adminConn.ws.readyState === WebSocket.OPEN) {
            const msg = createCRUDPushMessage(clientGroupID, [
              permissionChangeMutation,
            ]);
            adminConn.ws.send(JSON.stringify(msg));
            resolve(true);
          } else {
            resolve(false);
          }
        } catch {
          resolve(false);
        }
      }, 1); // 1ms delay
    }),
  ]);

  const endTime = performance.now();

  return {
    initialSent: initialResult,
    permissionChangeSent: permissionResult,
    timingMs: endTime - startTime,
  };
}

/**
 * Creates multiple connections with the same clientID to test
 * connection replacement race conditions.
 */
export async function createDuplicateClientConnections(
  count: number,
  port: number,
  clientGroupID: string,
  clientID: string,
  authToken?: string | undefined,
): Promise<{
  connections: ConnectResult[];
  openedCount: number;
  closedCount: number;
  closeAll: () => void;
}> {
  const connections: ConnectResult[] = [];

  // Create all connections simultaneously with same clientID
  for (let i = 0; i < count; i++) {
    connections.push(
      connectSync({
        port,
        clientGroupID,
        clientID, // Same clientID for all
        wsID: `dup-ws-${i}`,
        userID: 'dup-user',
        authToken,
      }),
    );
  }

  // Wait a bit for connections to settle
  await new Promise(resolve => setTimeout(resolve, 2000));

  let openedCount = 0;
  let closedCount = 0;

  for (const conn of connections) {
    if (conn.ws.readyState === WebSocket.OPEN) {
      openedCount++;
    } else if (
      conn.ws.readyState === WebSocket.CLOSED ||
      conn.ws.readyState === WebSocket.CLOSING
    ) {
      closedCount++;
    }
  }

  return {
    connections,
    openedCount,
    closedCount,
    closeAll: () => {
      for (const conn of connections) {
        try {
          conn.ws.close();
        } catch {
          // Ignore
        }
      }
    },
  };
}

/**
 * Monitors WebSocket for messages with timing information.
 */
export interface TimedMessage {
  message: unknown;
  receivedAt: number;
  relativeMs: number;
}

export function createTimedMessageCollector(
  ws: WebSocket,
): {
  messages: TimedMessage[];
  stop: () => void;
} {
  const messages: TimedMessage[] = [];
  const startTime = Date.now();

  const handler = (data: WebSocket.Data) => {
    const receivedAt = Date.now();
    try {
      messages.push({
        message: JSON.parse(data.toString()),
        receivedAt,
        relativeMs: receivedAt - startTime,
      });
    } catch {
      messages.push({
        message: data.toString(),
        receivedAt,
        relativeMs: receivedAt - startTime,
      });
    }
  };

  ws.on('message', handler);

  return {
    messages,
    stop: () => {
      ws.off('message', handler);
    },
  };
}

/**
 * Runs a function multiple times concurrently and collects results.
 */
export async function runConcurrently<T>(
  fn: (index: number) => Promise<T>,
  count: number,
): Promise<{
  results: T[];
  errors: Array<{index: number; error: unknown}>;
  durationMs: number;
}> {
  const startTime = performance.now();
  const results: T[] = [];
  const errors: Array<{index: number; error: unknown}> = [];

  const promises = Array.from({length: count}, async (_, i) => {
    try {
      const result = await fn(i);
      results[i] = result;
    } catch (e) {
      errors.push({index: i, error: e});
    }
  });

  await Promise.all(promises);

  return {
    results,
    errors,
    durationMs: performance.now() - startTime,
  };
}
