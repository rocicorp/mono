/**
 * Message Parsing Attack Payload Generators
 *
 * Utilities for generating attack payloads to test message parsing
 * vulnerabilities in zero-cache: type confusion, resource exhaustion,
 * Unicode edge cases, and boundary conditions.
 */

import type {Upstream} from '../../../../zero-protocol/src/up.ts';

// ============================================================================
// JSON Depth Attack Generators
// ============================================================================

/**
 * Creates a deeply nested object: {a:{b:{c:...}}}
 * Used to test stack overflow in JSON.parse() or recursive validators.
 */
export function createDeeplyNestedObject(depth: number): object {
  let result: Record<string, unknown> = {value: 'leaf'};
  for (let i = 0; i < depth; i++) {
    result = {nested: result};
  }
  return result;
}

/**
 * Creates a deeply nested array: [[[[...]]]]
 * Used to test stack overflow in JSON.parse() or recursive validators.
 */
export function createDeeplyNestedArray(depth: number): unknown[] {
  let result: unknown[] = ['leaf'];
  for (let i = 0; i < depth; i++) {
    result = [result];
  }
  return result;
}

/**
 * Creates a pathologically wide and deep structure.
 * Each level has multiple keys, each containing nested objects.
 */
export function createWideAndDeepObject(
  depth: number,
  width: number,
): Record<string, unknown> {
  if (depth <= 0) {
    return {leaf: true};
  }
  const result: Record<string, unknown> = {};
  for (let i = 0; i < width; i++) {
    result[`key${i}`] = createWideAndDeepObject(depth - 1, width);
  }
  return result;
}

/**
 * Creates a JSON string with deep nesting (avoids recursion in generator).
 */
export function createDeeplyNestedJSON(depth: number): string {
  return '{' + '"a":'.repeat(depth) + '1' + '}'.repeat(depth);
}

// ============================================================================
// Base64 Attack Generators
// ============================================================================

/**
 * Creates a large base64 payload of specified size (before encoding).
 * Used to test base64 decoding resource limits.
 */
export function createLargeBase64Payload(sizeBytes: number): string {
  // Create a string of the specified size
  const data = 'x'.repeat(sizeBytes);
  // Use TextEncoder + manual base64 encoding for large data
  const bytes = new TextEncoder().encode(JSON.stringify({data}));
  // Convert bytes to string without spreading (avoids stack overflow)
  const s = Array.from(bytes, byte => String.fromCharCode(byte)).join('');
  return encodeURIComponent(btoa(s));
}

/**
 * Creates a base64 "bomb" - data that expands significantly when decoded.
 * Note: Standard base64 only expands by ~33%, but we can test large payloads.
 */
export function createBase64Bomb(originalSize: number): string {
  // Create repetitive data that might compress well but expands in base64
  const data = 'A'.repeat(originalSize);
  const bytes = new TextEncoder().encode(data);
  const s = Array.from(bytes, byte => String.fromCharCode(byte)).join('');
  return encodeURIComponent(btoa(s));
}

/**
 * Creates a malformed base64 string with invalid characters.
 */
export function createMalformedBase64(): string[] {
  return [
    // Invalid characters
    encodeURIComponent('!!!invalid-base64!!!'),
    // Incorrect padding
    encodeURIComponent('YWJj==='),
    // Truncated
    encodeURIComponent('YWJ'),
    // Empty
    encodeURIComponent(''),
    // Only padding
    encodeURIComponent('===='),
    // Valid base64 but decodes to invalid UTF-8
    encodeURIComponent(btoa('\xff\xfe')),
    // Valid base64 but decodes to invalid JSON
    encodeURIComponent(btoa('not json')),
  ];
}

// ============================================================================
// Integer Boundary Attack Values
// ============================================================================

/**
 * Returns integer boundary values for testing parseInt/number handling.
 */
export function createIntegerBoundaryValues(): Record<string, string> {
  return {
    maxSafeInteger: String(Number.MAX_SAFE_INTEGER),
    maxSafeIntegerPlus1: String(Number.MAX_SAFE_INTEGER + 1),
    minSafeInteger: String(Number.MIN_SAFE_INTEGER),
    minSafeIntegerMinus1: String(Number.MIN_SAFE_INTEGER - 1),
    maxValue: String(Number.MAX_VALUE),
    negativeZero: '-0',
    positiveInfinity: 'Infinity',
    negativeInfinity: '-Infinity',
    nan: 'NaN',
    scientificLarge: '1e308',
    scientificSmall: '1e-308',
    scientificNegative: '-1e308',
    veryLongNumber: '9'.repeat(1000),
    leadingZeros: '00000001',
    hexNotation: '0x1234',
    octalNotation: '0o777',
    binaryNotation: '0b1010',
    negativeOne: '-1',
    floatAsInt: '3.14159',
    negativeFloat: '-3.14159',
    emptyString: '',
    whitespace: '  42  ',
    mixedChars: '42abc',
  };
}

// ============================================================================
// Unicode Confusion Attack Payloads
// ============================================================================

/**
 * Creates table/column names with Unicode confusion characters.
 * Used to test identifier handling and potential bypasses.
 */
export function createUnicodeConfusionPayloads(): Record<string, string> {
  return {
    // Cyrillic 'Ðµ' looks like Latin 'e'
    cyrillicE: 'us\u0435r', // usÐµr
    // Cyrillic 'Ð°' looks like Latin 'a'
    cyrillicA: 'dat\u0430', // datÐ°
    // Zero-width space
    zeroWidthSpace: 'user\u200Bid',
    // Zero-width non-joiner
    zeroWidthNonJoiner: 'user\u200Cid',
    // Zero-width joiner
    zeroWidthJoiner: 'user\u200Did',
    // Right-to-left override
    rtlOverride: '\u202Euser',
    // Left-to-right override
    ltrOverride: '\u202Duser',
    // Combining characters (Ã¼ as u + combining umlaut)
    combiningUmlaut: 'u\u0308ser',
    // Full-width characters
    fullWidth: '\uFF55\uFF53\uFF45\uFF52', // ï½•ï½“ï½…ï½’
    // Homoglyph attack using Greek letters
    greekOmicron: 'us\u03B5r', // Greek small letter epsilon
    // Unicode normalization differences (NFC vs NFD)
    nfdForm: 'caf\u0065\u0301', // cafÃ© (e + combining acute)
    nfcForm: 'caf\u00E9', // cafÃ© (precomposed Ã©)
    // Null byte
    nullByte: 'user\u0000id',
    // Bell character
    bellChar: 'user\u0007id',
    // Escape character
    escapeChar: 'user\u001Bid',
    // Very long Unicode string
    longUnicode: '\u0041'.repeat(10000), // 10000 'A's
    // Mixed scripts
    mixedScripts: 'user\u0430\u03B5\u0435table', // Latin + Cyrillic + Greek
    // Private use area
    privateUse: 'user\uE000id',
    // Surrogate pair (emoji)
    emoji: 'user\uD83D\uDE00id', // userðŸ˜€id
    // Invalid surrogate
    invalidSurrogate: 'user\uD800id',
  };
}

// ============================================================================
// Oversized Message Generators
// ============================================================================

/**
 * Creates a push message with a large number of mutations.
 */
export function createOversizedPush(
  clientID: string,
  mutationCount: number,
): Upstream {
  const mutations = [];
  for (let i = 0; i < mutationCount; i++) {
    mutations.push({
      type: 'crud' as const,
      id: i,
      clientID,
      name: '_zero_crud',
      args: [
        {
          ops: [
            {
              op: 'insert' as const,
              tableName: 'pentest_data',
              primaryKey: ['id'],
              value: {id: `item-${i}`, value: `value-${i}`},
            },
          ],
        },
      ],
      timestamp: Date.now(),
    });
  }

  return [
    'push',
    {
      clientGroupID: 'test-cg',
      mutations,
      pushVersion: 1,
      schemaVersion: 1,
      timestamp: Date.now(),
      requestID: `oversized-push-${Date.now()}`,
    },
  ];
}

/**
 * Creates a push with a single mutation containing many ops.
 */
export function createMutationWithManyOps(
  clientID: string,
  opCount: number,
): Upstream {
  const ops = [];
  for (let i = 0; i < opCount; i++) {
    ops.push({
      op: 'insert' as const,
      tableName: 'pentest_data',
      primaryKey: ['id'],
      value: {id: `op-${i}`, value: `value-${i}`},
    });
  }

  return [
    'push',
    {
      clientGroupID: 'test-cg',
      mutations: [
        {
          type: 'crud' as const,
          id: 1,
          clientID,
          name: '_zero_crud',
          args: [{ops}],
          timestamp: Date.now(),
        },
      ],
      pushVersion: 1,
      schemaVersion: 1,
      timestamp: Date.now(),
      requestID: `many-ops-${Date.now()}`,
    },
  ];
}

/**
 * Creates a changeDesiredQueries message with many queries.
 */
export function createOversizedQueryPatch(queryCount: number): Upstream {
  const patch = [];
  for (let i = 0; i < queryCount; i++) {
    patch.push({
      op: 'put' as const,
      hash: `query-${i}`,
      ast: {
        table: 'pentest_data',
        orderBy: [['id', 'asc' as const]],
      },
      ttl: undefined,
    });
  }

  return [
    'changeDesiredQueries',
    {
      desiredQueriesPatch: patch,
    },
  ];
}

/**
 * Creates messages with oversized string fields.
 */
export function createOversizedStrings(): Record<string, string> {
  return {
    oneKB: 'x'.repeat(1024),
    tenKB: 'x'.repeat(10 * 1024),
    oneHundredKB: 'x'.repeat(100 * 1024),
    oneMB: 'x'.repeat(1024 * 1024),
    fiveMB: 'x'.repeat(5 * 1024 * 1024),
  };
}

// ============================================================================
// Type Confusion Attack Payloads
// ============================================================================

/**
 * Creates messages with type confusion - arrays where objects expected, etc.
 */
export function createTypeConfusionMessages(): unknown[] {
  return [
    // Array instead of message tuple
    [[[['nested', 'array']]]],
    // Object instead of array
    {'0': 'push', '1': {}},
    // Null in message position
    ['push', null],
    // Undefined in message position
    ['push', undefined],
    // Number as message type
    [123, {}],
    // Boolean as message type
    [true, {}],
    // Object as message type
    [{type: 'push'}, {}],
    // Empty message
    [],
    // Single element
    ['push'],
    // Three elements
    ['push', {}, 'extra'],
    // Message body is array instead of object
    ['push', ['not', 'an', 'object']],
    // Message body has __proto__ key
    ['push', {__proto__: {admin: true}, clientGroupID: 'test'}],
    // Message body has constructor key
    ['push', {constructor: {prototype: {admin: true}}, clientGroupID: 'test'}],
    // Circular reference (will fail JSON.stringify but tests parsing)
    // Note: Can't actually create circular JSON, but we can test near-misses
    ['push', {a: {b: {c: {d: {e: 'deep'}}}, self: 'not-circular'}}],
    // Array-like object
    ['push', {'length': 2, '0': 'a', '1': 'b'}],
    // Symbol key (won't survive JSON but tests edge cases)
    ['push', {[Symbol.for('test')]: 'value', clientGroupID: 'test'}],
    // Getter that throws (won't survive JSON serialization)
    [
      'push',
      Object.defineProperty({clientGroupID: 'test'}, 'bad', {
        get() {
          throw new Error('getter');
        },
      }),
    ],
  ];
}

/**
 * Creates push messages with invalid mutation structures.
 */
export function createInvalidMutationStructures(): unknown[] {
  return [
    // Missing clientGroupID
    ['push', {mutations: [], pushVersion: 1}],
    // Missing mutations
    ['push', {clientGroupID: 'test', pushVersion: 1}],
    // Mutations is object instead of array
    ['push', {clientGroupID: 'test', mutations: {}, pushVersion: 1}],
    // Mutation missing required fields
    [
      'push',
      {
        clientGroupID: 'test',
        mutations: [{type: 'crud'}],
        pushVersion: 1,
        schemaVersion: 1,
        timestamp: Date.now(),
        requestID: 'test',
      },
    ],
    // Invalid mutation type
    [
      'push',
      {
        clientGroupID: 'test',
        mutations: [{type: 'unknown', id: 1, clientID: 'c', name: 'x'}],
        pushVersion: 1,
        schemaVersion: 1,
        timestamp: Date.now(),
        requestID: 'test',
      },
    ],
    // Mutation ID is string instead of number
    [
      'push',
      {
        clientGroupID: 'test',
        mutations: [
          {
            type: 'custom',
            id: 'not-a-number',
            clientID: 'c',
            name: 'x',
            args: [],
            timestamp: Date.now(),
          },
        ],
        pushVersion: 1,
        schemaVersion: 1,
        timestamp: Date.now(),
        requestID: 'test',
      },
    ],
    // Negative mutation ID
    [
      'push',
      {
        clientGroupID: 'test',
        mutations: [
          {
            type: 'custom',
            id: -1,
            clientID: 'c',
            name: 'x',
            args: [],
            timestamp: Date.now(),
          },
        ],
        pushVersion: 1,
        schemaVersion: 1,
        timestamp: Date.now(),
        requestID: 'test',
      },
    ],
    // Mutation ID is MAX_SAFE_INTEGER + 1
    [
      'push',
      {
        clientGroupID: 'test',
        mutations: [
          {
            type: 'custom',
            id: Number.MAX_SAFE_INTEGER + 1,
            clientID: 'c',
            name: 'x',
            args: [],
            timestamp: Date.now(),
          },
        ],
        pushVersion: 1,
        schemaVersion: 1,
        timestamp: Date.now(),
        requestID: 'test',
      },
    ],
  ];
}

// ============================================================================
// Size Boundary Attack Payloads
// ============================================================================

/**
 * Creates messages at specific byte boundaries relevant to WebSocket frames.
 * WebSocket frame boundaries: 125, 126, 65535, 65536
 */
export function createSizeBoundaryMessages(): Record<string, string> {
  // Calculate overhead of minimal valid message: ["ping",{}]
  const minimalMessage = '["ping",{}]';
  const overhead = minimalMessage.length;

  return {
    // Just under 125 byte frame threshold
    under125: JSON.stringify(['ping', {pad: 'x'.repeat(125 - overhead - 10)}]),
    // Exactly at 125 bytes
    at125: JSON.stringify(['ping', {pad: 'x'.repeat(125 - overhead - 8)}]),
    // Just over 125 (triggers extended payload length)
    over125: JSON.stringify(['ping', {pad: 'x'.repeat(125 - overhead + 10)}]),
    // Just under 65536
    under65536: JSON.stringify([
      'ping',
      {pad: 'x'.repeat(65536 - overhead - 10)},
    ]),
    // Just over 65536 (triggers 8-byte extended length)
    over65536: JSON.stringify([
      'ping',
      {pad: 'x'.repeat(65536 - overhead + 10)},
    ]),
    // Empty message
    empty: '',
    // Whitespace only
    whitespaceOnly: '   \n\t   ',
    // Just opening brace
    partialJson: '{',
    // Unclosed string
    unclosedString: '["ping',
    // Unclosed array
    unclosedArray: '["ping",{}',
  };
}

/**
 * Creates messages with fields at various size limits.
 */
export function createFieldSizeBoundaries(): Record<string, Upstream> {
  return {
    // Empty clientGroupID
    emptyClientGroupID: [
      'push',
      {
        clientGroupID: '',
        mutations: [],
        pushVersion: 1,
        schemaVersion: 1,
        timestamp: Date.now(),
        requestID: 'test',
      },
    ],
    // Very long clientGroupID
    longClientGroupID: [
      'push',
      {
        clientGroupID: 'x'.repeat(10000),
        mutations: [],
        pushVersion: 1,
        schemaVersion: 1,
        timestamp: Date.now(),
        requestID: 'test',
      },
    ],
    // Very long requestID
    longRequestID: [
      'push',
      {
        clientGroupID: 'test',
        mutations: [],
        pushVersion: 1,
        schemaVersion: 1,
        timestamp: Date.now(),
        requestID: 'x'.repeat(10000),
      },
    ],
    // Empty requestID
    emptyRequestID: [
      'push',
      {
        clientGroupID: 'test',
        mutations: [],
        pushVersion: 1,
        schemaVersion: 1,
        timestamp: Date.now(),
        requestID: '',
      },
    ],
  };
}

// ============================================================================
// Protocol Header Attack Payloads (for sec-websocket-protocol)
// ============================================================================

/**
 * Creates malformed sec-websocket-protocol values for connection attacks.
 */
export function createMalformedProtocolHeaders(): Record<string, string> {
  return {
    // Empty protocol
    empty: '',
    // Just whitespace
    whitespace: '   ',
    // Not base64
    notBase64: 'this-is-not-base64!!!',
    // Valid base64 but not JSON
    base64NotJson: encodeURIComponent(btoa('not json')),
    // Valid base64+JSON but wrong structure
    wrongStructure: encodeURIComponent(btoa(JSON.stringify({wrong: 'keys'}))),
    // Missing initConnectionMessage
    missingInit: encodeURIComponent(btoa(JSON.stringify({authToken: 'token'}))),
    // initConnectionMessage is string instead of array
    initIsString: encodeURIComponent(
      btoa(
        JSON.stringify({
          initConnectionMessage: 'not an array',
          authToken: undefined,
        }),
      ),
    ),
    // initConnectionMessage is wrong tuple
    initWrongTuple: encodeURIComponent(
      btoa(
        JSON.stringify({
          initConnectionMessage: ['wrong', 'tuple'],
          authToken: undefined,
        }),
      ),
    ),
    // Very long authToken
    longAuthToken: encodeURIComponent(
      btoa(
        JSON.stringify({
          initConnectionMessage: undefined,
          authToken: 'x'.repeat(100000),
        }),
      ),
    ),
    // Null values
    nullValues: encodeURIComponent(
      btoa(
        JSON.stringify({
          initConnectionMessage: null,
          authToken: null,
        }),
      ),
    ),
    // Deeply nested in protocol
    deeplyNested: encodeURIComponent(
      btoa(JSON.stringify(createDeeplyNestedObject(100))),
    ),
  };
}

// ============================================================================
// Query Parameter Attack Payloads
// ============================================================================

/**
 * Creates URL query parameter attack values.
 */
export function createQueryParamAttacks(): Record<
  string,
  Record<string, string>
> {
  return {
    // Integer overflow in ts
    tsOverflow: {
      ts: String(Number.MAX_SAFE_INTEGER + 1),
      lmid: '0',
    },
    // Negative lmid
    negativeLmid: {
      ts: String(Date.now()),
      lmid: '-1',
    },
    // lmid as float
    floatLmid: {
      ts: String(Date.now()),
      lmid: '3.14',
    },
    // Very large numbers
    veryLarge: {
      ts: '999999999999999999999',
      lmid: '999999999999999999999',
    },
    // Scientific notation
    scientific: {
      ts: '1e15',
      lmid: '1e10',
    },
    // NaN and Infinity
    nanInf: {
      ts: 'NaN',
      lmid: 'Infinity',
    },
    // Hex notation
    hex: {
      ts: '0xFFFFFF',
      lmid: '0x10',
    },
    // Empty strings
    empty: {
      ts: '',
      lmid: '',
    },
    // Whitespace
    whitespace: {
      ts: '  100  ',
      lmid: '  0  ',
    },
    // Special characters
    special: {
      ts: '100;DROP TABLE',
      lmid: '0--',
    },
  };
}
