/**
 * State Machine Testing Helpers
 *
 * Utilities for testing connection lifecycle, message ordering,
 * and race conditions in zero-cache.
 */

import {resolver} from '@rocicorp/resolver';
import WebSocket from 'ws';
import {PROTOCOL_VERSION} from '../../../../zero-protocol/src/protocol-version.ts';
import {encodeSecProtocols} from '../../../../zero-protocol/src/connect.ts';
import type {Upstream} from '../../../../zero-protocol/src/up.ts';

export interface ConnectionConfig {
  port: number;
  clientGroupID: string;
  clientID: string;
  wsID: string;
  userID?: string | undefined;
  authToken?: string | undefined;
  baseCookie?: string | undefined;
  lmid?: number | undefined;
  schemaVersion?: number | undefined;
}

export interface ManagedConnection {
  config: ConnectionConfig;
  ws: WebSocket;
  /** Resolves when 'open' event fires */
  opened: Promise<void>;
  /** Resolves with close code/reason when 'close' event fires */
  closed: Promise<{code: number; reason: string}>;
  /** Collects all messages received */
  messages: unknown[];
  /** Resolves with first error if 'error' event fires */
  error: Promise<Error>;
  /** Send a protocol message */
  send: (msg: Upstream) => void;
  /** Close the connection */
  close: (code?: number, reason?: string) => void;
  /** Wait for a specific message type */
  waitForMessage: (
    type: string,
    timeoutMs?: number,
  ) => Promise<unknown | undefined>;
  /** Whether the connection is currently open */
  isOpen: () => boolean;
}

/**
 * Creates a managed WebSocket connection with message tracking.
 */
export function createConnection(config: ConnectionConfig): ManagedConnection {
  const {
    port,
    clientGroupID,
    clientID,
    wsID,
    userID = '',
    authToken,
    baseCookie = '',
    lmid = 0,
    schemaVersion = 1,
  } = config;

  const url =
    `ws://localhost:${port}/sync/v${PROTOCOL_VERSION}/connect` +
    `?clientGroupID=${encodeURIComponent(clientGroupID)}` +
    `&clientID=${encodeURIComponent(clientID)}` +
    `&wsid=${encodeURIComponent(wsID)}` +
    `&userID=${encodeURIComponent(userID)}` +
    `&schemaVersion=${schemaVersion}` +
    `&baseCookie=${encodeURIComponent(baseCookie)}` +
    `&ts=${Date.now()}` +
    `&lmid=${lmid}`;

  const protocol = encodeSecProtocols(undefined, authToken);
  const ws = new WebSocket(url, protocol);

  const messages: unknown[] = [];
  const messageWaiters: Array<{
    type: string;
    resolve: (msg: unknown) => void;
  }> = [];

  const {promise: opened, resolve: onOpen} = resolver<void>();
  const {promise: closed, resolve: onClose} = resolver<{
    code: number;
    reason: string;
  }>();
  const {promise: error, resolve: onError} = resolver<Error>();

  ws.on('open', () => onOpen());
  ws.on('close', (code, reason) => onClose({code, reason: reason.toString()}));
  ws.on('error', err => onError(err));
  ws.on('message', data => {
    try {
      const msg = JSON.parse(data.toString());
      messages.push(msg);

      // Check if any waiters match this message type
      if (Array.isArray(msg) && typeof msg[0] === 'string') {
        const msgType = msg[0];
        for (let i = messageWaiters.length - 1; i >= 0; i--) {
          if (messageWaiters[i].type === msgType) {
            messageWaiters[i].resolve(msg);
            messageWaiters.splice(i, 1);
          }
        }
      }
    } catch {
      messages.push(data.toString());
    }
  });

  return {
    config,
    ws,
    opened,
    closed,
    messages,
    error,
    send: (msg: Upstream) => {
      ws.send(JSON.stringify(msg));
    },
    close: (code?: number, reason?: string) => {
      if (ws.readyState === WebSocket.OPEN) {
        ws.close(code, reason);
      }
    },
    waitForMessage: (
      type: string,
      timeoutMs: number = 5000,
    ): Promise<unknown | undefined> => {
      // Check existing messages first
      for (const msg of messages) {
        if (Array.isArray(msg) && msg[0] === type) {
          return msg;
        }
      }

      // Wait for new message
      return new Promise(resolve => {
        const timeout = setTimeout(() => resolve(undefined), timeoutMs);
        messageWaiters.push({
          type,
          resolve: msg => {
            clearTimeout(timeout);
            resolve(msg);
          },
        });
      });
    },
    isOpen: () => ws.readyState === WebSocket.OPEN,
  };
}

/**
 * Creates multiple connections with the same clientID but different wsIDs.
 * Useful for testing connection replacement race conditions.
 */
export function createRacingConnections(
  port: number,
  clientGroupID: string,
  clientID: string,
  count: number,
): ManagedConnection[] {
  const connections: ManagedConnection[] = [];

  // Create all connections as fast as possible (no await between creates)
  for (let i = 0; i < count; i++) {
    const conn = createConnection({
      port,
      clientGroupID,
      clientID,
      wsID: `race-ws-${i}-${Date.now()}`,
    });
    connections.push(conn);
  }

  return connections;
}

/**
 * Sends messages rapidly from a connection without waiting for responses.
 * Useful for testing message ordering under load.
 */
export function sendRapidMessages(
  conn: ManagedConnection,
  messages: Upstream[],
): void {
  for (const msg of messages) {
    conn.send(msg);
  }
}

/**
 * Creates an initConnection message for testing.
 */
export function createInitConnectionMessage(
  desiredQueriesHash?: string,
): Upstream {
  return [
    'initConnection',
    {
      desiredQueriesHash: desiredQueriesHash ?? '',
    },
  ];
}

/**
 * Creates a changeDesiredQueries message for testing.
 */
export function createChangeDesiredQueriesMessage(
  queries: Array<{
    hash: string;
    ast: {table: string};
  }>,
): Upstream {
  return [
    'changeDesiredQueries',
    {
      desiredQueriesPatch: queries.map(q => ({
        op: 'put' as const,
        hash: q.hash,
        ast: {
          table: q.ast.table,
          orderBy: [['id', 'asc']],
        },
        ttl: undefined,
      })),
    },
  ];
}

/**
 * Creates a push message with custom mutations.
 */
export function createPushMessage(
  clientID: string,
  mutations: Array<{
    id: number;
    name: string;
    args?: unknown[];
  }>,
): Upstream {
  return [
    'push',
    {
      pushVersion: 1,
      clientGroupID: 'test-cg',
      requestID: `push-${Date.now()}`,
      schemaVersion: 1,
      timestamp: Date.now(),
      mutations: mutations.map(m => ({
        type: 'custom',
        clientID,
        id: m.id,
        name: m.name,
        timestamp: Date.now(),
        args: m.args ?? [],
      })),
    },
  ];
}

/**
 * Creates a ping message.
 */
export function createPingMessage(): Upstream {
  return ['ping', {}];
}

/**
 * Wait for multiple connections to reach a specific state.
 */
export async function waitForConnectionStates(
  connections: ManagedConnection[],
  expectedOpen: number,
  timeoutMs: number = 5000,
): Promise<{open: number; closed: number; timedOut: boolean}> {
  const deadline = Date.now() + timeoutMs;
  let open = 0;
  let closedCount = 0;

  const results = await Promise.all(
    connections.map(async conn => {
      const remaining = deadline - Date.now();
      if (remaining <= 0) return 'timeout';

      const result = await Promise.race([
        conn.opened.then(() => 'open' as const),
        conn.closed.then(() => 'closed' as const),
        new Promise<'timeout'>(r => setTimeout(() => r('timeout'), remaining)),
      ]);
      return result;
    }),
  );

  for (const result of results) {
    if (result === 'open') open++;
    else if (result === 'closed') closedCount++;
  }

  return {
    open,
    closed: closedCount,
    timedOut: results.includes('timeout'),
  };
}

/**
 * Measures latency of a ping-pong exchange.
 */
export async function measurePingLatency(
  conn: ManagedConnection,
  timeoutMs: number = 5000,
): Promise<number | undefined> {
  const start = Date.now();
  conn.send(createPingMessage());

  const pong = await conn.waitForMessage('pong', timeoutMs);
  if (!pong) return undefined;

  return Date.now() - start;
}

/**
 * Simulates rapid reconnection cycles.
 * Creates connection, waits for open, closes, repeats.
 */
export async function runReconnectCycles(
  port: number,
  clientGroupID: string,
  clientID: string,
  cycles: number,
  delayBetweenMs: number = 0,
): Promise<{
  successfulConnects: number;
  failedConnects: number;
  averageConnectTimeMs: number;
}> {
  let successfulConnects = 0;
  let failedConnects = 0;
  let totalConnectTime = 0;

  for (let i = 0; i < cycles; i++) {
    const start = Date.now();
    const conn = createConnection({
      port,
      clientGroupID,
      clientID,
      wsID: `reconnect-${i}-${Date.now()}`,
    });

    const result = await Promise.race([
      conn.opened.then(() => 'open' as const),
      conn.error.then(() => 'error' as const),
      new Promise<'timeout'>(r => setTimeout(() => r('timeout'), 5000)),
    ]);

    if (result === 'open') {
      successfulConnects++;
      totalConnectTime += Date.now() - start;
      conn.close();
    } else {
      failedConnects++;
    }

    if (delayBetweenMs > 0) {
      await new Promise(r => setTimeout(r, delayBetweenMs));
    }
  }

  return {
    successfulConnects,
    failedConnects,
    averageConnectTimeMs:
      successfulConnects > 0 ? totalConnectTime / successfulConnects : 0,
  };
}

/**
 * Utility to close all connections in a list.
 */
export function closeAllConnections(
  connections: ManagedConnection[],
  code?: number,
  reason?: string,
): void {
  for (const conn of connections) {
    try {
      conn.close(code, reason);
    } catch {
      // Ignore errors during cleanup
    }
  }
}

/**
 * Wait for all connections to close.
 */
export async function waitForAllClosed(
  connections: ManagedConnection[],
  timeoutMs: number = 5000,
): Promise<boolean> {
  const deadline = Date.now() + timeoutMs;

  for (const conn of connections) {
    const remaining = deadline - Date.now();
    if (remaining <= 0) return false;

    if (conn.ws.readyState === WebSocket.CLOSED) continue;

    await Promise.race([
      conn.closed,
      new Promise(r => setTimeout(r, remaining)),
    ]);
  }

  return connections.every(c => c.ws.readyState === WebSocket.CLOSED);
}
