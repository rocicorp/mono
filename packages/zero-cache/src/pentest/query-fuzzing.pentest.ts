/**
 * Query Engine Fuzzing - Pentest Suite
 *
 * Tests the ZQL query processing pipeline for:
 * - AST validation bypass
 * - SQL injection vectors
 * - RLS bypass attempts
 * - Resource exhaustion
 *
 * This suite uses handcrafted edge cases based on code review of:
 * - zero-protocol/src/ast.ts (AST validation)
 * - zero-cache/src/auth/read-authorizer.ts (RLS transformation)
 * - z2s/src/compiler.ts (SQL compilation)
 */

/* eslint-disable no-console */
// Console.log is used intentionally in pentest code to flag security findings

import {describe} from 'vitest';
import type {AST} from '../../../zero-protocol/src/ast.ts';
import {test} from '../test/db.ts';
import {
  createAuthDataVariants,
  createDeepNesting,
  createLimitEdgeCases,
  createMalformedASTs,
  createMalformedConditions,
  createOrderingEdgeCases,
  createResourceExhaustionASTs,
  createRLSBypassASTs,
  createStartEdgeCases,
  createValidAST,
  MALICIOUS_COLUMN_NAMES,
  MALICIOUS_TABLE_NAMES,
  SQL_INJECTION_PAYLOADS,
} from './helpers/ast-fuzzer.ts';
import {startPentestServer} from './helpers/pentest-server.ts';
import {
  createAddQueryMessage,
  createInitConnectionMessage,
  createMalformedQueryPatches,
  formatQueryResult,
  isSecurityConcern,
  sendMessage,
  sendRawMessage,
  waitForMessageType,
  waitForQueryResult,
} from './helpers/query-helpers.ts';
import {
  connectSync,
  createValidJWT,
  waitForConnection,
} from './helpers/ws-client.ts';

// Shared test secret
const TEST_SECRET = 'pentest-secret-key-at-least-32-chars-long';

describe('query engine fuzzing', {timeout: 120000}, () => {
  // ============================================================================
  // AST Structure Fuzzing
  // ============================================================================
  describe('AST structure fuzzing', () => {
    test('malformed AST structures', async ({testDBs}) => {
      const server = await startPentestServer(testDBs, {
        adminPassword: 'test-password',
        nodeEnv: 'production',
        auth: {secret: TEST_SECRET},
        schemaMode: 'multi-permission',
      });

      try {
        const token = await createValidJWT(TEST_SECRET, {
          sub: 'test-user',
          role: 'user',
        });
        const result = connectSync({
          port: server.port,
          authToken: token,
          userID: 'test-user',
        });

        // Wait for connection to open
        await result.opened;

        // Wait for connected message (longer timeout for initial connection)
        const connected = await waitForMessageType(
          result.ws,
          'connected',
          10000,
        );
        if (!connected) {
          result.ws.close();
          // Skip if server didn't send connected message (unusual but possible)
          console.log(
            '[INFO] Server did not send connected message - skipping test',
          );
          return;
        }

        const malformedASTs = createMalformedASTs();

        for (const [name, ast] of Object.entries(malformedASTs)) {
          // Send init connection with malformed AST
          const initMessage = createInitConnectionMessage([
            {ast: ast as AST, hash: `malformed-${name}`},
          ]);
          sendMessage(result.ws, initMessage);

          // Wait for response
          const queryResult = await waitForQueryResult(result.ws, 3000);

          // Server should NOT crash - timeout indicates potential crash
          if (queryResult.type === 'timeout') {
            console.log(
              `[FINDING] Malformed AST "${name}" caused timeout - possible crash`,
            );
          }

          // Check for security concerns
          if (isSecurityConcern(queryResult)) {
            console.log(
              `[FINDING] Malformed AST "${name}" caused security concern: ${formatQueryResult(queryResult)}`,
            );
          }
        }

        result.ws.close();
      } finally {
        await server.cleanup();
      }
    });

    test('malformed WHERE conditions', async ({testDBs}) => {
      const server = await startPentestServer(testDBs, {
        adminPassword: 'test-password',
        nodeEnv: 'production',
        auth: {secret: TEST_SECRET},
        schemaMode: 'multi-permission',
      });

      try {
        const token = await createValidJWT(TEST_SECRET, {
          sub: 'test-user',
          role: 'user',
        });
        const result = connectSync({
          port: server.port,
          authToken: token,
          userID: 'test-user',
        });

        // Wait for connection to open
        await result.opened;

        // Wait for connected message
        await waitForMessageType(result.ws, 'connected', 5000);

        const malformedConditions = createMalformedConditions();

        for (const [name, ast] of Object.entries(malformedConditions)) {
          const message = createAddQueryMessage([
            {ast, hash: `condition-${name}`},
          ]);
          sendMessage(result.ws, message);

          const queryResult = await waitForQueryResult(result.ws, 3000);

          if (isSecurityConcern(queryResult)) {
            console.log(
              `[FINDING] Malformed condition "${name}" caused security concern: ${formatQueryResult(queryResult)}`,
            );
          }
        }

        result.ws.close();
      } finally {
        await server.cleanup();
      }
    });

    test('deeply nested conditions', async ({testDBs}) => {
      const server = await startPentestServer(testDBs, {
        adminPassword: 'test-password',
        nodeEnv: 'production',
        auth: {secret: TEST_SECRET},
        schemaMode: 'multi-permission',
      });

      try {
        const token = await createValidJWT(TEST_SECRET, {
          sub: 'test-user',
          role: 'user',
        });
        const result = connectSync({
          port: server.port,
          authToken: token,
          userID: 'test-user',
        });

        await waitForConnection(result, 5000);
        await waitForMessageType(result.ws, 'connected', 3000);

        // Test various nesting depths
        const depths = [10, 50, 100, 200];

        for (const depth of depths) {
          const ast: AST = {
            table: 'readable',
            where: createDeepNesting(depth),
          };

          const message = createAddQueryMessage([
            {ast, hash: `depth-${depth}`},
          ]);
          sendMessage(result.ws, message);

          const queryResult = await waitForQueryResult(result.ws, 5000);

          if (queryResult.type === 'timeout') {
            console.log(
              `[FINDING] Depth ${depth} caused timeout - possible stack overflow`,
            );
          } else if (isSecurityConcern(queryResult)) {
            console.log(
              `[FINDING] Depth ${depth} caused security concern: ${formatQueryResult(queryResult)}`,
            );
          }
        }

        result.ws.close();
      } finally {
        await server.cleanup();
      }
    });
  });

  // ============================================================================
  // SQL Injection Vectors
  // ============================================================================
  describe('SQL injection vectors', () => {
    test('SQL injection in table names', async ({testDBs}) => {
      const server = await startPentestServer(testDBs, {
        adminPassword: 'test-password',
        nodeEnv: 'production',
        auth: {secret: TEST_SECRET},
        schemaMode: 'multi-permission',
      });

      try {
        const token = await createValidJWT(TEST_SECRET, {
          sub: 'test-user',
          role: 'user',
        });
        const result = connectSync({
          port: server.port,
          authToken: token,
          userID: 'test-user',
        });

        await waitForConnection(result, 5000);
        await waitForMessageType(result.ws, 'connected', 3000);

        for (const tableName of MALICIOUS_TABLE_NAMES) {
          const ast: AST = {table: tableName};
          const message = createAddQueryMessage([
            {ast, hash: `table-injection-${tableName.slice(0, 10)}`},
          ]);
          sendMessage(result.ws, message);

          const queryResult = await waitForQueryResult(result.ws, 3000);

          // These should all be rejected or return empty - never execute SQL
          if (queryResult.type === 'success') {
            const data = queryResult.data as unknown[];
            if (Array.isArray(data) && data.length > 0) {
              console.log(
                `[CRITICAL] SQL injection in table name returned data: "${tableName}"`,
              );
            }
          }

          if (isSecurityConcern(queryResult)) {
            console.log(
              `[FINDING] Table injection "${tableName.slice(0, 20)}..." caused: ${formatQueryResult(queryResult)}`,
            );
          }
        }

        result.ws.close();
      } finally {
        await server.cleanup();
      }
    });

    test('SQL injection in column names', async ({testDBs}) => {
      const server = await startPentestServer(testDBs, {
        adminPassword: 'test-password',
        nodeEnv: 'production',
        auth: {secret: TEST_SECRET},
        schemaMode: 'multi-permission',
      });

      try {
        const token = await createValidJWT(TEST_SECRET, {
          sub: 'test-user',
          role: 'user',
        });
        const result = connectSync({
          port: server.port,
          authToken: token,
          userID: 'test-user',
        });

        await waitForConnection(result, 5000);
        await waitForMessageType(result.ws, 'connected', 3000);

        for (const columnName of MALICIOUS_COLUMN_NAMES) {
          const ast: AST = {
            table: 'readable',
            where: {
              type: 'simple',
              op: '=',
              left: {type: 'column', name: columnName},
              right: {type: 'literal', value: 'test'},
            },
          };

          const message = createAddQueryMessage([
            {ast, hash: `col-injection-${columnName.slice(0, 10)}`},
          ]);
          sendMessage(result.ws, message);

          const queryResult = await waitForQueryResult(result.ws, 3000);

          if (isSecurityConcern(queryResult)) {
            console.log(
              `[FINDING] Column injection "${columnName.slice(0, 20)}..." caused: ${formatQueryResult(queryResult)}`,
            );
          }
        }

        result.ws.close();
      } finally {
        await server.cleanup();
      }
    });

    test('SQL injection in literal values', async ({testDBs}) => {
      const server = await startPentestServer(testDBs, {
        adminPassword: 'test-password',
        nodeEnv: 'production',
        auth: {secret: TEST_SECRET},
        schemaMode: 'multi-permission',
      });

      try {
        const token = await createValidJWT(TEST_SECRET, {
          sub: 'test-user',
          role: 'user',
        });
        const result = connectSync({
          port: server.port,
          authToken: token,
          userID: 'test-user',
        });

        await waitForConnection(result, 5000);
        await waitForMessageType(result.ws, 'connected', 3000);

        for (const [name, payload] of Object.entries(SQL_INJECTION_PAYLOADS)) {
          const ast: AST = {
            table: 'readable',
            where: {
              type: 'simple',
              op: '=',
              left: {type: 'column', name: 'id'},
              right: {type: 'literal', value: payload},
            },
          };

          const message = createAddQueryMessage([
            {ast, hash: `literal-${name}`},
          ]);
          sendMessage(result.ws, message);

          const queryResult = await waitForQueryResult(result.ws, 3000);

          // SQL injection should be parameterized - server should handle safely
          if (queryResult.type === 'success') {
            // This is fine - the value is just a search parameter that won't match
          } else if (isSecurityConcern(queryResult)) {
            console.log(
              `[FINDING] Literal injection "${name}" caused: ${formatQueryResult(queryResult)}`,
            );
          }
        }

        result.ws.close();
      } finally {
        await server.cleanup();
      }
    });

    test('SQL injection in array values', async ({testDBs}) => {
      const server = await startPentestServer(testDBs, {
        adminPassword: 'test-password',
        nodeEnv: 'production',
        auth: {secret: TEST_SECRET},
        schemaMode: 'multi-permission',
      });

      try {
        const token = await createValidJWT(TEST_SECRET, {
          sub: 'test-user',
          role: 'user',
        });
        const result = connectSync({
          port: server.port,
          authToken: token,
          userID: 'test-user',
        });

        await waitForConnection(result, 5000);
        await waitForMessageType(result.ws, 'connected', 3000);

        // Test SQL injection in array values (IN clause)
        const arrayPayloads = [
          ['normal', SQL_INJECTION_PAYLOADS.basicInjection],
          [SQL_INJECTION_PAYLOADS.unionSelect, 'normal'],
          [
            SQL_INJECTION_PAYLOADS.stackedQuery,
            SQL_INJECTION_PAYLOADS.dollarQuote,
          ],
        ];

        for (let i = 0; i < arrayPayloads.length; i++) {
          const ast: AST = {
            table: 'readable',
            where: {
              type: 'simple',
              op: 'IN',
              left: {type: 'column', name: 'id'},
              right: {type: 'literal', value: arrayPayloads[i]},
            },
          };

          const message = createAddQueryMessage([
            {ast, hash: `array-injection-${i}`},
          ]);
          sendMessage(result.ws, message);

          const queryResult = await waitForQueryResult(result.ws, 3000);

          if (isSecurityConcern(queryResult)) {
            console.log(
              `[FINDING] Array injection ${i} caused: ${formatQueryResult(queryResult)}`,
            );
          }
        }

        result.ws.close();
      } finally {
        await server.cleanup();
      }
    });

    test('SQL injection in ORDER BY', async ({testDBs}) => {
      const server = await startPentestServer(testDBs, {
        adminPassword: 'test-password',
        nodeEnv: 'production',
        auth: {secret: TEST_SECRET},
        schemaMode: 'multi-permission',
      });

      try {
        const token = await createValidJWT(TEST_SECRET, {
          sub: 'test-user',
          role: 'user',
        });
        const result = connectSync({
          port: server.port,
          authToken: token,
          userID: 'test-user',
        });

        await waitForConnection(result, 5000);
        await waitForMessageType(result.ws, 'connected', 3000);

        const orderingEdgeCases = createOrderingEdgeCases();

        for (const [name, ast] of Object.entries(orderingEdgeCases)) {
          const message = createAddQueryMessage([{ast, hash: `order-${name}`}]);
          sendMessage(result.ws, message);

          const queryResult = await waitForQueryResult(result.ws, 3000);

          if (isSecurityConcern(queryResult)) {
            console.log(
              `[FINDING] ORDER BY injection "${name}" caused: ${formatQueryResult(queryResult)}`,
            );
          }
        }

        result.ws.close();
      } finally {
        await server.cleanup();
      }
    });
  });

  // ============================================================================
  // RLS Bypass Attempts
  // ============================================================================
  describe('RLS bypass attempts', () => {
    test('query unreadable tables', async ({testDBs}) => {
      const server = await startPentestServer(testDBs, {
        adminPassword: 'test-password',
        nodeEnv: 'production',
        auth: {secret: TEST_SECRET},
        schemaMode: 'multi-permission',
      });

      try {
        // Connect as regular user (not admin)
        const token = await createValidJWT(TEST_SECRET, {
          sub: 'test-user',
          role: 'user',
        });
        const result = connectSync({
          port: server.port,
          authToken: token,
          userID: 'test-user',
        });

        await waitForConnection(result, 5000);
        await waitForMessageType(result.ws, 'connected', 3000);

        // Try to query unreadable table - should return empty results
        const ast: AST = {table: 'unreadable'};
        const message = createAddQueryMessage([
          {ast, hash: 'query-unreadable'},
        ]);
        sendMessage(result.ws, message);

        const queryResult = await waitForQueryResult(result.ws, 3000);

        // Should NOT return data from unreadable table
        if (queryResult.type === 'success') {
          console.log(
            '[INFO] Query to unreadable table processed (expected empty results)',
          );
        }

        result.ws.close();
      } finally {
        await server.cleanup();
      }
    });

    test('query protected tables as non-admin', async ({testDBs}) => {
      const server = await startPentestServer(testDBs, {
        adminPassword: 'test-password',
        nodeEnv: 'production',
        auth: {secret: TEST_SECRET},
        schemaMode: 'multi-permission',
      });

      try {
        // Connect as regular user (not admin)
        const token = await createValidJWT(TEST_SECRET, {
          sub: 'test-user',
          role: 'user',
        });
        const result = connectSync({
          port: server.port,
          authToken: token,
          userID: 'test-user',
        });

        await waitForConnection(result, 5000);
        await waitForMessageType(result.ws, 'connected', 3000);

        // Try to query protected table - should return empty
        const ast: AST = {table: 'protected'};
        const message = createAddQueryMessage([{ast, hash: 'query-protected'}]);
        sendMessage(result.ws, message);

        const queryResult = await waitForQueryResult(result.ws, 3000);

        if (queryResult.type === 'success') {
          console.log(
            '[INFO] Query to protected table processed (expected empty for non-admin)',
          );
        }

        result.ws.close();
      } finally {
        await server.cleanup();
      }
    });

    test('EXISTS subquery oracle attacks', async ({testDBs}) => {
      const server = await startPentestServer(testDBs, {
        adminPassword: 'test-password',
        nodeEnv: 'production',
        auth: {secret: TEST_SECRET},
        schemaMode: 'multi-permission',
      });

      try {
        const token = await createValidJWT(TEST_SECRET, {
          sub: 'test-user',
          role: 'user',
        });
        const result = connectSync({
          port: server.port,
          authToken: token,
          userID: 'test-user',
        });

        await waitForConnection(result, 5000);
        await waitForMessageType(result.ws, 'connected', 3000);

        const rlsBypassASTs = createRLSBypassASTs();

        for (const [name, ast] of Object.entries(rlsBypassASTs)) {
          const message = createAddQueryMessage([
            {ast: ast as AST, hash: `rls-${name}`},
          ]);
          sendMessage(result.ws, message);

          const queryResult = await waitForQueryResult(result.ws, 3000);

          // EXISTS on unreadable tables should be transformed to always return false
          if (queryResult.type === 'success') {
            // Verify no data from protected tables leaked
          } else if (isSecurityConcern(queryResult)) {
            console.log(
              `[FINDING] RLS bypass "${name}" caused: ${formatQueryResult(queryResult)}`,
            );
          }
        }

        result.ws.close();
      } finally {
        await server.cleanup();
      }
    });

    test('internalQuery injection attempt', async ({testDBs}) => {
      const server = await startPentestServer(testDBs, {
        adminPassword: 'test-password',
        nodeEnv: 'production',
        auth: {secret: TEST_SECRET},
        schemaMode: 'multi-permission',
      });

      try {
        const token = await createValidJWT(TEST_SECRET, {
          sub: 'test-user',
          role: 'user',
        });
        const result = connectSync({
          port: server.port,
          authToken: token,
          userID: 'test-user',
        });

        await waitForConnection(result, 5000);
        await waitForMessageType(result.ws, 'connected', 3000);

        // Try to mark query as internal to bypass permissions
        const ast = {
          table: 'unreadable',
          internalQuery: true, // This should be stripped/ignored
        };

        const message = createAddQueryMessage([
          {ast: ast as AST, hash: 'internal-injection'},
        ]);
        sendMessage(result.ws, message);

        const queryResult = await waitForQueryResult(result.ws, 3000);

        if (queryResult.type === 'success') {
          console.log(
            '[INFO] internalQuery flag processed (should be ignored)',
          );
        }

        result.ws.close();
      } finally {
        await server.cleanup();
      }
    });

    test('reserved query ID hijacking', async ({testDBs}) => {
      const server = await startPentestServer(testDBs, {
        adminPassword: 'test-password',
        nodeEnv: 'production',
        auth: {secret: TEST_SECRET},
        schemaMode: 'multi-permission',
      });

      try {
        const token = await createValidJWT(TEST_SECRET, {
          sub: 'test-user',
          role: 'user',
        });
        const result = connectSync({
          port: server.port,
          authToken: token,
          userID: 'test-user',
        });

        await waitForConnection(result, 5000);
        await waitForMessageType(result.ws, 'connected', 3000);

        // Try reserved query IDs
        const reservedIds = [
          'lmids',
          'mutationResults',
          '_internal',
          '__proto__',
        ];

        for (const id of reservedIds) {
          const ast: AST = {table: 'readable', alias: id};
          const message = createAddQueryMessage([{ast, hash: id}]);
          sendMessage(result.ws, message);

          const queryResult = await waitForQueryResult(result.ws, 3000);

          if (isSecurityConcern(queryResult)) {
            console.log(
              `[FINDING] Reserved ID "${id}" caused: ${formatQueryResult(queryResult)}`,
            );
          }
        }

        result.ws.close();
      } finally {
        await server.cleanup();
      }
    });
  });

  // ============================================================================
  // Boundary Values and Edge Cases
  // ============================================================================
  describe('boundary values and edge cases', () => {
    test('limit edge cases', async ({testDBs}) => {
      const server = await startPentestServer(testDBs, {
        adminPassword: 'test-password',
        nodeEnv: 'production',
        auth: {secret: TEST_SECRET},
        schemaMode: 'multi-permission',
      });

      try {
        const token = await createValidJWT(TEST_SECRET, {
          sub: 'test-user',
          role: 'user',
        });
        const result = connectSync({
          port: server.port,
          authToken: token,
          userID: 'test-user',
        });

        await waitForConnection(result, 5000);
        await waitForMessageType(result.ws, 'connected', 3000);

        const limitEdgeCases = createLimitEdgeCases();

        for (const [name, ast] of Object.entries(limitEdgeCases)) {
          const message = createAddQueryMessage([{ast, hash: `limit-${name}`}]);
          sendMessage(result.ws, message);

          const queryResult = await waitForQueryResult(result.ws, 3000);

          if (isSecurityConcern(queryResult)) {
            console.log(
              `[FINDING] Limit edge case "${name}" caused: ${formatQueryResult(queryResult)}`,
            );
          }
        }

        result.ws.close();
      } finally {
        await server.cleanup();
      }
    });

    test('start/cursor edge cases', async ({testDBs}) => {
      const server = await startPentestServer(testDBs, {
        adminPassword: 'test-password',
        nodeEnv: 'production',
        auth: {secret: TEST_SECRET},
        schemaMode: 'multi-permission',
      });

      try {
        const token = await createValidJWT(TEST_SECRET, {
          sub: 'test-user',
          role: 'user',
        });
        const result = connectSync({
          port: server.port,
          authToken: token,
          userID: 'test-user',
        });

        await waitForConnection(result, 5000);
        await waitForMessageType(result.ws, 'connected', 3000);

        const startEdgeCases = createStartEdgeCases();

        for (const [name, ast] of Object.entries(startEdgeCases)) {
          const message = createAddQueryMessage([{ast, hash: `start-${name}`}]);
          sendMessage(result.ws, message);

          const queryResult = await waitForQueryResult(result.ws, 3000);

          if (isSecurityConcern(queryResult)) {
            console.log(
              `[FINDING] Start edge case "${name}" caused: ${formatQueryResult(queryResult)}`,
            );
          }
        }

        result.ws.close();
      } finally {
        await server.cleanup();
      }
    });
  });

  // ============================================================================
  // Resource Exhaustion
  // ============================================================================
  describe('resource exhaustion', () => {
    test('resource exhaustion ASTs', async ({testDBs}) => {
      const server = await startPentestServer(testDBs, {
        adminPassword: 'test-password',
        nodeEnv: 'production',
        auth: {secret: TEST_SECRET},
        schemaMode: 'multi-permission',
      });

      try {
        const token = await createValidJWT(TEST_SECRET, {
          sub: 'test-user',
          role: 'user',
        });
        const result = connectSync({
          port: server.port,
          authToken: token,
          userID: 'test-user',
        });

        await waitForConnection(result, 5000);
        await waitForMessageType(result.ws, 'connected', 3000);

        const exhaustionASTs = createResourceExhaustionASTs();

        for (const [name, ast] of Object.entries(exhaustionASTs)) {
          const message = createAddQueryMessage([
            {ast, hash: `exhaust-${name}`},
          ]);
          sendMessage(result.ws, message);

          // Use longer timeout for resource exhaustion tests
          const queryResult = await waitForQueryResult(result.ws, 10000);

          if (queryResult.type === 'timeout') {
            console.log(
              `[FINDING] Resource exhaustion "${name}" caused timeout`,
            );
          } else if (isSecurityConcern(queryResult)) {
            console.log(
              `[FINDING] Resource exhaustion "${name}" caused: ${formatQueryResult(queryResult)}`,
            );
          }
        }

        result.ws.close();
      } finally {
        await server.cleanup();
      }
    });

    test('many concurrent queries', async ({testDBs}) => {
      const server = await startPentestServer(testDBs, {
        adminPassword: 'test-password',
        nodeEnv: 'production',
        auth: {secret: TEST_SECRET},
        schemaMode: 'multi-permission',
      });

      try {
        const token = await createValidJWT(TEST_SECRET, {
          sub: 'test-user',
          role: 'user',
        });
        const result = connectSync({
          port: server.port,
          authToken: token,
          userID: 'test-user',
        });

        await waitForConnection(result, 5000);
        await waitForMessageType(result.ws, 'connected', 3000);

        // Send many queries at once
        const queries = Array.from({length: 100}, (_, i) => ({
          ast: createValidAST('readable'),
          hash: `concurrent-${i}`,
        }));

        const message = createAddQueryMessage(queries);
        sendMessage(result.ws, message);

        // Wait for processing
        const queryResult = await waitForQueryResult(result.ws, 15000);

        if (queryResult.type === 'timeout') {
          console.log('[FINDING] Many concurrent queries caused timeout');
        }

        result.ws.close();
      } finally {
        await server.cleanup();
      }
    });
  });

  // ============================================================================
  // Query Patch Fuzzing
  // ============================================================================
  describe('query patch fuzzing', () => {
    test('malformed query patches', async ({testDBs}) => {
      const server = await startPentestServer(testDBs, {
        adminPassword: 'test-password',
        nodeEnv: 'production',
        auth: {secret: TEST_SECRET},
        schemaMode: 'multi-permission',
      });

      try {
        const token = await createValidJWT(TEST_SECRET, {
          sub: 'test-user',
          role: 'user',
        });
        const result = connectSync({
          port: server.port,
          authToken: token,
          userID: 'test-user',
        });

        await waitForConnection(result, 5000);
        await waitForMessageType(result.ws, 'connected', 3000);

        const malformedPatches = createMalformedQueryPatches();

        for (const [name, patch] of Object.entries(malformedPatches)) {
          // Send raw malformed message
          const message = [
            'changeDesiredQueries',
            {desiredQueriesPatch: [patch]},
          ];
          sendRawMessage(result.ws, message);

          const queryResult = await waitForQueryResult(result.ws, 3000);

          if (queryResult.type === 'timeout') {
            console.log(`[FINDING] Malformed patch "${name}" caused timeout`);
          }
        }

        result.ws.close();
      } finally {
        await server.cleanup();
      }
    });
  });

  // ============================================================================
  // authData Edge Cases
  // ============================================================================
  describe('authData edge cases', () => {
    test('various authData structures in JWT', async ({testDBs}) => {
      const server = await startPentestServer(testDBs, {
        adminPassword: 'test-password',
        nodeEnv: 'production',
        auth: {secret: TEST_SECRET},
        schemaMode: 'multi-permission',
      });

      try {
        const authVariants = createAuthDataVariants();

        for (const [name, authData] of Object.entries(authVariants)) {
          // Skip null/undefined variants as they can't be put in JWT
          if (authData === null || authData === undefined) {
            continue;
          }

          try {
            const token = await createValidJWT(TEST_SECRET, {
              sub: 'test-user',
              ...(typeof authData === 'object' ? authData : {}),
            });

            const result = connectSync({
              port: server.port,
              authToken: token,
              userID: 'test-user',
            });

            const connectionResult = await waitForConnection(result, 5000);

            if (connectionResult.type === 'timeout') {
              console.log(
                `[FINDING] authData "${name}" caused connection timeout`,
              );
            }

            result.ws.close();
          } catch {
            // JWT creation may fail for some variants - that's expected
          }
        }
      } finally {
        await server.cleanup();
      }
    });
  });
});
