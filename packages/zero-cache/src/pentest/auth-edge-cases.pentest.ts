/**
 * Authentication Edge Cases - Pentest Suite
 *
 * Tests authentication handling for edge cases not easily found through
 * static code review. Focuses on:
 * - Malformed sec-websocket-protocol headers
 * - JWT verification edge cases
 * - Auth state/config edge cases
 */

/* eslint-disable no-console */
// Console.log is used intentionally in pentest code to flag security findings

import {describe, expect} from 'vitest';
import WebSocket from 'ws';
import {encodeSecProtocols} from '../../../zero-protocol/src/connect.ts';
import {test} from '../test/db.ts';
import {startPentestServer} from './helpers/pentest-server.ts';
import {
  connectSync,
  tryConnectSync,
  createMalformedProtocols,
  createMalformedTokens,
  createValidJWT,
  waitForConnection,
  waitForOpenThenClose,
} from './helpers/ws-client.ts';

// Shared secret for JWT tests
const TEST_SECRET = 'pentest-secret-key-at-least-32-chars-long';

describe('auth edge cases', {timeout: 60000}, () => {
  describe('malformed sec-websocket-protocol headers', () => {
    test('invalid base64 in protocol header', async ({testDBs}) => {
      const server = await startPentestServer(testDBs, {
        adminPassword: 'test-password',
        nodeEnv: 'production',
        auth: {secret: TEST_SECRET},
      });

      try {
        const protocols = createMalformedProtocols();

        for (const [name, protocol] of Object.entries(protocols)) {
          const result = tryConnectSync({
            port: server.port,
            rawProtocol: protocol,
          });

          // Some protocols are rejected by ws library at constructor time
          if ('constructorError' in result) {
            // This is expected for invalid protocol strings
            continue;
          }

          const outcome = await waitForConnection(result, 3000);
          result.ws.close();

          // Server should reject malformed protocols gracefully
          // (either close connection or return error, but not crash)
          expect(
            outcome.type,
            `Protocol "${name}" should not timeout - server may have crashed`,
          ).not.toBe('timeout');

          // If connection succeeded, that's interesting - log it
          if (outcome.type === 'opened') {
            console.log(
              `[FINDING] Malformed protocol "${name}" was accepted by server`,
            );
          }
        }
      } finally {
        await server.cleanup();
      }
    });

    test('missing sec-websocket-protocol header', async ({testDBs}) => {
      const server = await startPentestServer(testDBs, {
        adminPassword: 'test-password',
        nodeEnv: 'production',
        auth: {secret: TEST_SECRET},
      });

      try {
        const result = connectSync({
          port: server.port,
          skipProtocol: true,
        });

        const outcome = await waitForConnection(result, 3000);
        result.ws.close();

        // Without protocol header, server should reject
        // (connect-params.ts line 51 uses must() which throws)
        expect(outcome.type).toBe('closed');
        if (outcome.type === 'closed') {
          expect(outcome.code).toBeGreaterThanOrEqual(1000);
        }
      } finally {
        await server.cleanup();
      }
    });
  });

  describe('JWT verification edge cases', () => {
    test('malformed JWT tokens', async ({testDBs}) => {
      const server = await startPentestServer(testDBs, {
        adminPassword: 'test-password',
        nodeEnv: 'production',
        auth: {secret: TEST_SECRET},
      });

      try {
        // First create a valid token to generate malformed variants
        const validToken = await createValidJWT(TEST_SECRET, {
          sub: 'test-user',
        });
        const malformedTokens = createMalformedTokens(validToken);

        for (const [name, token] of Object.entries(malformedTokens)) {
          const result = connectSync({
            port: server.port,
            authToken: token,
            userID: 'test-user',
          });

          const outcome = await waitForConnection(result, 3000);
          result.ws.close();

          // Server should reject malformed tokens
          expect(
            outcome.type,
            `Token "${name}" should not timeout - server may have crashed`,
          ).not.toBe('timeout');

          // If connection with malformed token succeeded, that's a finding
          if (outcome.type === 'opened') {
            console.log(
              `[FINDING] Malformed token "${name}" was accepted by server`,
            );
          }
        }
      } finally {
        await server.cleanup();
      }
    });

    test('expired JWT token', async ({testDBs}) => {
      const server = await startPentestServer(testDBs, {
        adminPassword: 'test-password',
        nodeEnv: 'production',
        auth: {secret: TEST_SECRET},
      });

      try {
        const expiredToken = await createValidJWT(TEST_SECRET, {
          sub: 'test-user',
          exp: Math.floor(Date.now() / 1000) - 3600, // Expired 1 hour ago
          iat: Math.floor(Date.now() / 1000) - 7200, // Issued 2 hours ago
        });

        const result = connectSync({
          port: server.port,
          authToken: expiredToken,
          userID: 'test-user',
        });

        // WebSocket opens, then auth fails, then closes with error
        const outcome = await waitForOpenThenClose(result, 5000);
        result.ws.close();

        // Expired tokens should be rejected - WS opens first, then closes
        expect(
          outcome.type === 'openedThenClosed' || outcome.type === 'closed',
        ).toBe(true);
        if (outcome.type === 'openedThenClosed') {
          // Close code 3000 indicates JWT error per syncer.ts:183
          expect(outcome.closeCode).toBe(3000);
          // Error message should be sent before close
          expect(outcome.message).toBeDefined();
        }
        if (outcome.type === 'opened') {
          console.log('[FINDING] Expired token accepted without close!');
        }
      } finally {
        await server.cleanup();
      }
    });

    test('JWT with nbf (not before) in the future', async ({testDBs}) => {
      const server = await startPentestServer(testDBs, {
        adminPassword: 'test-password',
        nodeEnv: 'production',
        auth: {secret: TEST_SECRET},
      });

      try {
        const futureToken = await createValidJWT(TEST_SECRET, {
          sub: 'test-user',
          nbf: Math.floor(Date.now() / 1000) + 3600, // Not valid for 1 hour
        });

        const result = connectSync({
          port: server.port,
          authToken: futureToken,
          userID: 'test-user',
        });

        const outcome = await waitForOpenThenClose(result, 5000);
        result.ws.close();

        // Future tokens should be rejected
        expect(
          outcome.type === 'openedThenClosed' || outcome.type === 'closed',
        ).toBe(true);
        if (outcome.type === 'openedThenClosed') {
          expect(outcome.closeCode).toBe(3000);
        }
        if (outcome.type === 'opened') {
          console.log('[FINDING] Future nbf token accepted without close!');
        }
      } finally {
        await server.cleanup();
      }
    });

    test('JWT with wrong algorithm claim', async ({testDBs}) => {
      const server = await startPentestServer(testDBs, {
        adminPassword: 'test-password',
        nodeEnv: 'production',
        auth: {secret: TEST_SECRET},
      });

      try {
        // Create a token but manually craft one with "alg":"none"
        // This tests for algorithm confusion attacks
        const header = btoa(JSON.stringify({alg: 'none', typ: 'JWT'}));
        const payload = btoa(
          JSON.stringify({
            sub: 'test-user',
            iat: Math.floor(Date.now() / 1000),
            exp: Math.floor(Date.now() / 1000) + 3600,
          }),
        );
        const algNoneToken = `${header}.${payload}.`;

        const result = connectSync({
          port: server.port,
          authToken: algNoneToken,
          userID: 'test-user',
        });

        const outcome = await waitForOpenThenClose(result, 5000);
        result.ws.close();

        // "alg: none" attack should be rejected
        expect(
          outcome.type === 'openedThenClosed' || outcome.type === 'closed',
        ).toBe(true);
        if (outcome.type === 'opened') {
          console.log('[CRITICAL] Algorithm "none" attack succeeded!');
        }
      } finally {
        await server.cleanup();
      }
    });

    test('JWT subject mismatch with userID', async ({testDBs}) => {
      const server = await startPentestServer(testDBs, {
        adminPassword: 'test-password',
        nodeEnv: 'production',
        auth: {secret: TEST_SECRET},
      });

      try {
        // Token has subject "user-a" but connecting as "user-b"
        const token = await createValidJWT(TEST_SECRET, {sub: 'user-a'});

        const result = connectSync({
          port: server.port,
          authToken: token,
          userID: 'user-b', // Different from token subject
        });

        const outcome = await waitForOpenThenClose(result, 5000);
        result.ws.close();

        // Subject mismatch should be rejected
        // syncer.ts:166-168 passes userID as subject to verifyToken
        expect(
          outcome.type === 'openedThenClosed' || outcome.type === 'closed',
        ).toBe(true);
        if (outcome.type === 'opened') {
          console.log(
            '[FINDING] Subject mismatch accepted - user impersonation possible',
          );
        }
      } finally {
        await server.cleanup();
      }
    });

    test('JWT signed with wrong secret', async ({testDBs}) => {
      const server = await startPentestServer(testDBs, {
        adminPassword: 'test-password',
        nodeEnv: 'production',
        auth: {secret: TEST_SECRET},
      });

      try {
        // Token signed with different secret
        const wrongToken = await createValidJWT(
          'wrong-secret-that-is-long-enough',
          {
            sub: 'test-user',
          },
        );

        const result = connectSync({
          port: server.port,
          authToken: wrongToken,
          userID: 'test-user',
        });

        const outcome = await waitForOpenThenClose(result, 5000);
        result.ws.close();

        // Wrong signature should be rejected
        expect(
          outcome.type === 'openedThenClosed' || outcome.type === 'closed',
        ).toBe(true);
        if (outcome.type === 'opened') {
          console.log('[CRITICAL] Token with wrong signature was accepted!');
        }
      } finally {
        await server.cleanup();
      }
    });
  });

  describe('auth config edge cases', () => {
    test('no token when JWT verification configured', async ({testDBs}) => {
      const server = await startPentestServer(testDBs, {
        adminPassword: 'test-password',
        nodeEnv: 'production',
        auth: {secret: TEST_SECRET},
      });

      try {
        // Connect without auth token when server expects one
        const result = connectSync({
          port: server.port,
          // No authToken
        });

        const outcome = await waitForConnection(result, 3000);
        result.ws.close();

        // Behavior depends on whether custom endpoints are also configured
        // With only JWT config, this should likely work (anonymous connection)
        // unless permissions require auth
        if (outcome.type === 'opened') {
          console.log(
            '[INFO] Anonymous connection allowed with JWT configured (expected)',
          );
        }
      } finally {
        await server.cleanup();
      }
    });

    test('valid token when no JWT verification configured', async ({
      testDBs,
    }) => {
      const server = await startPentestServer(testDBs, {
        adminPassword: 'test-password',
        nodeEnv: 'production',
        // No auth config
      });

      try {
        // Send token when server has no JWT config
        const token = await createValidJWT(TEST_SECRET, {sub: 'test-user'});

        const result = connectSync({
          port: server.port,
          authToken: token,
          userID: 'test-user',
        });

        const outcome = await waitForOpenThenClose(result, 5000);
        result.ws.close();

        // Without JWT config or custom endpoints, providing a token
        // should error (syncer.ts:156-162)
        // Connection may open then close with error, or fail to upgrade
        expect(outcome.type).not.toBe('timeout');
        if (outcome.type === 'opened') {
          console.log(
            '[INFO] Token accepted without JWT config - check if custom endpoints bypass',
          );
        }
      } finally {
        await server.cleanup();
      }
    });

    test('empty string token', async ({testDBs}) => {
      const server = await startPentestServer(testDBs, {
        adminPassword: 'test-password',
        nodeEnv: 'production',
        auth: {secret: TEST_SECRET},
      });

      try {
        const result = connectSync({
          port: server.port,
          authToken: '', // Empty string
          userID: 'test-user',
        });

        const outcome = await waitForConnection(result, 3000);
        result.ws.close();

        // Empty token should be treated as "no token" or rejected
        expect(outcome.type).not.toBe('timeout');
      } finally {
        await server.cleanup();
      }
    });

    test('connection reuse after token expiry', async ({testDBs}) => {
      // This tests whether an established connection remains valid
      // after the token that established it expires
      const server = await startPentestServer(testDBs, {
        adminPassword: 'test-password',
        nodeEnv: 'production',
        auth: {secret: TEST_SECRET},
      });

      try {
        // Create a token that expires very soon
        const shortLivedToken = await createValidJWT(TEST_SECRET, {
          sub: 'test-user',
          exp: Math.floor(Date.now() / 1000) + 2, // Expires in 2 seconds
        });

        const result = connectSync({
          port: server.port,
          authToken: shortLivedToken,
          userID: 'test-user',
        });

        const outcome = await waitForConnection(result, 3000);

        if (outcome.type === 'opened') {
          // Connection established, wait for token to expire
          await new Promise(resolve => setTimeout(resolve, 3000));

          // Connection should still be open (tokens validated once at connect)
          expect(result.ws.readyState).toBe(result.ws.OPEN);
          console.log(
            '[INFO] Connection persists after token expiry (expected behavior)',
          );
        }

        result.ws.close();
      } finally {
        await server.cleanup();
      }
    });
  });

  describe('protocol version edge cases', () => {
    test('invalid protocol version in URL', async ({testDBs}) => {
      const server = await startPentestServer(testDBs, {
        adminPassword: 'test-password',
        nodeEnv: 'production',
      });

      try {
        // Try connecting with invalid protocol version
        const ws = new WebSocket(
          `ws://localhost:${server.port}/sync/v999/connect` +
            `?clientGroupID=test-cg&clientID=test-client&wsid=test` +
            `&schemaVersion=1&baseCookie=&ts=${Date.now()}&lmid=0`,
          encodeSecProtocols(undefined, undefined),
        );

        const closed = new Promise<{code: number; reason: string}>(resolve => {
          ws.on('close', (code, reason) =>
            resolve({code, reason: reason.toString()}),
          );
        });
        const errored = new Promise<Error>(resolve => {
          ws.on('error', err => resolve(err));
        });

        const result = await Promise.race([
          closed.then(r => ({type: 'closed' as const, ...r})),
          errored.then(e => ({type: 'error' as const, error: e})),
          new Promise<{type: 'timeout'}>(resolve =>
            setTimeout(() => resolve({type: 'timeout'}), 3000),
          ),
        ]);

        ws.close();

        // Invalid version should be rejected
        expect(result.type).not.toBe('timeout');
        if (result.type === 'closed') {
          // 1002 = protocol error, or server may return custom code
          expect(result.code).toBeGreaterThanOrEqual(1000);
        }
      } finally {
        await server.cleanup();
      }
    });
  });
});
