/**
 * Change Streamer Authentication Pentest Suite
 *
 * Tests for critical security issues in the change-streamer replication endpoints:
 * - /replication/v1/changes - CDC (Change Data Capture) subscription
 * - /replication/v1/snapshot - Full database snapshot retrieval
 *
 * CRITICAL FINDING: These endpoints appear to have NO authentication.
 * A network-local attacker could subscribe to ALL database changes without credentials.
 *
 * Test categories:
 * 1. Unauthenticated access to replication endpoints
 * 2. Cross-tenant data leakage via change streams
 * 3. Snapshot exfiltration without credentials
 */

/* eslint-disable no-console */
// Console.log is used intentionally in pentest code to flag security findings

import {resolver} from '@rocicorp/resolver';
import {describe, expect} from 'vitest';
import WebSocket from 'ws';
import {PROTOCOL_VERSION as REPLICATION_PROTOCOL_VERSION} from '../services/change-streamer/change-streamer.ts';
import {test} from '../test/db.ts';
import {startPentestServer} from './helpers/pentest-server.ts';
import {connectSync, waitForConnection} from './helpers/ws-client.ts';
import {createMutationAuthToken} from './helpers/mutation-helpers.ts';

const TEST_SECRET = 'pentest-change-streamer-secret-32chars!';

describe('change-streamer authentication', {timeout: 120000}, () => {
  // ===========================================================================
  // 1. Unauthenticated Access Tests
  // ===========================================================================
  describe('unauthenticated replication access', () => {
    test('CRITICAL: unauthenticated snapshot request should be rejected', async ({
      testDBs,
    }) => {
      const server = await startPentestServer(testDBs, {
        adminPassword: 'test-password',
        nodeEnv: 'production',
        schemaMode: 'mutation-test',
        auth: {secret: TEST_SECRET},
      });

      try {
        // Attempt to connect to snapshot endpoint without any authentication
        const snapshotUrl = `ws://localhost:${server.replicationPort}/replication/v${REPLICATION_PROTOCOL_VERSION}/snapshot?taskID=pentest-snapshot-1`;

        const {promise: closed, resolve: onClose} = resolver<{
          code: number;
          reason: string;
        }>();
        const {promise: opened, resolve: onOpen} = resolver<void>();
        const {promise: message, resolve: onMessage} = resolver<unknown>();

        const ws = new WebSocket(snapshotUrl);
        ws.on('open', () => onOpen());
        ws.on('close', (code, reason) =>
          onClose({code, reason: reason.toString()}),
        );
        ws.on('message', data => {
          try {
            onMessage(JSON.parse(data.toString()));
          } catch {
            onMessage(data.toString());
          }
        });

        // Wait for connection result
        const timeout = new Promise<'timeout'>(resolve =>
          setTimeout(() => resolve('timeout'), 10000),
        );
        const result = await Promise.race([
          opened.then(() => 'opened' as const),
          closed.then(c => ({closed: c})),
          timeout,
        ]);

        if (result === 'opened') {
          // Connection opened - check if we receive snapshot data
          const msgOrTimeout = await Promise.race([
            message,
            new Promise<'msg-timeout'>(r =>
              setTimeout(() => r('msg-timeout'), 5000),
            ),
          ]);

          if (msgOrTimeout !== 'msg-timeout') {
            console.log(
              '[CRITICAL FINDING] Unauthenticated snapshot endpoint returned data:',
              typeof msgOrTimeout === 'object'
                ? JSON.stringify(msgOrTimeout).slice(0, 200)
                : msgOrTimeout,
            );
          } else {
            console.log(
              '[INFO] Snapshot endpoint opened but no data received (may require specific params)',
            );
          }
        } else if (result === 'timeout') {
          console.log('[INFO] Snapshot endpoint connection timed out');
        } else {
          console.log(
            '[INFO] Snapshot endpoint rejected with code:',
            result.closed.code,
            'reason:',
            result.closed.reason,
          );
        }

        ws.close();
      } finally {
        await server.cleanup();
      }
    });

    test('CRITICAL: unauthenticated change subscription should be rejected', async ({
      testDBs,
    }) => {
      const server = await startPentestServer(testDBs, {
        adminPassword: 'test-password',
        nodeEnv: 'production',
        schemaMode: 'mutation-test',
        auth: {secret: TEST_SECRET},
      });

      try {
        // Attempt to connect to changes endpoint without authentication
        const changesUrl =
          `ws://localhost:${server.replicationPort}/replication/v${REPLICATION_PROTOCOL_VERSION}/changes` +
          `?id=pentest-attacker` +
          `&mode=serving` +
          `&replicaVersion=1` +
          `&watermark=00000000000000000000` +
          `&initial=true`;

        const {promise: closed, resolve: onClose} = resolver<{
          code: number;
          reason: string;
        }>();
        const {promise: opened, resolve: onOpen} = resolver<void>();
        const messages: unknown[] = [];

        const ws = new WebSocket(changesUrl);
        ws.on('open', () => onOpen());
        ws.on('close', (code, reason) =>
          onClose({code, reason: reason.toString()}),
        );
        ws.on('message', data => {
          try {
            const parsed = JSON.parse(data.toString());
            messages.push(parsed);
          } catch {
            messages.push(data.toString());
          }
        });

        // Wait for connection result
        const timeout = new Promise<'timeout'>(resolve =>
          setTimeout(() => resolve('timeout'), 10000),
        );
        const result = await Promise.race([
          opened.then(() => 'opened' as const),
          closed.then(c => ({closed: c})),
          timeout,
        ]);

        if (result === 'opened') {
          // Wait a bit for any CDC data to arrive
          await new Promise(resolve => setTimeout(resolve, 3000));

          if (messages.length > 0) {
            console.log(
              '[CRITICAL FINDING] Unauthenticated change-streamer endpoint returned data:',
            );
            console.log(
              '  Messages received:',
              messages.length,
            );
            console.log(
              '  First message:',
              JSON.stringify(messages[0]).slice(0, 300),
            );
          } else {
            console.log(
              '[INFO] Change-streamer opened but no changes received (may be idle)',
            );
          }
        } else if (result === 'timeout') {
          console.log('[INFO] Change-streamer connection timed out');
        } else {
          console.log(
            '[INFO] Change-streamer rejected with code:',
            result.closed.code,
            'reason:',
            result.closed.reason,
          );
        }

        ws.close();
      } finally {
        await server.cleanup();
      }
    });

    test('replication endpoint with invalid protocol version is rejected', async ({
      testDBs,
    }) => {
      const server = await startPentestServer(testDBs, {
        adminPassword: 'test-password',
        nodeEnv: 'production',
        schemaMode: 'mutation-test',
        auth: {secret: TEST_SECRET},
      });

      try {
        // Try invalid protocol versions
        const invalidVersions = [0, 999, -1];

        for (const version of invalidVersions) {
          const url = `ws://localhost:${server.replicationPort}/replication/v${version}/changes?id=test&mode=serving&replicaVersion=1&watermark=0&initial=true`;

          const {promise: result, resolve: onResult} = resolver<string>();
          const ws = new WebSocket(url);
          ws.on('open', () => onResult('opened'));
          ws.on('close', (code, reason) =>
            onResult(`closed:${code}:${reason.toString()}`),
          );
          ws.on('error', () => onResult('error'));

          const timeout = new Promise<string>(r =>
            setTimeout(() => r('timeout'), 5000),
          );
          const outcome = await Promise.race([result, timeout]);

          if (outcome === 'opened') {
            console.log(
              `[FINDING] Invalid protocol version v${version} accepted`,
            );
          } else {
            console.log(
              `[INFO] Protocol version v${version} rejected: ${outcome}`,
            );
          }

          ws.close();
        }
      } finally {
        await server.cleanup();
      }
    });

    test('replication endpoint path traversal attempt', async ({testDBs}) => {
      const server = await startPentestServer(testDBs, {
        adminPassword: 'test-password',
        nodeEnv: 'production',
        schemaMode: 'mutation-test',
        auth: {secret: TEST_SECRET},
      });

      try {
        // Try path traversal in replication endpoint
        const maliciousPaths = [
          '/replication/../admin/status',
          '/replication/v1/../../../etc/passwd',
          '/replication/v1/changes%00/admin',
          '/replication/v1/changes;../admin',
        ];

        for (const path of maliciousPaths) {
          const url = `ws://localhost:${server.replicationPort}${path}`;

          const {promise: result, resolve: onResult} = resolver<string>();
          try {
            const ws = new WebSocket(url);
            ws.on('open', () => {
              onResult('opened');
              ws.close();
            });
            ws.on('close', (code, reason) =>
              onResult(`closed:${code}:${reason.toString()}`),
            );
            ws.on('error', e => onResult(`error:${e.message}`));

            const timeout = new Promise<string>(r =>
              setTimeout(() => r('timeout'), 3000),
            );
            const outcome = await Promise.race([result, timeout]);

            if (outcome === 'opened') {
              console.log(
                `[FINDING] Path traversal accepted: ${path.slice(0, 50)}`,
              );
            } else {
              console.log(
                `[INFO] Path traversal rejected: ${path.slice(0, 30)} -> ${outcome.slice(0, 50)}`,
              );
            }
          } catch (e) {
            console.log(
              `[INFO] Path traversal caused error: ${path.slice(0, 30)} -> ${String(e).slice(0, 50)}`,
            );
          }
        }
      } finally {
        await server.cleanup();
      }
    });
  });

  // ===========================================================================
  // 2. Cross-Tenant Data Leakage Tests
  // ===========================================================================
  describe('cross-tenant change leakage', () => {
    test('subscriber cannot see other tenants changes', async ({testDBs}) => {
      // This test checks if app isolation exists in the change-streamer
      const server = await startPentestServer(testDBs, {
        adminPassword: 'test-password',
        nodeEnv: 'production',
        schemaMode: 'mutation-test',
        auth: {secret: TEST_SECRET},
      });

      try {
        // First, create a legitimate sync connection and make changes
        const legitimateToken = await createMutationAuthToken(TEST_SECRET, {
          sub: 'user-1',
          role: 'admin',
        });

        // Connect as legitimate user
        const legitimateConn = connectSync({
          port: server.port,
          clientGroupID: 'tenant-a-cg',
          clientID: 'tenant-a-client',
          userID: 'user-1',
          authToken: legitimateToken,
        });

        const legOutcome = await waitForConnection(legitimateConn, 5000);
        expect(legOutcome.type).toBe('opened');

        // Now try to subscribe to replication with different tenant ID
        const attackerUrl =
          `ws://localhost:${server.replicationPort}/replication/v${REPLICATION_PROTOCOL_VERSION}/changes` +
          `?id=attacker-impersonating-tenant-b` +
          `&mode=serving` +
          `&replicaVersion=1` +
          `&watermark=00000000000000000000` +
          `&initial=true`;

        const attackerMessages: unknown[] = [];
        const {promise: attackerOpened, resolve: onAttackerOpen} =
          resolver<void>();

        const attackerWs = new WebSocket(attackerUrl);
        attackerWs.on('open', () => onAttackerOpen());
        attackerWs.on('message', data => {
          try {
            attackerMessages.push(JSON.parse(data.toString()));
          } catch {
            attackerMessages.push(data.toString());
          }
        });

        const attackerTimeout = new Promise<'timeout'>(r =>
          setTimeout(() => r('timeout'), 5000),
        );
        const attackerResult = await Promise.race([
          attackerOpened.then(() => 'opened' as const),
          attackerTimeout,
        ]);

        if (attackerResult === 'opened') {
          // Wait for any changes to propagate
          await new Promise(resolve => setTimeout(resolve, 3000));

          if (attackerMessages.length > 0) {
            console.log(
              '[CRITICAL FINDING] Attacker can subscribe to change stream:',
            );
            console.log('  Messages received:', attackerMessages.length);
            // Check if any messages contain tenant-a data
            const hasLeakedData = attackerMessages.some(msg => {
              const str = JSON.stringify(msg);
              return str.includes('tenant-a') || str.includes('user-1');
            });
            if (hasLeakedData) {
              console.log('  [CRITICAL] Cross-tenant data leakage detected!');
            }
          }
        }

        legitimateConn.ws.close();
        attackerWs.close();
      } finally {
        await server.cleanup();
      }
    });

    test('replication with spoofed subscriber ID', async ({testDBs}) => {
      const server = await startPentestServer(testDBs, {
        adminPassword: 'test-password',
        nodeEnv: 'production',
        schemaMode: 'mutation-test',
        auth: {secret: TEST_SECRET},
      });

      try {
        // Try to impersonate a specific subscriber ID
        const spoofedIds = [
          'admin',
          'system',
          'replicator',
          'internal',
          '../admin',
          'id=admin&extra=true',
        ];

        for (const spoofedId of spoofedIds) {
          const url =
            `ws://localhost:${server.replicationPort}/replication/v${REPLICATION_PROTOCOL_VERSION}/changes` +
            `?id=${encodeURIComponent(spoofedId)}` +
            `&mode=serving` +
            `&replicaVersion=1` +
            `&watermark=00000000000000000000` +
            `&initial=true`;

          const {promise: result, resolve: onResult} = resolver<string>();
          const ws = new WebSocket(url);
          ws.on('open', () => onResult('opened'));
          ws.on('close', (code, reason) =>
            onResult(`closed:${code}:${reason.toString()}`),
          );
          ws.on('error', e => onResult(`error:${e.message}`));

          const timeout = new Promise<string>(r =>
            setTimeout(() => r('timeout'), 3000),
          );
          const outcome = await Promise.race([result, timeout]);

          if (outcome === 'opened') {
            console.log(
              `[FINDING] Spoofed subscriber ID accepted: "${spoofedId}"`,
            );
          } else {
            console.log(
              `[INFO] Spoofed subscriber ID rejected: "${spoofedId}" -> ${outcome.slice(0, 50)}`,
            );
          }

          ws.close();
        }
      } finally {
        await server.cleanup();
      }
    });
  });

  // ===========================================================================
  // 3. Snapshot Exfiltration Tests
  // ===========================================================================
  describe('snapshot exfiltration', () => {
    test('snapshot endpoint requires valid taskID', async ({testDBs}) => {
      const server = await startPentestServer(testDBs, {
        adminPassword: 'test-password',
        nodeEnv: 'production',
        schemaMode: 'mutation-test',
        auth: {secret: TEST_SECRET},
      });

      try {
        // Try various taskID attacks
        const taskIdAttacks = [
          '', // Empty
          '../../../etc/passwd', // Path traversal
          'admin', // Reserved name
          'a'.repeat(10000), // Very long
          '\x00null\x00', // Null bytes
          'task;DROP TABLE users;--', // SQL injection
          '${env.SECRET}', // Template injection
        ];

        for (const taskId of taskIdAttacks) {
          const url =
            `ws://localhost:${server.replicationPort}/replication/v${REPLICATION_PROTOCOL_VERSION}/snapshot` +
            `?taskID=${encodeURIComponent(taskId)}`;

          const {promise: result, resolve: onResult} = resolver<string>();
          try {
            const ws = new WebSocket(url);
            ws.on('open', () => onResult('opened'));
            ws.on('close', (code, reason) =>
              onResult(`closed:${code}:${reason.toString()}`),
            );
            ws.on('error', e => onResult(`error:${e.message}`));

            const timeout = new Promise<string>(r =>
              setTimeout(() => r('timeout'), 3000),
            );
            const outcome = await Promise.race([result, timeout]);

            console.log(
              `[INFO] TaskID attack "${taskId.slice(0, 20)}..." -> ${outcome.slice(0, 50)}`,
            );
          } catch (e) {
            console.log(
              `[INFO] TaskID attack "${taskId.slice(0, 20)}..." caused error: ${String(e).slice(0, 50)}`,
            );
          }
        }
      } finally {
        await server.cleanup();
      }
    });

    test('snapshot without taskID parameter', async ({testDBs}) => {
      const server = await startPentestServer(testDBs, {
        adminPassword: 'test-password',
        nodeEnv: 'production',
        schemaMode: 'mutation-test',
        auth: {secret: TEST_SECRET},
      });

      try {
        // Connect without taskID
        const url = `ws://localhost:${server.replicationPort}/replication/v${REPLICATION_PROTOCOL_VERSION}/snapshot`;

        const {promise: closed, resolve: onClose} = resolver<{
          code: number;
          reason: string;
        }>();
        const {promise: opened, resolve: onOpen} = resolver<void>();

        const ws = new WebSocket(url);
        ws.on('open', () => onOpen());
        ws.on('close', (code, reason) =>
          onClose({code, reason: reason.toString()}),
        );

        const timeout = new Promise<'timeout'>(r =>
          setTimeout(() => r('timeout'), 5000),
        );
        const result = await Promise.race([
          opened.then(() => 'opened' as const),
          closed.then(c => ({closed: c})),
          timeout,
        ]);

        if (result === 'opened') {
          console.log(
            '[FINDING] Snapshot endpoint accepts connection without taskID',
          );
        } else if (result === 'timeout') {
          console.log('[INFO] Snapshot without taskID timed out');
        } else {
          console.log(
            '[INFO] Snapshot without taskID rejected:',
            result.closed.code,
            result.closed.reason,
          );
        }

        ws.close();
      } finally {
        await server.cleanup();
      }
    });

    test('multiple concurrent snapshot requests (DoS potential)', async ({
      testDBs,
    }) => {
      const server = await startPentestServer(testDBs, {
        adminPassword: 'test-password',
        nodeEnv: 'production',
        schemaMode: 'mutation-test',
        auth: {secret: TEST_SECRET},
      });

      try {
        // Open many concurrent connections
        const connectionCount = 50;
        const connections: WebSocket[] = [];
        const results: string[] = [];

        const startTime = Date.now();

        for (let i = 0; i < connectionCount; i++) {
          const url =
            `ws://localhost:${server.replicationPort}/replication/v${REPLICATION_PROTOCOL_VERSION}/snapshot` +
            `?taskID=dos-test-${i}`;

          const ws = new WebSocket(url);
          connections.push(ws);

          ws.on('open', () => results.push(`${i}:open`));
          ws.on('close', (code, _reason) => results.push(`${i}:close:${code}`));
          ws.on('error', _e => results.push(`${i}:error`));
        }

        // Wait for all connections to settle
        await new Promise(resolve => setTimeout(resolve, 5000));

        const duration = Date.now() - startTime;
        const openedCount = results.filter(r => r.includes(':open')).length;
        const closedCount = results.filter(r => r.includes(':close')).length;
        const errorCount = results.filter(r => r.includes(':error')).length;

        console.log(`[INFO] DoS test results (${connectionCount} connections):`);
        console.log(`  Duration: ${duration}ms`);
        console.log(`  Opened: ${openedCount}`);
        console.log(`  Closed: ${closedCount}`);
        console.log(`  Errors: ${errorCount}`);

        if (openedCount === connectionCount) {
          console.log(
            '[FINDING] All connections accepted - no rate limiting on snapshot endpoint',
          );
        }

        // Cleanup
        for (const ws of connections) {
          ws.close();
        }
      } finally {
        await server.cleanup();
      }
    });
  });

  // ===========================================================================
  // 4. Mode Manipulation Tests
  // ===========================================================================
  describe('replication mode manipulation', () => {
    test('backup mode access without authorization', async ({testDBs}) => {
      const server = await startPentestServer(testDBs, {
        adminPassword: 'test-password',
        nodeEnv: 'production',
        schemaMode: 'mutation-test',
        auth: {secret: TEST_SECRET},
      });

      try {
        // Try to access backup mode
        const url =
          `ws://localhost:${server.replicationPort}/replication/v${REPLICATION_PROTOCOL_VERSION}/changes` +
          `?id=backup-attacker` +
          `&mode=backup` + // Privileged mode
          `&replicaVersion=1` +
          `&watermark=00000000000000000000` +
          `&initial=true`;

        const {promise: closed, resolve: onClose} = resolver<{
          code: number;
          reason: string;
        }>();
        const {promise: opened, resolve: onOpen} = resolver<void>();
        const messages: unknown[] = [];

        const ws = new WebSocket(url);
        ws.on('open', () => onOpen());
        ws.on('close', (code, reason) =>
          onClose({code, reason: reason.toString()}),
        );
        ws.on('message', data => {
          try {
            messages.push(JSON.parse(data.toString()));
          } catch {
            messages.push(data.toString());
          }
        });

        const timeout = new Promise<'timeout'>(r =>
          setTimeout(() => r('timeout'), 5000),
        );
        const result = await Promise.race([
          opened.then(() => 'opened' as const),
          closed.then(c => ({closed: c})),
          timeout,
        ]);

        if (result === 'opened') {
          await new Promise(resolve => setTimeout(resolve, 2000));
          console.log('[FINDING] Backup mode accepted without authorization');
          console.log('  Messages received:', messages.length);
        } else if (result === 'timeout') {
          console.log('[INFO] Backup mode connection timed out');
        } else {
          console.log(
            '[INFO] Backup mode rejected:',
            result.closed.code,
            result.closed.reason,
          );
        }

        ws.close();
      } finally {
        await server.cleanup();
      }
    });

    test('invalid mode values are rejected', async ({testDBs}) => {
      const server = await startPentestServer(testDBs, {
        adminPassword: 'test-password',
        nodeEnv: 'production',
        schemaMode: 'mutation-test',
        auth: {secret: TEST_SECRET},
      });

      try {
        const invalidModes = [
          'admin',
          'internal',
          'debug',
          '../serving',
          'serving%00backup',
          'SERVING', // Case sensitivity
        ];

        for (const mode of invalidModes) {
          const url =
            `ws://localhost:${server.replicationPort}/replication/v${REPLICATION_PROTOCOL_VERSION}/changes` +
            `?id=mode-test` +
            `&mode=${encodeURIComponent(mode)}` +
            `&replicaVersion=1` +
            `&watermark=00000000000000000000` +
            `&initial=true`;

          const {promise: result, resolve: onResult} = resolver<string>();
          const ws = new WebSocket(url);
          ws.on('open', () => onResult('opened'));
          ws.on('close', (code, reason) =>
            onResult(`closed:${code}:${reason.toString()}`),
          );
          ws.on('error', e => onResult(`error:${e.message}`));

          const timeout = new Promise<string>(r =>
            setTimeout(() => r('timeout'), 3000),
          );
          const outcome = await Promise.race([result, timeout]);

          if (outcome === 'opened') {
            console.log(`[FINDING] Invalid mode "${mode}" accepted`);
          } else {
            console.log(
              `[INFO] Invalid mode "${mode}" rejected: ${outcome.slice(0, 50)}`,
            );
          }

          ws.close();
        }
      } finally {
        await server.cleanup();
      }
    });
  });
});
