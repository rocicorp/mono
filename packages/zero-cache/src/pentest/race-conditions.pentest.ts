/**
 * Race Conditions Pentest Suite
 *
 * Tests for concurrency vulnerabilities in Zero's mutation and connection handling:
 *
 * 1. Two-Phase Auth Race Conditions
 *    - canPreMutation and canPostMutation run via Promise.all
 *    - Concurrent mutations can race between phases
 *    - TOCTOU vulnerabilities in authorization checks
 *
 * 2. LMID (Last Mutation ID) Race Conditions
 *    - Two mutations with sequential IDs arriving simultaneously
 *    - Mutation ID increment races
 *
 * 3. Connection State Races
 *    - Rapid reconnection with same clientID
 *    - Concurrent connections with same clientID
 *    - Connection cleanup during active mutation
 *
 * 4. Permission Reload Races
 *    - Permissions changing mid-transaction
 *
 * Reference: write-authorizer.ts:150-217, mutagen.ts:336-340
 */

/* eslint-disable no-console */
// Console.log is used intentionally in pentest code to flag security findings

import {describe, expect} from 'vitest';
import {test} from '../test/db.ts';
import {startPentestServer} from './helpers/pentest-server.ts';
import {connectSync, waitForConnection} from './helpers/ws-client.ts';
import {
  createInsertMutation,
  createUpdateMutation,
  createDeleteMutation,
  createCRUDPushMessage,
  createMutationAuthToken,
} from './helpers/mutation-helpers.ts';
import {
  createConcurrentConnections,
  sendConcurrentMutations,
  createSameRowMutations,
  submitMutationBurst,
  createDuplicateClientConnections,
  createTimedMessageCollector,
} from './helpers/race-condition-helpers.ts';

const TEST_SECRET = 'pentest-race-condition-secret-32chars!';
const TEST_CLIENT_GROUP = 'race-test-cg';

describe('race conditions', {timeout: 180000}, () => {
  // ===========================================================================
  // 1. Two-Phase Auth Race Conditions
  // ===========================================================================
  describe('two-phase auth races', () => {
    test('concurrent mutations to same row from different clients', async ({
      testDBs,
    }) => {
      const server = await startPentestServer(testDBs, {
        adminPassword: 'test-password',
        nodeEnv: 'production',
        schemaMode: 'mutation-test',
        auth: {secret: TEST_SECRET},
      });

      try {
        const token = await createMutationAuthToken(TEST_SECRET, {
          sub: 'user-1',
          role: 'admin',
        });

        // First, create the row to update
        const setupConn = connectSync({
          port: server.port,
          clientGroupID: TEST_CLIENT_GROUP,
          clientID: 'setup-client',
          userID: 'user-1',
          authToken: token,
        });

        const setupOutcome = await waitForConnection(setupConn, 5000);
        expect(setupOutcome.type).toBe('opened');

        // Insert initial row
        const insertMutation = createInsertMutation(
          'setup-client',
          1,
          'public_table',
          {id: 'race-target', value: 'initial'},
        );
        setupConn.ws.send(
          JSON.stringify(
            createCRUDPushMessage(TEST_CLIENT_GROUP, [insertMutation]),
          ),
        );
        await new Promise(resolve => setTimeout(resolve, 1000));

        // Create multiple concurrent connections
        const concurrentCount = 5;
        const concurrent = await createConcurrentConnections(
          concurrentCount,
          server.port,
          TEST_CLIENT_GROUP,
          token,
        );

        // Create mutations targeting the same row
        const mutations = createSameRowMutations(
          'race-target',
          'public_table',
          concurrentCount,
        );

        // Send all mutations simultaneously
        const results = await sendConcurrentMutations(
          concurrent.connections,
          TEST_CLIENT_GROUP,
          mutations,
        );

        console.log('[INFO] Concurrent same-row mutation results:');
        console.log(
          '  Sent:',
          results.filter(r => r.sent).length,
          'of',
          results.length,
        );

        // Wait for mutations to process
        await new Promise(resolve => setTimeout(resolve, 3000));

        // Check how many succeeded vs failed
        let openCount = 0;
        let closedCount = 0;
        for (const conn of concurrent.connections) {
          if (conn.ws.readyState === conn.ws.OPEN) openCount++;
          else closedCount++;
        }

        console.log(
          `  Connections still open: ${openCount}, closed: ${closedCount}`,
        );

        // If all stayed open, check for serialization errors in logs
        if (openCount === concurrentCount) {
          console.log(
            '  [INFO] All connections stayed open - check for serialization errors in server logs',
          );
        }

        setupConn.ws.close();
        concurrent.closeAll();
      } finally {
        await server.cleanup();
      }
    });

    test('pre-check passes but row changes before post-check (TOCTOU)', async ({
      testDBs,
    }) => {
      const server = await startPentestServer(testDBs, {
        adminPassword: 'test-password',
        nodeEnv: 'production',
        schemaMode: 'mutation-test',
        auth: {secret: TEST_SECRET},
      });

      try {
        // User 1 owns a row
        const user1Token = await createMutationAuthToken(TEST_SECRET, {
          sub: 'user-1',
        });

        // User 2 will try to exploit TOCTOU
        const user2Token = await createMutationAuthToken(TEST_SECRET, {
          sub: 'user-2',
        });

        // Setup: user-1 creates a row they own
        const user1Conn = connectSync({
          port: server.port,
          clientGroupID: TEST_CLIENT_GROUP,
          clientID: 'user1-client',
          userID: 'user-1',
          authToken: user1Token,
        });

        const user1Outcome = await waitForConnection(user1Conn, 5000);
        expect(user1Outcome.type).toBe('opened');

        // Insert row owned by user-1
        const insertOwned = createInsertMutation(
          'user1-client',
          1,
          'owner_only',
          {id: 'toctou-target', owner_id: 'user-1', value: 'original'},
        );
        user1Conn.ws.send(
          JSON.stringify(createCRUDPushMessage(TEST_CLIENT_GROUP, [insertOwned])),
        );
        await new Promise(resolve => setTimeout(resolve, 1000));

        // User 2 connects
        const user2Conn = connectSync({
          port: server.port,
          clientGroupID: TEST_CLIENT_GROUP,
          clientID: 'user2-client',
          userID: 'user-2',
          authToken: user2Token,
        });

        const user2Outcome = await waitForConnection(user2Conn, 5000);
        expect(user2Outcome.type).toBe('opened');

        // TOCTOU attempt: user-1 changes ownership while user-2's mutation is in-flight
        // First, user-2 starts an update (that should fail owner check)
        const toctouUpdate = createUpdateMutation(
          'user2-client',
          1,
          'owner_only',
          {id: 'toctou-target', owner_id: 'user-2', value: 'stolen-by-user2'},
        );

        // User-1 transfers ownership at the exact same time
        const transferOwnership = createUpdateMutation(
          'user1-client',
          2,
          'owner_only',
          {id: 'toctou-target', owner_id: 'user-2', value: 'transferred'},
        );

        // Send both as close together as possible
        const startTime = Date.now();
        user2Conn.ws.send(
          JSON.stringify(createCRUDPushMessage(TEST_CLIENT_GROUP, [toctouUpdate])),
        );
        user1Conn.ws.send(
          JSON.stringify(
            createCRUDPushMessage(TEST_CLIENT_GROUP, [transferOwnership]),
          ),
        );
        const endTime = Date.now();

        console.log(`[INFO] TOCTOU attack sent in ${endTime - startTime}ms`);

        // Wait and check results
        await new Promise(resolve => setTimeout(resolve, 3000));

        // If user-2's mutation went through despite not owning at pre-check time,
        // that's a TOCTOU vulnerability
        console.log('[INFO] TOCTOU test completed - check server logs for:');
        console.log('  - Whether user-2 mutation was blocked');
        console.log('  - Serialization conflicts');
        console.log('  - Authorization failures');

        user1Conn.ws.close();
        user2Conn.ws.close();
      } finally {
        await server.cleanup();
      }
    });

    test('rapid mutations during permission evaluation', async ({testDBs}) => {
      const server = await startPentestServer(testDBs, {
        adminPassword: 'test-password',
        nodeEnv: 'production',
        schemaMode: 'mutation-test',
        auth: {secret: TEST_SECRET},
      });

      try {
        const token = await createMutationAuthToken(TEST_SECRET, {
          sub: 'rapid-user',
          role: 'admin',
        });

        const conn = connectSync({
          port: server.port,
          clientGroupID: TEST_CLIENT_GROUP,
          clientID: 'rapid-client',
          userID: 'rapid-user',
          authToken: token,
        });

        const outcome = await waitForConnection(conn, 5000);
        expect(outcome.type).toBe('opened');

        // Send 100 mutations in rapid succession
        const mutations = Array.from({length: 100}, (_, i) =>
          createInsertMutation('rapid-client', i + 1, 'public_table', {
            id: `rapid-${i}`,
            value: `value-${i}`,
          }),
        );

        const startTime = Date.now();
        await submitMutationBurst(conn.ws, TEST_CLIENT_GROUP, mutations, 0);
        const endTime = Date.now();

        console.log(`[INFO] Sent 100 mutations in ${endTime - startTime}ms`);

        // Wait for processing
        await new Promise(resolve => setTimeout(resolve, 5000));

        const wsState = conn.ws.readyState === conn.ws.OPEN ? 'open' : 'closed';
        console.log(`[INFO] Connection state after burst: ${wsState}`);

        conn.ws.close();
      } finally {
        await server.cleanup();
      }
    });
  });

  // ===========================================================================
  // 2. LMID Race Conditions
  // ===========================================================================
  describe('LMID race conditions', () => {
    test('two mutations with sequential IDs sent simultaneously', async ({
      testDBs,
    }) => {
      const server = await startPentestServer(testDBs, {
        adminPassword: 'test-password',
        nodeEnv: 'production',
        schemaMode: 'mutation-test',
        auth: {secret: TEST_SECRET},
      });

      try {
        const token = await createMutationAuthToken(TEST_SECRET, {
          sub: 'lmid-user',
        });

        const conn = connectSync({
          port: server.port,
          clientGroupID: TEST_CLIENT_GROUP,
          clientID: 'lmid-race-client',
          userID: 'lmid-user',
          authToken: token,
        });

        const outcome = await waitForConnection(conn, 5000);
        expect(outcome.type).toBe('opened');

        // Collect messages to track responses
        const collector = createTimedMessageCollector(conn.ws);

        // Send mutations 1 and 2 simultaneously
        const mutation1 = createInsertMutation(
          'lmid-race-client',
          1,
          'public_table',
          {id: 'lmid-1', value: 'first'},
        );
        const mutation2 = createInsertMutation(
          'lmid-race-client',
          2,
          'public_table',
          {id: 'lmid-2', value: 'second'},
        );

        // Send both at the exact same time
        conn.ws.send(
          JSON.stringify(createCRUDPushMessage(TEST_CLIENT_GROUP, [mutation1])),
        );
        conn.ws.send(
          JSON.stringify(createCRUDPushMessage(TEST_CLIENT_GROUP, [mutation2])),
        );

        // Wait for processing
        await new Promise(resolve => setTimeout(resolve, 3000));

        collector.stop();

        console.log('[INFO] LMID race test results:');
        console.log('  Messages received:', collector.messages.length);
        console.log(
          '  Connection state:',
          conn.ws.readyState === conn.ws.OPEN ? 'open' : 'closed',
        );

        // Check for any error messages about out-of-order mutations
        for (const msg of collector.messages) {
          const msgStr = JSON.stringify(msg.message);
          if (msgStr.includes('error') || msgStr.includes('InvalidPush')) {
            console.log('  Error message:', msgStr.slice(0, 200));
          }
        }

        conn.ws.close();
      } finally {
        await server.cleanup();
      }
    });

    test('same LMID from multiple connections', async ({testDBs}) => {
      const server = await startPentestServer(testDBs, {
        adminPassword: 'test-password',
        nodeEnv: 'production',
        schemaMode: 'mutation-test',
        auth: {secret: TEST_SECRET},
      });

      try {
        const token = await createMutationAuthToken(TEST_SECRET, {
          sub: 'multi-lmid-user',
        });

        // Create multiple connections
        const connCount = 3;
        const connections: Array<{conn: ReturnType<typeof connectSync>}> = [];

        for (let i = 0; i < connCount; i++) {
          const conn = connectSync({
            port: server.port,
            clientGroupID: TEST_CLIENT_GROUP,
            clientID: `multi-lmid-client-${i}`,
            userID: 'multi-lmid-user',
            authToken: token,
          });
          const outcome = await waitForConnection(conn, 5000);
          expect(outcome.type).toBe('opened');
          connections.push({conn});
        }

        // All clients send LMID=1 simultaneously
        const sendPromises = connections.map(({conn}, i) => {
          const mutation = createInsertMutation(
            `multi-lmid-client-${i}`,
            1,
            'public_table',
            {id: `multi-lmid-${i}`, value: `from-client-${i}`},
          );
          conn.ws.send(
            JSON.stringify(createCRUDPushMessage(TEST_CLIENT_GROUP, [mutation])),
          );
          return Promise.resolve();
        });

        await Promise.all(sendPromises);

        // Wait for processing
        await new Promise(resolve => setTimeout(resolve, 3000));

        let openCount = 0;
        let closedCount = 0;
        for (const {conn} of connections) {
          if (conn.ws.readyState === conn.ws.OPEN) openCount++;
          else closedCount++;
        }

        console.log('[INFO] Multi-client LMID=1 test:');
        console.log(`  Open: ${openCount}, Closed: ${closedCount}`);

        // Cleanup
        for (const {conn} of connections) {
          conn.ws.close();
        }
      } finally {
        await server.cleanup();
      }
    });

    test('out-of-order LMID delivery', async ({testDBs}) => {
      const server = await startPentestServer(testDBs, {
        adminPassword: 'test-password',
        nodeEnv: 'production',
        schemaMode: 'mutation-test',
        auth: {secret: TEST_SECRET},
      });

      try {
        const token = await createMutationAuthToken(TEST_SECRET, {
          sub: 'ooo-lmid-user',
        });

        const conn = connectSync({
          port: server.port,
          clientGroupID: TEST_CLIENT_GROUP,
          clientID: 'ooo-lmid-client',
          userID: 'ooo-lmid-user',
          authToken: token,
        });

        const outcome = await waitForConnection(conn, 5000);
        expect(outcome.type).toBe('opened');

        const collector = createTimedMessageCollector(conn.ws);

        // Send mutation 2 BEFORE mutation 1 (out of order)
        const mutation2 = createInsertMutation(
          'ooo-lmid-client',
          2,
          'public_table',
          {id: 'ooo-2', value: 'second-sent-first'},
        );
        const mutation1 = createInsertMutation(
          'ooo-lmid-client',
          1,
          'public_table',
          {id: 'ooo-1', value: 'first-sent-second'},
        );

        // Send out of order
        conn.ws.send(
          JSON.stringify(createCRUDPushMessage(TEST_CLIENT_GROUP, [mutation2])),
        );
        await new Promise(resolve => setTimeout(resolve, 100));
        conn.ws.send(
          JSON.stringify(createCRUDPushMessage(TEST_CLIENT_GROUP, [mutation1])),
        );

        // Wait for processing
        await new Promise(resolve => setTimeout(resolve, 3000));

        collector.stop();

        console.log('[INFO] Out-of-order LMID test:');
        console.log('  Messages received:', collector.messages.length);
        console.log(
          '  Connection state:',
          conn.ws.readyState === conn.ws.OPEN ? 'open' : 'closed',
        );

        // Check for InvalidPush errors
        for (const msg of collector.messages) {
          const msgStr = JSON.stringify(msg.message);
          if (msgStr.includes('InvalidPush') || msgStr.includes('unexpected')) {
            console.log('  [EXPECTED] Out-of-order rejected:', msgStr.slice(0, 200));
          }
        }

        conn.ws.close();
      } finally {
        await server.cleanup();
      }
    });
  });

  // ===========================================================================
  // 3. Connection State Races
  // ===========================================================================
  describe('connection state races', () => {
    test('rapid reconnection with same clientID', async ({testDBs}) => {
      const server = await startPentestServer(testDBs, {
        adminPassword: 'test-password',
        nodeEnv: 'production',
        schemaMode: 'mutation-test',
        auth: {secret: TEST_SECRET},
      });

      try {
        const token = await createMutationAuthToken(TEST_SECRET, {
          sub: 'reconnect-user',
        });

        const reconnectCount = 10;
        const results: string[] = [];

        for (let i = 0; i < reconnectCount; i++) {
          const conn = connectSync({
            port: server.port,
            clientGroupID: TEST_CLIENT_GROUP,
            clientID: 'rapid-reconnect-client', // Same clientID
            wsID: `reconnect-ws-${i}`,
            userID: 'reconnect-user',
            authToken: token,
          });

          const outcome = await waitForConnection(conn, 2000);
          results.push(outcome.type);

          // Immediately close and reconnect
          conn.ws.close();
          // Small delay to not overwhelm
          await new Promise(resolve => setTimeout(resolve, 100));
        }

        console.log('[INFO] Rapid reconnection results:');
        const openedCount = results.filter(r => r === 'opened').length;
        const closedCount = results.filter(r => r === 'closed').length;
        const timeoutCount = results.filter(r => r === 'timeout').length;
        console.log(`  Opened: ${openedCount}`);
        console.log(`  Closed: ${closedCount}`);
        console.log(`  Timeout: ${timeoutCount}`);
      } finally {
        await server.cleanup();
      }
    });

    test('concurrent connections with same clientID (connection replacement)', async ({
      testDBs,
    }) => {
      const server = await startPentestServer(testDBs, {
        adminPassword: 'test-password',
        nodeEnv: 'production',
        schemaMode: 'mutation-test',
        auth: {secret: TEST_SECRET},
      });

      try {
        const token = await createMutationAuthToken(TEST_SECRET, {
          sub: 'dup-client-user',
        });

        const result = await createDuplicateClientConnections(
          5,
          server.port,
          TEST_CLIENT_GROUP,
          'duplicate-client-id', // Same clientID for all
          token,
        );

        console.log('[INFO] Duplicate clientID connection test:');
        console.log(`  Total connections: 5`);
        console.log(`  Opened: ${result.openedCount}`);
        console.log(`  Closed: ${result.closedCount}`);

        // Only one should remain open (others should be replaced)
        if (result.openedCount > 1) {
          console.log(
            '[FINDING] Multiple connections with same clientID stayed open!',
          );
        } else if (result.openedCount === 1) {
          console.log('  [EXPECTED] Only one connection remained open');
        } else {
          console.log('  [INFO] All connections closed');
        }

        result.closeAll();
      } finally {
        await server.cleanup();
      }
    });

    test('mutation sent during connection replacement', async ({testDBs}) => {
      const server = await startPentestServer(testDBs, {
        adminPassword: 'test-password',
        nodeEnv: 'production',
        schemaMode: 'mutation-test',
        auth: {secret: TEST_SECRET},
      });

      try {
        const token = await createMutationAuthToken(TEST_SECRET, {
          sub: 'replace-mutation-user',
        });

        // First connection
        const conn1 = connectSync({
          port: server.port,
          clientGroupID: TEST_CLIENT_GROUP,
          clientID: 'replace-test-client',
          wsID: 'ws-1',
          userID: 'replace-mutation-user',
          authToken: token,
        });

        const outcome1 = await waitForConnection(conn1, 5000);
        expect(outcome1.type).toBe('opened');

        // Send a mutation on conn1
        const mutation1 = createInsertMutation(
          'replace-test-client',
          1,
          'public_table',
          {id: 'replace-test-1', value: 'from-conn1'},
        );
        conn1.ws.send(
          JSON.stringify(createCRUDPushMessage(TEST_CLIENT_GROUP, [mutation1])),
        );

        // Immediately create second connection with same clientID
        const conn2 = connectSync({
          port: server.port,
          clientGroupID: TEST_CLIENT_GROUP,
          clientID: 'replace-test-client', // Same clientID
          wsID: 'ws-2',
          userID: 'replace-mutation-user',
          authToken: token,
        });

        // Send mutation on conn2 immediately
        const mutation2 = createInsertMutation(
          'replace-test-client',
          2,
          'public_table',
          {id: 'replace-test-2', value: 'from-conn2'},
        );

        const outcome2 = await waitForConnection(conn2, 5000);
        if (outcome2.type === 'opened') {
          conn2.ws.send(
            JSON.stringify(createCRUDPushMessage(TEST_CLIENT_GROUP, [mutation2])),
          );
        }

        // Wait for processing
        await new Promise(resolve => setTimeout(resolve, 3000));

        const ws1State = conn1.ws.readyState === conn1.ws.OPEN ? 'open' : 'closed';
        const ws2State = conn2.ws.readyState === conn2.ws.OPEN ? 'open' : 'closed';

        console.log('[INFO] Connection replacement mutation test:');
        console.log(`  Conn1 state: ${ws1State}`);
        console.log(`  Conn2 state: ${ws2State}`);

        conn1.ws.close();
        conn2.ws.close();
      } finally {
        await server.cleanup();
      }
    });
  });

  // ===========================================================================
  // 4. Resource Exhaustion via Races
  // ===========================================================================
  describe('race-based resource exhaustion', () => {
    test('connection flood from concurrent clients', async ({testDBs}) => {
      const server = await startPentestServer(testDBs, {
        adminPassword: 'test-password',
        nodeEnv: 'production',
        schemaMode: 'mutation-test',
        auth: {secret: TEST_SECRET},
      });

      try {
        const token = await createMutationAuthToken(TEST_SECRET, {
          sub: 'flood-user',
        });

        const connectionCount = 50;
        const result = await createConcurrentConnections(
          connectionCount,
          server.port,
          TEST_CLIENT_GROUP,
          token,
        );

        // Count how many actually opened
        let openCount = 0;
        for (const conn of result.connections) {
          if (conn.ws.readyState === conn.ws.OPEN) openCount++;
        }

        console.log('[INFO] Connection flood test:');
        console.log(`  Attempted: ${connectionCount}`);
        console.log(`  Opened: ${openCount}`);

        if (openCount === connectionCount) {
          console.log(
            '  [INFO] All connections accepted - check for connection limits',
          );
        }

        result.closeAll();
      } finally {
        await server.cleanup();
      }
    });

    test('mutation flood creating serialization contention', async ({
      testDBs,
    }) => {
      const server = await startPentestServer(testDBs, {
        adminPassword: 'test-password',
        nodeEnv: 'production',
        schemaMode: 'mutation-test',
        auth: {secret: TEST_SECRET},
      });

      try {
        const token = await createMutationAuthToken(TEST_SECRET, {
          sub: 'contention-user',
          role: 'admin',
        });

        // Create multiple connections
        const connCount = 10;
        const concurrent = await createConcurrentConnections(
          connCount,
          server.port,
          TEST_CLIENT_GROUP,
          token,
        );

        // Each connection sends mutations targeting the same row
        // This should cause serialization conflicts
        const targetRowId = 'contention-target';

        // First, create the row
        const conn0 = concurrent.connections[0];
        if (conn0.ws.readyState === conn0.ws.OPEN) {
          const insertMutation = createInsertMutation(
            'race-client-0',
            1,
            'public_table',
            {id: targetRowId, value: 'initial'},
          );
          conn0.ws.send(
            JSON.stringify(
              createCRUDPushMessage(TEST_CLIENT_GROUP, [insertMutation]),
            ),
          );
        }

        await new Promise(resolve => setTimeout(resolve, 1000));

        // Now all connections update the same row simultaneously
        const startTime = Date.now();
        let sentCount = 0;

        for (let i = 0; i < connCount; i++) {
          const conn = concurrent.connections[i];
          if (conn.ws.readyState === conn.ws.OPEN) {
            const mutation = createUpdateMutation(
              `race-client-${i}`,
              i === 0 ? 2 : 1, // Client 0 already used LMID 1
              'public_table',
              {id: targetRowId, value: `updated-by-${i}`},
            );
            conn.ws.send(
              JSON.stringify(createCRUDPushMessage(TEST_CLIENT_GROUP, [mutation])),
            );
            sentCount++;
          }
        }

        const endTime = Date.now();

        // Wait for processing
        await new Promise(resolve => setTimeout(resolve, 5000));

        let stillOpen = 0;
        let closedCount = 0;
        for (const conn of concurrent.connections) {
          if (conn.ws.readyState === conn.ws.OPEN) stillOpen++;
          else closedCount++;
        }

        console.log('[INFO] Serialization contention test:');
        console.log(`  Mutations sent: ${sentCount} in ${endTime - startTime}ms`);
        console.log(`  Connections still open: ${stillOpen}`);
        console.log(`  Connections closed: ${closedCount}`);

        concurrent.closeAll();
      } finally {
        await server.cleanup();
      }
    });
  });

  // ===========================================================================
  // 5. State Consistency Races
  // ===========================================================================
  describe('state consistency races', () => {
    test('delete and insert same row ID simultaneously', async ({testDBs}) => {
      const server = await startPentestServer(testDBs, {
        adminPassword: 'test-password',
        nodeEnv: 'production',
        schemaMode: 'mutation-test',
        auth: {secret: TEST_SECRET},
      });

      try {
        const token = await createMutationAuthToken(TEST_SECRET, {
          sub: 'ghost-user',
          role: 'admin',
        });

        const conn = connectSync({
          port: server.port,
          clientGroupID: TEST_CLIENT_GROUP,
          clientID: 'ghost-client',
          userID: 'ghost-user',
          authToken: token,
        });

        const outcome = await waitForConnection(conn, 5000);
        expect(outcome.type).toBe('opened');

        // First create the row
        const insert1 = createInsertMutation('ghost-client', 1, 'public_table', {
          id: 'ghost-row',
          value: 'initial',
        });
        conn.ws.send(
          JSON.stringify(createCRUDPushMessage(TEST_CLIENT_GROUP, [insert1])),
        );

        await new Promise(resolve => setTimeout(resolve, 500));

        // Now delete and re-insert with same ID at the same time
        const deleteMutation = createDeleteMutation(
          'ghost-client',
          2,
          'public_table',
          {id: 'ghost-row'},
        );
        const insert2 = createInsertMutation('ghost-client', 3, 'public_table', {
          id: 'ghost-row',
          value: 'reinserted',
        });

        // Send both simultaneously
        conn.ws.send(
          JSON.stringify(createCRUDPushMessage(TEST_CLIENT_GROUP, [deleteMutation])),
        );
        conn.ws.send(
          JSON.stringify(createCRUDPushMessage(TEST_CLIENT_GROUP, [insert2])),
        );

        await new Promise(resolve => setTimeout(resolve, 2000));

        console.log('[INFO] Delete + Insert same ID test completed');
        console.log(
          '  Connection state:',
          conn.ws.readyState === conn.ws.OPEN ? 'open' : 'closed',
        );

        conn.ws.close();
      } finally {
        await server.cleanup();
      }
    });

    test('update non-existent row (phantom update)', async ({testDBs}) => {
      const server = await startPentestServer(testDBs, {
        adminPassword: 'test-password',
        nodeEnv: 'production',
        schemaMode: 'mutation-test',
        auth: {secret: TEST_SECRET},
      });

      try {
        const token = await createMutationAuthToken(TEST_SECRET, {
          sub: 'phantom-user',
        });

        const conn = connectSync({
          port: server.port,
          clientGroupID: TEST_CLIENT_GROUP,
          clientID: 'phantom-client',
          userID: 'phantom-user',
          authToken: token,
        });

        const outcome = await waitForConnection(conn, 5000);
        expect(outcome.type).toBe('opened');

        // Try to update a row that doesn't exist
        const phantomUpdate = createUpdateMutation(
          'phantom-client',
          1,
          'public_table',
          {id: 'does-not-exist', value: 'phantom-value'},
        );

        conn.ws.send(
          JSON.stringify(
            createCRUDPushMessage(TEST_CLIENT_GROUP, [phantomUpdate]),
          ),
        );

        await new Promise(resolve => setTimeout(resolve, 2000));

        console.log('[INFO] Phantom update test completed');
        console.log(
          '  Connection state:',
          conn.ws.readyState === conn.ws.OPEN ? 'open' : 'closed',
        );

        conn.ws.close();
      } finally {
        await server.cleanup();
      }
    });
  });
});
