/**
 * State Machine Bugs - Pentest Suite
 *
 * Tests for race conditions, state confusion, and connection lifecycle
 * vulnerabilities in zero-cache. Focuses on:
 * - Connection replacement race conditions
 * - wsID confusion and message routing
 * - Rapid reconnect cycles (DoS potential)
 * - Message ordering violations
 * - Concurrent operations
 */

/* eslint-disable no-console */
// Console.log is used intentionally in pentest code to flag security findings
// oxlint-disable eslint-plugin-jest(no-conditional-expect)
// oxlint-disable eslint-plugin-jest(valid-describe-callback)

import {describe, expect} from 'vitest';
import {test} from '../test/db.ts';
import {startPentestServer} from './helpers/pentest-server.ts';
import {
  closeAllConnections,
  createConnection,
  createInitConnectionMessage,
  createPingMessage,
  createPushMessage,
  createRacingConnections,
  measurePingLatency,
  runReconnectCycles,
  sendRapidMessages,
  waitForAllClosed,
  waitForConnectionStates,
  type ManagedConnection,
} from './helpers/state-machine-helpers.ts';

describe('state machine bugs', {timeout: 120000}, () => {
  describe('connection replacement races', () => {
    test('multiple simultaneous connections with same clientID', async ({
      testDBs,
    }) => {
      const server = await startPentestServer(testDBs, {
        adminPassword: 'test-password',
        nodeEnv: 'production',
      });

      try {
        // Create 5 connections simultaneously with same clientID
        const connections = createRacingConnections(
          server.port,
          'test-cg',
          'race-client',
          5,
        );

        // Wait for connections to settle
        await new Promise(r => setTimeout(r, 1000));

        const states = await waitForConnectionStates(connections, 1, 5000);

        // Only ONE connection should remain open
        // Others should be closed with "replaced by" reason
        if (states.open > 1) {
          console.log(
            `[FINDING] ${states.open} connections remain open for same clientID (expected 1)`,
          );
        }

        // Verify at least some connections were replaced
        expect(states.open + states.closed).toBe(5);

        // The surviving connection should be responsive
        const openConns = connections.filter(c => c.isOpen());
        if (openConns.length > 0) {
          const latency = await measurePingLatency(openConns[0]);
          expect(latency).toBeDefined();
          expect(latency).toBeLessThan(1000);
        }

        closeAllConnections(connections);
      } finally {
        await server.cleanup();
      }
    });

    test('rapid connection replacement does not cause message loss', async ({
      testDBs,
    }) => {
      const server = await startPentestServer(testDBs, {
        adminPassword: 'test-password',
        nodeEnv: 'production',
      });

      try {
        const clientID = 'replace-test-client';
        const allConnections: ManagedConnection[] = [];

        // Create connections rapidly, each replacing the previous
        for (let i = 0; i < 10; i++) {
          const conn = createConnection({
            port: server.port,
            clientGroupID: 'test-cg',
            clientID,
            wsID: `replace-${i}`,
          });
          allConnections.push(conn);

          // Small delay to ensure some ordering
          await new Promise(r => setTimeout(r, 50));
        }

        // Wait for dust to settle
        await new Promise(r => setTimeout(r, 500));

        // Find the surviving connection (should be the last one)
        const openConns = allConnections.filter(c => c.isOpen());

        // Should have exactly one open connection
        if (openConns.length !== 1) {
          console.log(
            `[FINDING] Expected 1 open connection, got ${openConns.length}`,
          );
        }

        // The survivor should respond to pings
        if (openConns.length > 0) {
          const latency = await measurePingLatency(openConns[0]);
          expect(latency).toBeDefined();
        }

        closeAllConnections(allConnections);
      } finally {
        await server.cleanup();
      }
    });

    test('connection replacement during message processing', async ({
      testDBs,
    }) => {
      const server = await startPentestServer(testDBs, {
        adminPassword: 'test-password',
        nodeEnv: 'production',
      });

      try {
        // Create first connection
        const conn1 = createConnection({
          port: server.port,
          clientGroupID: 'test-cg',
          clientID: 'msg-race-client',
          wsID: 'ws-1',
        });

        await conn1.opened;

        // Send initConnection message
        conn1.send(createInitConnectionMessage());

        // Before response arrives, create replacement connection
        const conn2 = createConnection({
          port: server.port,
          clientGroupID: 'test-cg',
          clientID: 'msg-race-client',
          wsID: 'ws-2',
        });

        // Wait for conn2 to open (conn1 should close)
        const result = await Promise.race([
          conn2.opened.then(() => 'conn2-opened' as const),
          conn1.closed.then(() => 'conn1-closed' as const),
          new Promise<'timeout'>(r => setTimeout(() => r('timeout'), 5000)),
        ]);

        // conn1 should be closed (replaced)
        expect(result).not.toBe('timeout');

        // Wait a bit for state to settle
        await new Promise(r => setTimeout(r, 500));

        // conn2 should be open and responsive
        if (conn2.isOpen()) {
          conn2.send(createPingMessage());
          const pong = await conn2.waitForMessage('pong', 2000);
          expect(pong).toBeDefined();
        } else {
          console.log('[FINDING] Replacement connection is not open');
        }

        closeAllConnections([conn1, conn2]);
      } finally {
        await server.cleanup();
      }
    });
  });

  describe('wsID confusion attacks', () => {
    test('messages from old wsID are silently dropped', async ({testDBs}) => {
      const server = await startPentestServer(testDBs, {
        adminPassword: 'test-password',
        nodeEnv: 'production',
      });

      try {
        // Create first connection
        const conn1 = createConnection({
          port: server.port,
          clientGroupID: 'test-cg',
          clientID: 'wsid-test',
          wsID: 'old-ws',
        });

        await conn1.opened;

        // Create replacement connection (different wsID, same clientID)
        const conn2 = createConnection({
          port: server.port,
          clientGroupID: 'test-cg',
          clientID: 'wsid-test',
          wsID: 'new-ws',
        });

        // Wait for conn2 to open
        await conn2.opened;

        // Wait for conn1 to be closed
        await Promise.race([
          conn1.closed,
          new Promise(r => setTimeout(r, 2000)),
        ]);

        // If conn1 is still open (race condition), try to send from it
        if (conn1.isOpen()) {
          // This message should be silently dropped (wsID mismatch)
          conn1.send(createPingMessage());

          // Wait to see if we get a response (we shouldn't)
          const pong = await conn1.waitForMessage('pong', 1000);
          if (pong) {
            console.log(
              '[FINDING] Old wsID received response - messages not properly filtered',
            );
          }
        }

        // conn2 should still work
        if (conn2.isOpen()) {
          conn2.send(createPingMessage());
          const pong = await conn2.waitForMessage('pong', 2000);
          expect(pong).toBeDefined();
        }

        closeAllConnections([conn1, conn2]);
      } finally {
        await server.cleanup();
      }
    });

    test('wsID spoofing between different clients', async ({testDBs}) => {
      const server = await startPentestServer(testDBs, {
        adminPassword: 'test-password',
        nodeEnv: 'production',
      });

      try {
        // Client A connects
        const clientA = createConnection({
          port: server.port,
          clientGroupID: 'test-cg',
          clientID: 'client-a',
          wsID: 'shared-wsid', // Intentionally using same wsID
        });

        await clientA.opened;

        // Client B connects with same wsID (but different clientID)
        const clientB = createConnection({
          port: server.port,
          clientGroupID: 'test-cg',
          clientID: 'client-b',
          wsID: 'shared-wsid', // Same wsID as client A
        });

        await clientB.opened;

        // Both should be open (different clientIDs)
        expect(clientA.isOpen()).toBe(true);
        expect(clientB.isOpen()).toBe(true);

        // Both should respond to pings independently
        const [latencyA, latencyB] = await Promise.all([
          measurePingLatency(clientA),
          measurePingLatency(clientB),
        ]);

        expect(latencyA).toBeDefined();
        expect(latencyB).toBeDefined();

        closeAllConnections([clientA, clientB]);
      } finally {
        await server.cleanup();
      }
    });
  });

  describe('rapid reconnect cycles', () => {
    test('server handles rapid reconnects without DoS', async ({testDBs}) => {
      const server = await startPentestServer(testDBs, {
        adminPassword: 'test-password',
        nodeEnv: 'production',
      });

      try {
        const result = await runReconnectCycles(
          server.port,
          'test-cg',
          'reconnect-stress',
          20, // 20 rapid reconnects
          10, // 10ms delay between
        );

        // Should have high success rate
        const successRate =
          result.successfulConnects /
          (result.successfulConnects + result.failedConnects);

        if (successRate < 0.9) {
          console.log(
            `[FINDING] Low reconnect success rate: ${(successRate * 100).toFixed(1)}%`,
          );
        }

        // Connect time should not degrade significantly
        if (result.averageConnectTimeMs > 1000) {
          console.log(
            `[FINDING] High average connect time: ${result.averageConnectTimeMs.toFixed(0)}ms`,
          );
        }

        // Server should still be responsive after stress test
        const testConn = createConnection({
          port: server.port,
          clientGroupID: 'test-cg',
          clientID: 'post-stress-test',
          wsID: 'final-ws',
        });

        await testConn.opened;
        const latency = await measurePingLatency(testConn);
        expect(latency).toBeDefined();
        expect(latency).toBeLessThan(1000);

        testConn.close();
      } finally {
        await server.cleanup();
      }
    });

    test('concurrent clients with overlapping reconnects', async ({
      testDBs,
    }) => {
      const server = await startPentestServer(testDBs, {
        adminPassword: 'test-password',
        nodeEnv: 'production',
      });

      try {
        // Run reconnect cycles for multiple clients concurrently
        const results = await Promise.all([
          runReconnectCycles(server.port, 'test-cg', 'concurrent-1', 10, 20),
          runReconnectCycles(server.port, 'test-cg', 'concurrent-2', 10, 20),
          runReconnectCycles(server.port, 'test-cg', 'concurrent-3', 10, 20),
        ]);

        // All should have reasonable success rates
        for (let i = 0; i < results.length; i++) {
          const r = results[i];
          const rate =
            r.successfulConnects / (r.successfulConnects + r.failedConnects);
          if (rate < 0.8) {
            console.log(
              `[FINDING] Client ${i + 1} low success rate: ${(rate * 100).toFixed(1)}%`,
            );
          }
        }

        // Server should still be responsive
        const testConn = createConnection({
          port: server.port,
          clientGroupID: 'test-cg',
          clientID: 'post-concurrent',
          wsID: 'test',
        });

        await testConn.opened;
        const latency = await measurePingLatency(testConn);
        expect(latency).toBeDefined();
        testConn.close();
      } finally {
        await server.cleanup();
      }
    });
  });

  describe('message ordering violations', () => {
    test('out-of-order protocol messages', async ({testDBs}) => {
      const server = await startPentestServer(testDBs, {
        adminPassword: 'test-password',
        nodeEnv: 'production',
      });

      try {
        const conn = createConnection({
          port: server.port,
          clientGroupID: 'test-cg',
          clientID: 'order-test',
          wsID: 'order-ws',
        });

        await conn.opened;

        // Send messages in unusual order (push before initConnection)
        // This should be handled gracefully
        sendRapidMessages(conn, [
          createPushMessage('order-test', [{id: 1, name: 'test', args: []}]),
          createPingMessage(),
          createInitConnectionMessage(),
          createPingMessage(),
        ]);

        // Wait for responses
        await new Promise(r => setTimeout(r, 2000));

        // Connection should still be open (not crashed)
        const stillOpen = conn.isOpen();
        if (!stillOpen) {
          const closeInfo = await conn.closed;
          console.log(
            `[NOTE] Connection closed after out-of-order messages: code=${closeInfo.code}`,
          );
        }

        // Should have received some messages (even if errors)
        expect(conn.messages.length).toBeGreaterThan(0);

        conn.close();
      } finally {
        await server.cleanup();
      }
    });

    test('rapid fire same message type', async ({testDBs}) => {
      const server = await startPentestServer(testDBs, {
        adminPassword: 'test-password',
        nodeEnv: 'production',
      });

      try {
        const conn = createConnection({
          port: server.port,
          clientGroupID: 'test-cg',
          clientID: 'rapid-ping',
          wsID: 'rapid-ws',
        });

        await conn.opened;

        // Send 100 pings as fast as possible
        const pings: ReturnType<typeof createPingMessage>[] = [];
        for (let i = 0; i < 100; i++) {
          pings.push(createPingMessage());
        }
        sendRapidMessages(conn, pings);

        // Wait for responses
        await new Promise(r => setTimeout(r, 3000));

        // Should receive 100 pongs
        const pongs = conn.messages.filter(
          m => Array.isArray(m) && m[0] === 'pong',
        );

        if (pongs.length !== 100) {
          console.log(
            `[NOTE] Received ${pongs.length}/100 pongs (some may be coalesced)`,
          );
        }

        // Connection should still be alive
        expect(conn.isOpen()).toBe(true);

        conn.close();
      } finally {
        await server.cleanup();
      }
    });
  });

  describe('concurrent operations', () => {
    test('concurrent ping from multiple connections', async ({testDBs}) => {
      const server = await startPentestServer(testDBs, {
        adminPassword: 'test-password',
        nodeEnv: 'production',
      });

      try {
        // Create 10 different clients
        const connections: ManagedConnection[] = [];
        for (let i = 0; i < 10; i++) {
          const conn = createConnection({
            port: server.port,
            clientGroupID: 'test-cg',
            clientID: `concurrent-client-${i}`,
            wsID: `concurrent-ws-${i}`,
          });
          connections.push(conn);
        }

        // Wait for all to open
        await Promise.all(connections.map(c => c.opened));

        // All send ping simultaneously
        for (const conn of connections) {
          conn.send(createPingMessage());
        }

        // Wait for all pongs
        const pongResults = await Promise.all(
          connections.map(c => c.waitForMessage('pong', 5000)),
        );

        // All should have received pong
        const receivedCount = pongResults.filter(p => p !== undefined).length;
        expect(receivedCount).toBe(10);

        closeAllConnections(connections);
      } finally {
        await server.cleanup();
      }
    });

    test('message interleaving between clients', async ({testDBs}) => {
      const server = await startPentestServer(testDBs, {
        adminPassword: 'test-password',
        nodeEnv: 'production',
      });

      try {
        // Create 2 clients
        const conn1 = createConnection({
          port: server.port,
          clientGroupID: 'test-cg',
          clientID: 'interleave-1',
          wsID: 'interleave-ws-1',
        });

        const conn2 = createConnection({
          port: server.port,
          clientGroupID: 'test-cg',
          clientID: 'interleave-2',
          wsID: 'interleave-ws-2',
        });

        await Promise.all([conn1.opened, conn2.opened]);

        // Interleave messages
        for (let i = 0; i < 10; i++) {
          conn1.send(createPingMessage());
          conn2.send(createPingMessage());
        }

        // Wait for responses
        await new Promise(r => setTimeout(r, 2000));

        // Each should have received their pongs
        const pongs1 = conn1.messages.filter(
          m => Array.isArray(m) && m[0] === 'pong',
        );
        const pongs2 = conn2.messages.filter(
          m => Array.isArray(m) && m[0] === 'pong',
        );

        expect(pongs1.length).toBe(10);
        expect(pongs2.length).toBe(10);

        closeAllConnections([conn1, conn2]);
      } finally {
        await server.cleanup();
      }
    });
  });

  describe('connection cleanup', () => {
    test('graceful close cleans up resources', async ({testDBs}) => {
      const server = await startPentestServer(testDBs, {
        adminPassword: 'test-password',
        nodeEnv: 'production',
      });

      try {
        const conn = createConnection({
          port: server.port,
          clientGroupID: 'test-cg',
          clientID: 'cleanup-test',
          wsID: 'cleanup-ws',
        });

        await conn.opened;

        // Do a ping to verify connection is working
        conn.send(createPingMessage());
        await conn.waitForMessage('pong', 2000);

        // Close gracefully
        conn.close(1000, 'Normal close');

        // Wait for close (code may vary depending on timing)
        const closeInfo = await conn.closed;
        expect(closeInfo.code).toBeGreaterThanOrEqual(1000);

        // Create new connection with same clientID
        const conn2 = createConnection({
          port: server.port,
          clientGroupID: 'test-cg',
          clientID: 'cleanup-test',
          wsID: 'cleanup-ws-2',
        });

        await conn2.opened;

        // Should work normally
        const latency = await measurePingLatency(conn2);
        expect(latency).toBeDefined();

        conn2.close();
      } finally {
        await server.cleanup();
      }
    });

    test('abnormal close (no close frame) is handled', async ({testDBs}) => {
      const server = await startPentestServer(testDBs, {
        adminPassword: 'test-password',
        nodeEnv: 'production',
      });

      try {
        const conn = createConnection({
          port: server.port,
          clientGroupID: 'test-cg',
          clientID: 'abnormal-close',
          wsID: 'abnormal-ws',
        });

        await conn.opened;

        // Terminate without close frame
        conn.ws.terminate();

        // Wait a bit
        await new Promise(r => setTimeout(r, 500));

        // Create new connection - should work
        const conn2 = createConnection({
          port: server.port,
          clientGroupID: 'test-cg',
          clientID: 'abnormal-close',
          wsID: 'abnormal-ws-2',
        });

        await conn2.opened;
        const latency = await measurePingLatency(conn2);
        expect(latency).toBeDefined();

        conn2.close();
      } finally {
        await server.cleanup();
      }
    });
  });

  describe('error recovery', () => {
    test('connection survives malformed messages', async ({testDBs}) => {
      const server = await startPentestServer(testDBs, {
        adminPassword: 'test-password',
        nodeEnv: 'production',
      });

      try {
        const conn = createConnection({
          port: server.port,
          clientGroupID: 'test-cg',
          clientID: 'malformed-test',
          wsID: 'malformed-ws',
        });

        await conn.opened;

        // Send malformed messages
        conn.ws.send('not json');
        conn.ws.send('{}');
        conn.ws.send('[]');
        conn.ws.send('["unknown-type", {}]');
        conn.ws.send('[123, {}]'); // wrong type for message type

        // Wait a bit
        await new Promise(r => setTimeout(r, 500));

        // Connection should still work (or be gracefully closed)
        if (conn.isOpen()) {
          const latency = await measurePingLatency(conn);
          expect(latency).toBeDefined();
        } else {
          // Closed is acceptable, but should be graceful
          const closeInfo = await conn.closed;
          expect(closeInfo.code).toBeGreaterThanOrEqual(1000);
        }

        conn.close();
      } finally {
        await server.cleanup();
      }
    });

    test('server recovers from connection storm', async ({testDBs}) => {
      const server = await startPentestServer(testDBs, {
        adminPassword: 'test-password',
        nodeEnv: 'production',
      });

      try {
        // Create many connections rapidly
        const connections: ManagedConnection[] = [];
        for (let i = 0; i < 50; i++) {
          const conn = createConnection({
            port: server.port,
            clientGroupID: 'test-cg',
            clientID: `storm-client-${i}`,
            wsID: `storm-ws-${i}`,
          });
          connections.push(conn);
        }

        // Wait for connections to settle
        await new Promise(r => setTimeout(r, 3000));

        // Count how many succeeded
        const openCount = connections.filter(c => c.isOpen()).length;

        // Close all
        closeAllConnections(connections);
        await waitForAllClosed(connections, 5000);

        // Server should still be responsive
        const testConn = createConnection({
          port: server.port,
          clientGroupID: 'test-cg',
          clientID: 'post-storm',
          wsID: 'post-storm-ws',
        });

        await testConn.opened;
        const latency = await measurePingLatency(testConn);
        expect(latency).toBeDefined();

        // Log storm results
        console.log(
          `[INFO] Connection storm: ${openCount}/50 connections opened`,
        );

        testConn.close();
      } finally {
        await server.cleanup();
      }
    });
  });
});
