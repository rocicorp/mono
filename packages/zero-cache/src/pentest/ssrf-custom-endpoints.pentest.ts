/**
 * SSRF and Custom Endpoint Security Pentest Suite
 *
 * Tests for Server-Side Request Forgery vulnerabilities in Zero's custom mutation
 * and query endpoint handling.
 *
 * Attack Surface:
 * - ZERO_MUTATE_URL: Custom mutation server endpoint
 * - ZERO_QUERY_URL: Custom query transformation endpoint
 * - URLPattern validation for allowed URLs
 * - HTTP redirect following behavior
 * - URL parsing edge cases
 *
 * Test Categories:
 * 1. URL Validation Bypass Attempts
 * 2. DNS Rebinding Simulation
 * 3. Redirect Chain Following
 * 4. URL Parsing Edge Cases
 * 5. Header Injection via URLs
 *
 * Note: Zero uses URLPattern for URL validation. These tests verify the security
 * of that validation layer and what happens when patterns are misconfigured.
 */

/* eslint-disable no-console */
// Console.log is used intentionally in pentest code to flag security findings

import {describe, expect} from 'vitest';
import {test} from '../test/db.ts';
import {
  compileUrlPattern,
  urlMatch,
  fetchFromAPIServer,
} from '../custom/fetch.ts';
import {
  SSRF_TEST_URLS,
  createMockSSRFServer,
  generateEncodedURLs,
  shouldBeBlocked,
  type MockSSRFServer,
} from './helpers/ssrf-helpers.ts';
import {createSilentLogContext} from '../../../shared/src/logging-test-utils.ts';
import * as v from '../../../shared/src/valita.ts';

const lc = createSilentLogContext();

describe('SSRF and custom endpoints', {timeout: 60000}, () => {
  // ===========================================================================
  // 1. URL Pattern Matching Tests
  // ===========================================================================
  describe('URL pattern matching security', () => {
    test('strict URL patterns should not match private IPs', () => {
      // A properly configured pattern should be specific
      const strictPattern = compileUrlPattern(
        'https://api.example.com/mutations',
      );

      // Should not match private IPs
      const privateURLs = [
        'http://127.0.0.1/mutations',
        'http://localhost/mutations',
        'http://10.0.0.1/mutations',
        'http://192.168.1.1/mutations',
        'http://169.254.169.254/mutations', // AWS metadata
      ];

      for (const url of privateURLs) {
        const matches = urlMatch(url, [strictPattern]);
        if (matches) {
          console.log(`[FINDING] Strict pattern matched private IP: ${url}`);
        } else {
          console.log(`[INFO] Private IP correctly rejected: ${url}`);
        }
        expect(matches).toBe(false);
      }
    });

    test('wildcard patterns may match unintended URLs', () => {
      // Overly permissive patterns that developers might mistakenly use
      const dangerousPatterns = [
        'http://*', // Matches anything HTTP
        'http://*/*', // Matches any host with path
        'https://*.com/*', // Too broad TLD wildcard
        'http://localhost:*/*', // Localhost with any port
      ];

      const attackURLs = [
        'http://127.0.0.1/evil',
        'http://169.254.169.254/latest/meta-data/',
        'http://10.0.0.1/internal',
      ];

      for (const patternStr of dangerousPatterns) {
        try {
          const pattern = compileUrlPattern(patternStr);

          for (const url of attackURLs) {
            const matches = urlMatch(url, [pattern]);
            if (matches) {
              console.log(
                `[FINDING] Dangerous pattern "${patternStr}" matches "${url}"`,
              );
            }
          }
        } catch (e) {
          console.log(`[INFO] Pattern "${patternStr}" is invalid (good): ${String(e).slice(0, 50)}`);
        }
      }
    });

    test('URL encoding tricks should not bypass pattern matching', () => {
      const pattern = compileUrlPattern('https://api.example.com/*');

      const encodedURLs = [
        'https://api.example.com%2e%2e%2finternal', // Encoded ../
        'https://api.example.com/../internal',
        'https://api.example.com/test%00internal',
        'https://api.example.com/test;internal',
      ];

      for (const url of encodedURLs) {
        try {
          const matches = urlMatch(url, [pattern]);
          console.log(
            `[INFO] Encoded URL "${url.slice(0, 50)}": ${matches ? 'matched' : 'rejected'}`,
          );
        } catch (e) {
          console.log(`[INFO] Encoded URL caused error: ${String(e).slice(0, 50)}`);
        }
      }
    });

    test('@-symbol in URL should not allow user info to bypass host check', () => {
      const pattern = compileUrlPattern('https://api.example.com/*');

      // The @ symbol can be used to specify credentials
      // http://user@host/ - here "user" is ignored and "host" is the actual host
      const atSymbolURLs = [
        'https://api.example.com@127.0.0.1/test',
        'https://user:pass@127.0.0.1/test',
        'https://127.0.0.1@api.example.com/test',
      ];

      for (const url of atSymbolURLs) {
        try {
          const matches = urlMatch(url, [pattern]);
          if (matches) {
            console.log(`[FINDING] @-symbol URL matched: ${url}`);
          } else {
            console.log(`[INFO] @-symbol URL rejected: ${url}`);
          }
        } catch (e) {
          console.log(`[INFO] @-symbol URL caused error: ${String(e).slice(0, 50)}`);
        }
      }
    });
  });

  // ===========================================================================
  // 2. IP Encoding Bypass Attempts
  // ===========================================================================
  describe('IP encoding bypass attempts', () => {
    test('decimal IP encoding should be handled correctly', () => {
      const pattern = compileUrlPattern('https://api.example.com/*');

      // 127.0.0.1 = 2130706433 in decimal
      const decimalIPs = [
        'http://2130706433/test', // 127.0.0.1
        'http://3232235521/test', // 192.168.0.1
        'http://167772161/test', // 10.0.0.1
      ];

      for (const url of decimalIPs) {
        try {
          const matches = urlMatch(url, [pattern]);
          console.log(
            `[INFO] Decimal IP "${url}": ${matches ? 'MATCHED' : 'rejected'}`,
          );
        } catch (e) {
          console.log(`[INFO] Decimal IP error: ${String(e).slice(0, 50)}`);
        }
      }
    });

    test('octal IP encoding should be handled correctly', () => {
      const pattern = compileUrlPattern('https://api.example.com/*');

      // Octal encoded IPs
      const octalIPs = [
        'http://0177.0.0.1/test', // 127.0.0.1
        'http://0177.0000.0000.0001/test', // 127.0.0.1 full octal
        'http://0300.0250.0.1/test', // 192.168.0.1
      ];

      for (const url of octalIPs) {
        try {
          const matches = urlMatch(url, [pattern]);
          console.log(
            `[INFO] Octal IP "${url}": ${matches ? 'MATCHED' : 'rejected'}`,
          );
        } catch (e) {
          console.log(`[INFO] Octal IP error: ${String(e).slice(0, 50)}`);
        }
      }
    });

    test('hex IP encoding should be handled correctly', () => {
      const pattern = compileUrlPattern('https://api.example.com/*');

      // Hex encoded IPs
      const hexIPs = [
        'http://0x7f.0x0.0x0.0x1/test', // 127.0.0.1
        'http://0x7f000001/test', // 127.0.0.1 full hex
        'http://0xc0a80001/test', // 192.168.0.1
      ];

      for (const url of hexIPs) {
        try {
          const matches = urlMatch(url, [pattern]);
          console.log(
            `[INFO] Hex IP "${url}": ${matches ? 'MATCHED' : 'rejected'}`,
          );
        } catch (e) {
          console.log(`[INFO] Hex IP error: ${String(e).slice(0, 50)}`);
        }
      }
    });

    test('all encoding variants for 127.0.0.1 should be blocked', () => {
      // Generate all known encodings of 127.0.0.1
      const encodedURLs = generateEncodedURLs('127.0.0.1', '/api/test');

      console.log('[INFO] Testing encoded URL variants for 127.0.0.1:');
      for (const url of encodedURLs) {
        const blockedByFilter = shouldBeBlocked(url);
        console.log(`  ${url}: ${blockedByFilter ? 'would be blocked' : 'NOT blocked'}`);
      }
    });
  });

  // ===========================================================================
  // 3. Mock Server SSRF Tests
  // ===========================================================================
  describe('redirect chain handling', () => {
    let mockServer: MockSSRFServer;

    test('setup mock server', async () => {
      mockServer = await createMockSSRFServer();
      console.log(`[INFO] Mock SSRF server started on port ${mockServer.port}`);
    });

    test('fetch should not follow redirects to internal IPs', () => {
      if (!mockServer) {
        console.log('[SKIP] Mock server not available');
        return;
      }

      // Configure mock server to redirect to internal IP
      mockServer.setNextResponse({
        status: 302,
        redirectTo: 'http://127.0.0.1:8080/internal',
      });

      // Note: We can only test the URL matching, not the actual redirect following
      // because fetchFromAPIServer doesn't expose a way to test redirect behavior
      // without a full server setup

      console.log('[INFO] Redirect to internal IP test configured');
      console.log('  Source:', mockServer.baseUrl);
      console.log('  Redirect target: http://127.0.0.1:8080/internal');

      // The actual fetch behavior depends on Node's fetch implementation
      // and whether redirects are followed automatically
    });

    test('cleanup mock server', async () => {
      if (mockServer) {
        await mockServer.close();
        console.log('[INFO] Mock server closed');
      }
    });
  });

  // ===========================================================================
  // 4. Unicode and Punycode Tests
  // ===========================================================================
  describe('unicode and punycode handling', () => {
    test('unicode hostnames should be handled correctly', () => {
      const pattern = compileUrlPattern('https://example.com/*');

      const unicodeURLs = Object.entries(SSRF_TEST_URLS.unicode);

      for (const [name, url] of unicodeURLs) {
        try {
          const matches = urlMatch(url, [pattern]);
          console.log(
            `[INFO] Unicode ${name}: ${matches ? 'matched' : 'rejected'}`,
          );
        } catch (e) {
          console.log(
            `[INFO] Unicode ${name} error: ${String(e).slice(0, 50)}`,
          );
        }
      }
    });

    test('punycode domains should be properly resolved', () => {
      // Punycode for internationalized domain names
      const punycodeURLs = [
        {original: 'https://münchen.example.com/test', punycode: 'https://xn--mnchen-3ya.example.com/test'},
        {original: 'https://例え.jp/test', punycode: 'https://xn--r8jz45g.jp/test'},
      ];

      for (const {original, punycode} of punycodeURLs) {
        console.log(`[INFO] Punycode test:`);
        console.log(`  Original: ${original}`);
        console.log(`  Punycode: ${punycode}`);
      }
    });
  });

  // ===========================================================================
  // 5. DNS Rebinding Concepts
  // ===========================================================================
  describe('DNS rebinding awareness', () => {
    test('DNS rebinding attack vector documentation', () => {
      // DNS rebinding is a TOCTOU attack where:
      // 1. URL validation resolves hostname to public IP (passes check)
      // 2. Actual fetch resolves hostname to private IP (bypasses check)
      //
      // This can't be tested directly without actual DNS infrastructure,
      // but we document the attack vector.

      console.log('[INFO] DNS Rebinding Attack Vector:');
      console.log('  1. Attacker registers domain attacker.com');
      console.log('  2. DNS returns public IP at validation time');
      console.log('  3. TTL is set very low (0-1 seconds)');
      console.log('  4. When fetch occurs, DNS returns 127.0.0.1');
      console.log('  5. Request goes to internal service');
      console.log('');
      console.log('Mitigation strategies:');
      console.log('  - Resolve DNS once and use IP for all requests');
      console.log('  - Block private IPs at network layer');
      console.log('  - Use allowlist of specific IPs, not hostnames');
      console.log('  - Validate final destination IP after any redirects');

      // Services like nip.io allow DNS rebinding testing
      const nioUrls = SSRF_TEST_URLS.dnsRebinding;
      console.log('\n[INFO] NIP.io test URLs (for manual testing):');
      for (const [name, url] of Object.entries(nioUrls)) {
        console.log(`  ${name}: ${url}`);
      }
    });
  });

  // ===========================================================================
  // 6. Protocol Handling Tests
  // ===========================================================================
  describe('protocol handling', () => {
    test('non-HTTP protocols should be rejected', () => {
      const pattern = compileUrlPattern('https://api.example.com/*');

      const nonHttpURLs = Object.entries(SSRF_TEST_URLS.protocols);

      for (const [name, url] of nonHttpURLs) {
        try {
          const matches = urlMatch(url, [pattern]);
          if (matches) {
            console.log(`[FINDING] Non-HTTP protocol matched: ${name} = ${url}`);
          } else {
            console.log(`[INFO] Non-HTTP protocol rejected: ${name}`);
          }
        } catch (e) {
          console.log(`[INFO] Non-HTTP protocol error: ${name} - ${String(e).slice(0, 30)}`);
        }
      }
    });

    test('http vs https should be distinguished', () => {
      const httpsPattern = compileUrlPattern('https://api.example.com/*');

      const httpURL = 'http://api.example.com/test';
      const httpsURL = 'https://api.example.com/test';

      const httpMatches = urlMatch(httpURL, [httpsPattern]);
      const httpsMatches = urlMatch(httpsURL, [httpsPattern]);

      console.log(`[INFO] HTTPS-only pattern matching:`);
      console.log(`  http://... matches: ${httpMatches}`);
      console.log(`  https://... matches: ${httpsMatches}`);

      // A strict HTTPS pattern should NOT match HTTP
      if (httpMatches) {
        console.log('[FINDING] HTTPS pattern matched HTTP URL - downgrade possible');
      }
    });
  });

  // ===========================================================================
  // 7. fetchFromAPIServer Security Tests
  // ===========================================================================
  describe('fetchFromAPIServer security', () => {
    test('fetch with no allowed patterns should fail', async () => {
      const validator = v.object({});

      try {
        await fetchFromAPIServer(
          validator,
          'push',
          lc,
          'https://api.example.com/test',
          false,
          [], // Empty allowed patterns
          {appID: 'test', shardNum: 0},
          {},
          {},
        );
        console.log('[FINDING] Fetch succeeded with no allowed patterns!');
      } catch {
        console.log('[INFO] Fetch correctly rejected with no allowed patterns');
      }
    });

    test('fetch to URL not matching patterns should fail', async () => {
      const validator = v.object({});
      const allowedPattern = compileUrlPattern('https://api.allowed.com/*');

      try {
        await fetchFromAPIServer(
          validator,
          'push',
          lc,
          'https://api.attacker.com/test',
          false,
          [allowedPattern],
          {appID: 'test', shardNum: 0},
          {},
          {},
        );
        console.log('[FINDING] Fetch succeeded to non-allowed URL!');
      } catch (e) {
        const errMsg = String(e);
        if (errMsg.includes('not allowed')) {
          console.log('[INFO] Fetch correctly rejected non-allowed URL');
        } else {
          console.log('[INFO] Fetch failed for other reason:', errMsg.slice(0, 100));
        }
      }
    });

    test('reserved query params should be blocked', async () => {
      const validator = v.object({});
      const allowedPattern = compileUrlPattern('https://api.allowed.com/*');

      // Try to inject reserved params
      const attackURLs = [
        'https://api.allowed.com/test?schema=evil',
        'https://api.allowed.com/test?appID=hacked',
      ];

      for (const url of attackURLs) {
        try {
          await fetchFromAPIServer(
            validator,
            'push',
            lc,
            url,
            false,
            [allowedPattern],
            {appID: 'test', shardNum: 0},
            {},
            {},
          );
          console.log(`[FINDING] Reserved param injection allowed: ${url}`);
        } catch (e) {
          const errMsg = String(e);
          if (errMsg.includes('reserved')) {
            console.log(`[INFO] Reserved param correctly blocked: ${url.slice(0, 50)}`);
          } else {
            console.log(`[INFO] Failed for other reason: ${errMsg.slice(0, 50)}`);
          }
        }
      }
    });
  });

  // ===========================================================================
  // 8. AWS Metadata Endpoint Tests
  // ===========================================================================
  describe('cloud metadata endpoint protection', () => {
    test('AWS metadata endpoint URLs should be identifiable', () => {
      // AWS Instance Metadata Service URLs
      const awsMetadataURLs = [
        'http://169.254.169.254/latest/meta-data/',
        'http://169.254.169.254/latest/user-data',
        'http://169.254.169.254/latest/api/token',
        'http://169.254.169.254/latest/meta-data/iam/security-credentials/',
      ];

      console.log('[INFO] AWS Metadata endpoint test URLs:');
      for (const url of awsMetadataURLs) {
        const wouldBeBlocked = shouldBeBlocked(url);
        console.log(`  ${url}: ${wouldBeBlocked ? 'blocked' : 'NOT BLOCKED'}`);
      }

      // GCP metadata endpoint
      const gcpMetadataURLs = [
        'http://metadata.google.internal/computeMetadata/v1/',
        'http://169.254.169.254/computeMetadata/v1/', // GCP also uses this
      ];

      console.log('\n[INFO] GCP Metadata endpoint test URLs:');
      for (const url of gcpMetadataURLs) {
        const wouldBeBlocked = shouldBeBlocked(url);
        console.log(`  ${url}: ${wouldBeBlocked ? 'blocked' : 'NOT BLOCKED'}`);
      }
    });
  });
});
