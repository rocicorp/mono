# Zero Cache Pentest Plan

Areas to explore with dynamic testing to find unknown vulnerabilities or verify uncertain findings from code review.

---

## Findings from Dynamic Testing

### Authentication Edge Cases (Tested 2026-01-16)

**Test file:** `src/pentest/auth-edge-cases.pentest.ts`

**Results:** 12/13 tests pass

| Test                             | Result | Notes                                                  |
| -------------------------------- | ------ | ------------------------------------------------------ |
| Malformed sec-websocket-protocol | PASS   | ws library rejects invalid protocols at client level   |
| Missing protocol header          | PASS   | Server correctly rejects                               |
| Malformed JWT tokens             | PASS   | All malformed variants rejected                        |
| Expired JWT                      | PASS   | Correctly rejected with close code 3000                |
| JWT with future nbf              | PASS   | Correctly rejected                                     |
| JWT with alg:none                | PASS   | Correctly rejected (jose library prevents this attack) |
| JWT subject mismatch             | PASS   | Correctly rejected                                     |
| JWT wrong signature              | PASS   | Correctly rejected                                     |
| No token with JWT config         | PASS   | Anonymous connection allowed                           |
| Token without JWT config         | PASS   | Error thrown (see finding below)                       |
| Empty string token               | PASS   | Handled correctly                                      |
| Connection reuse after expiry    | PASS   | Connection persists (expected - tokens validated once) |
| Invalid protocol version         | PASS   | Server rejects invalid version                         |

**Finding: Unhandled Error Path**

When a client sends a token but the server has no JWT config (and no custom endpoints), the server throws an unhandled error in `#createConnection` (syncer.ts:157). This causes an unhandled rejection rather than a graceful error response.

**Recommendation:** The error should be caught and sent to the client as an error message before closing the connection, rather than throwing an unhandled rejection.

---

### Query Engine Fuzzing (Tested 2026-01-16)

**Test file:** `src/pentest/query-fuzzing.pentest.ts`

**Results:** 19/19 tests pass - No vulnerabilities found

| Category              | Tests | Result | Notes                                         |
| --------------------- | ----- | ------ | --------------------------------------------- |
| AST Structure Fuzzing | 3     | PASS   | Malformed ASTs rejected without crash         |
| SQL Injection Vectors | 5     | PASS   | All injection payloads properly parameterized |
| RLS Bypass Attempts   | 5     | PASS   | Protected/unreadable tables return empty      |
| Boundary Values       | 2     | PASS   | Edge values handled correctly                 |
| Resource Exhaustion   | 2     | PASS   | Deep nesting and large queries handled        |
| Query Patch Fuzzing   | 1     | PASS   | Malformed patches rejected gracefully         |
| authData Edge Cases   | 1     | PASS   | Unusual claim structures handled              |

**Security Findings:** None

The Zero query engine demonstrates robust security:

- SQL injection attempts are properly parameterized via `@databases/sql`
- RLS (Row-Level Security) is correctly enforced - queries to protected tables return empty results
- Malformed AST structures are rejected with proper error handling (no crashes)
- Resource exhaustion attempts (deep nesting, large conditions) are handled gracefully

---

## Verify Uncertain Findings

### ZSP-014: wsID Default Empty String (Verified 2026-01-16) ✅ NOT A VULNERABILITY

**Location:** `src/workers/connect-params.ts:47`

**Question:** Code shows `wsid` defaults to `''` when not provided. Can multiple connections share the same empty wsID, and does this cause security issues?

**Test approach:**

- [x] Connect multiple clients without `wsid` parameter
- [x] Verify whether messages can leak between connections
- [x] Check if connection state becomes confused

**Results:**

| Test                             | Result | Notes                                     |
| -------------------------------- | ------ | ----------------------------------------- |
| Multiple clients with empty wsID | PASS   | Connections properly isolated by clientID |
| Same clientID, different wsID    | PASS   | Old connection correctly replaced         |
| Same clientID and same wsID      | PASS   | Duplicate handled correctly (one closed)  |

**Conclusion:** The `wsID` parameter is only used for detecting reconnection of the same client - it's NOT used for routing or message delivery. Connections are keyed by `clientID`, not `wsID`. Multiple clients with empty `wsID` are properly isolated by their distinct `clientID` values.

**Status: VERIFIED - Not a security vulnerability**

---

## Exploratory Testing Areas

### 1. Authentication Edge Cases ✅ TESTED

**Goal:** Find edge cases in JWT/token handling not covered by static review.

**Status:** Tested (see Findings section above)

**Test approach:**

- [x] Malformed JWTs (truncated, wrong algorithm, expired edge cases)
- [x] Token parsing with unexpected characters/encoding
- [ ] Race conditions between token validation and request processing
- [x] Empty vs null vs missing token distinction
- [x] Tokens with unusual claims structures

### 2. Message Parsing Boundaries ✅ TESTED

**Goal:** Find parsing vulnerabilities through boundary testing.

**Status:** Tested (see Phase 15 below)

**Test approach:**

- [x] Type confusion in message handlers
- [x] Integer overflow in size/count fields
- [x] Unicode edge cases in identifiers (table names, column names)
- [x] Deeply nested JSON structures
- [x] Messages at exact size boundaries

### 3. Query Engine Fuzzing ✅ TESTED

**Goal:** Find SQL injection or logic bugs through malformed queries.

**Status:** Tested (see Findings section below)

**Test approach:**

- [x] Malformed AST structures that pass Valita validation but break execution
- [x] Deep nesting / recursion in queries
- [x] Edge cases in RLS condition generation
- [x] Column/table names with special characters
- [x] Values that look like SQL but should be escaped
- [x] Subquery edge cases (oracle attack variations)

### 4. State Machine Bugs

**Goal:** Find race conditions and state confusion vulnerabilities.

**Test approach:**

- [ ] Out-of-order protocol messages
- [ ] Reconnection during active operations
- [ ] Concurrent mutations to same data
- [ ] Connection lifecycle edge cases (close during operation)
- [ ] Multiple rapid connect/disconnect cycles

### 5. Internal Query Bypass (ZSP-005 Verification) ✅ TESTED

**Goal:** Confirm clients cannot trigger `internalQuery: true` to bypass RLS.

**Status:** Covered in query-fuzzing.pentest.ts RLS bypass tests

**Location:** `src/services/view-syncer/cvr.ts:82-89`

**Test approach:**

- [x] Attempt to inject `type: 'internal'` in query messages
- [x] Try reserved query IDs (`lmids`, `mutationResults`)
- [x] Fuzz query type determination logic

**Results:** All bypass attempts properly rejected. Reserved query IDs handled correctly.

### 6. Custom Endpoint Security

**Goal:** Find SSRF or validation bypasses in custom mutation/query URLs.

**Location:** `src/custom/fetch.ts`

**Test approach:**

- [ ] URL parsing edge cases (unicode, encoding)
- [ ] DNS rebinding scenarios
- [ ] Response handling edge cases
- [ ] Timeout/retry abuse

---

## Test Priority

| Priority | Area                      | Status  | Rationale                           |
| -------- | ------------------------- | ------- | ----------------------------------- |
| 1        | Authentication Edge Cases | ✅ DONE | High impact, complex code path      |
| 2        | Query Engine Fuzzing      | ✅ DONE | SQL injection = critical if found   |
| 3        | ZSP-014 Verification      | ✅ DONE | Not a vulnerability                 |
| 4        | Internal Query Bypass     | ✅ DONE | Covered in query fuzzing RLS tests  |
| 5        | State Machine Bugs        | ✅ DONE | See Phase 14 below                  |
| 6        | Message Parsing           | ✅ DONE | See Phase 15 below                  |
| 7        | Custom Endpoint Security  | TODO    | Depends on deployment configuration |
| 8        | Zero-Server Mutations     | ✅ DONE | See Phase 13 below                  |

---

## Phase 13: Zero-Server Mutation Security (Tested 2026-01-16)

**Test file:** `packages/zero-server/src/pentest/zero-server.pentest.ts`

### Test Categories

| Category            | Tests | Target                                                        |
| ------------------- | ----- | ------------------------------------------------------------- |
| Prototype Pollution | 3     | `push-processor.ts:104` - `getValueAtPath()` mutator dispatch |
| Mutation ID Attacks | 3     | `zql-database.ts:58-99` - LMID tracking                       |
| SQL Injection       | 3     | `custom.ts:348-429` - INSERT/UPDATE/DELETE SQL generation     |
| Client Isolation    | 3     | Process-mutations client/clientGroup boundaries               |
| Error Leakage       | 3     | Error message information disclosure                          |
| Input Validation    | 3     | Schema bypass, type confusion, edge cases                     |

### Key Findings

**Prototype Pollution via Mutator Path:**

- Location: `packages/shared/src/object-traversal.ts:38`
- The `getValueAtPath()` function uses `part in current` which includes prototype properties
- Attack: Mutator name `__proto__.polluted` or `constructor.prototype.admin` could traverse prototype chain
- Status: **Tested** - The assertion `typeof mutator === 'function'` at push-processor.ts:105 provides defense-in-depth; prototype properties return non-functions

**SQL Injection in CRUD:**

- Location: `packages/zero-server/src/custom.ts:350-428`
- Uses `@databases/sql` template literals for parameterized queries
- Status: **Tested** - All injection payloads properly parameterized

**Client Isolation:**

- Location: `packages/zero-server/src/zql-database.ts:58-74`
- LMID tracked per (clientGroupID, clientID) tuple
- Status: **Tested** - Proper isolation verified

### Running the Tests

```bash
# Run zero-server pentest suite
npm --workspace=zero-server run test -- --config vitest.config.pentest.ts
```

---

## Phase 14: State Machine Bugs (Tested 2026-01-19)

**Test file:** `packages/zero-cache/src/pentest/state-machine.pentest.ts`

### Test Categories

| Category                     | Tests | Target                                                |
| ---------------------------- | ----- | ----------------------------------------------------- |
| Connection Replacement Races | 3     | `syncer.ts:126-250` - Connection creation/replacement |
| wsID Confusion Attacks       | 2     | `view-syncer.ts:876-881` - wsID filtering             |
| Rapid Reconnect Cycles       | 2     | Connection churn DoS potential                        |
| Message Ordering             | 2     | Protocol message sequencing                           |
| Concurrent Operations        | 2     | Multi-client concurrent access                        |
| Connection Cleanup           | 2     | Graceful/abnormal close handling                      |
| Error Recovery               | 2     | Malformed messages, connection storms                 |

### Key Findings

**Connection Replacement (No Vulnerabilities Found):**

- Location: `packages/zero-cache/src/workers/syncer.ts:126-140`
- When multiple connections arrive with same `clientID`, older connections are properly closed
- The replacement logic is synchronous within the handler, preventing race conditions
- Status: **Tested** - Proper connection replacement verified

**wsID Message Filtering:**

- Location: `packages/zero-cache/src/services/view-syncer/view-syncer.ts:876-881`
- Messages from stale `wsID` are silently dropped (by design)
- Status: **Tested** - Messages properly filtered by wsID

**Rapid Reconnection Handling:**

- Server handles 20+ rapid reconnects without degradation
- Connection storms (50 simultaneous connections) handled gracefully
- Status: **Tested** - No DoS vulnerability found

**Message Ordering:**

- Out-of-order protocol messages handled gracefully (error response)
- Rapid-fire same message type (100 pings) processed correctly
- Status: **Tested** - Proper message handling verified

### Running the Tests

```bash
# Run state machine pentest suite
npm --workspace=zero-cache run test -- --config vitest.config.pentest.ts --testNamePattern="state machine"
```

---

## Phase 15: Message Parsing Penetration Testing (Tested 2026-01-19)

**Test file:** `packages/zero-cache/src/pentest/message-parsing.pentest.ts`

### Test Categories

| Category                  | Tests | Target                                                   |
| ------------------------- | ----- | -------------------------------------------------------- |
| JSON Depth DoS            | 4     | `connection.ts:186` - JSON.parse() without depth limits  |
| Base64 Header Attacks     | 3     | `connect.ts:83` - atob() without size limits             |
| Integer Overflow/Coercion | 2     | `url-params.ts:28` - parseInt() without bounds           |
| Unbounded Array/String    | 4     | `push.ts:104`, `syncer-ws-message-handler.ts:110`        |
| Unicode Confusion         | 2     | `mutagen.ts:382` - Table names without normalization     |
| Type Confusion            | 3     | `syncer-ws-message-handler.ts:82-222` - Message dispatch |
| Size Boundary             | 3     | WebSocket frame boundary handling                        |
| Production JSON Bypass    | 1     | `config.ts:9` - skipAssertJSONValue in production        |

### Critical Finding: Production JSON Validation Bypass

**Location:** `packages/shared/src/config.ts:9`

When `NODE_ENV === 'production'`, `skipAssertJSONValue` is `true`. This means:

- The recursive `isJSONValue()` function is bypassed entirely in production
- Deeply nested JSON passes through completely unvalidated
- No depth limits are enforced on incoming JSON structures

**Recommendation:** Add explicit depth limiting in `connection.ts:186` before `JSON.parse()`, independent of the assertion configuration.

### Key Findings

**JSON Depth DoS:**

- Location: `packages/zero-cache/src/workers/connection.ts:186`
- `JSON.parse()` accepts arbitrary nesting depth (tested up to 5000 levels)
- Status: **Tested** - Server handles gracefully but no explicit limits

**Base64 Size Limits:**

- Location: `packages/zero-protocol/src/connect.ts:83`
- `atob()` called without size validation on sec-websocket-protocol header
- Status: **Tested** - Large payloads (100KB+) accepted without explicit limits

**Integer Parsing:**

- Location: `packages/zero-cache/src/types/url-params.ts:28`
- `parseInt()` used without bounds checking
- Values like `NaN`, `Infinity`, and beyond MAX_SAFE_INTEGER may be accepted
- Status: **Tested** - Some edge values handled, others may cause logic issues

**Unbounded Arrays:**

- Push messages with many mutations (1000+) accepted
- Single mutations with many ops (10000+) processed without limits
- Query patches with many queries (5000+) accepted
- Status: **Tested** - Server handles load but no explicit limits

**Unicode Confusion:**

- Table/column names accept homoglyphs (Cyrillic 'е' vs Latin 'e')
- Zero-width characters, RTL overrides, combining characters accepted
- No Unicode normalization performed on identifiers
- Status: **Tested** - Potential for confusion attacks on identifier matching

### Security Recommendations

Based on testing results:

1. **Add JSON depth limit** in `connection.ts` before `JSON.parse()` - recommend max depth of 32-64 levels
2. **Add base64 size limit** in `connect.ts` before `atob()` - recommend max size of 64KB
3. **Add integer bounds validation** in `url-params.ts` - validate ts/lmid are in safe integer range
4. **Add mutation/op count limits** in message handlers - recommend max 100 mutations, max 1000 ops per mutation
5. **Add Unicode normalization** for table/column identifiers - use NFC normalization
6. **Re-evaluate JSON validation bypass in production** - consider always validating or adding depth limit

### Running the Tests

```bash
# Run message parsing pentest suite
npm --workspace=zero-cache run test -- --config vitest.config.pentest.ts --testNamePattern="message parsing"
```
