# Zero Cache Pentest Plan

Areas to explore with dynamic testing to find unknown vulnerabilities or verify uncertain findings from code review.

---

## Findings from Dynamic Testing

### Authentication Edge Cases (Tested 2026-01-16)

**Test file:** `src/pentest/auth-edge-cases.pentest.ts`

**Results:** 12/13 tests pass

| Test                             | Result | Notes                                                  |
| -------------------------------- | ------ | ------------------------------------------------------ |
| Malformed sec-websocket-protocol | PASS   | ws library rejects invalid protocols at client level   |
| Missing protocol header          | PASS   | Server correctly rejects                               |
| Malformed JWT tokens             | PASS   | All malformed variants rejected                        |
| Expired JWT                      | PASS   | Correctly rejected with close code 3000                |
| JWT with future nbf              | PASS   | Correctly rejected                                     |
| JWT with alg:none                | PASS   | Correctly rejected (jose library prevents this attack) |
| JWT subject mismatch             | PASS   | Correctly rejected                                     |
| JWT wrong signature              | PASS   | Correctly rejected                                     |
| No token with JWT config         | PASS   | Anonymous connection allowed                           |
| Token without JWT config         | PASS   | Error thrown (see finding below)                       |
| Empty string token               | PASS   | Handled correctly                                      |
| Connection reuse after expiry    | PASS   | Connection persists (expected - tokens validated once) |
| Invalid protocol version         | PASS   | Server rejects invalid version                         |

**Finding: Unhandled Error Path**

When a client sends a token but the server has no JWT config (and no custom endpoints), the server throws an unhandled error in `#createConnection` (syncer.ts:157). This causes an unhandled rejection rather than a graceful error response.

**Recommendation:** The error should be caught and sent to the client as an error message before closing the connection, rather than throwing an unhandled rejection.

---

### Query Engine Fuzzing (Tested 2026-01-16)

**Test file:** `src/pentest/query-fuzzing.pentest.ts`

**Results:** 19/19 tests pass - No vulnerabilities found

| Category | Tests | Result | Notes |
| --- | --- | --- | --- |
| AST Structure Fuzzing | 3 | PASS | Malformed ASTs rejected without crash |
| SQL Injection Vectors | 5 | PASS | All injection payloads properly parameterized |
| RLS Bypass Attempts | 5 | PASS | Protected/unreadable tables return empty |
| Boundary Values | 2 | PASS | Edge values handled correctly |
| Resource Exhaustion | 2 | PASS | Deep nesting and large queries handled |
| Query Patch Fuzzing | 1 | PASS | Malformed patches rejected gracefully |
| authData Edge Cases | 1 | PASS | Unusual claim structures handled |

**Security Findings:** None

The Zero query engine demonstrates robust security:
- SQL injection attempts are properly parameterized via `@databases/sql`
- RLS (Row-Level Security) is correctly enforced - queries to protected tables return empty results
- Malformed AST structures are rejected with proper error handling (no crashes)
- Resource exhaustion attempts (deep nesting, large conditions) are handled gracefully

---

## Verify Uncertain Findings

### ZSP-014: wsID Default Empty String (Verified 2026-01-16) ✅ NOT A VULNERABILITY

**Location:** `src/workers/connect-params.ts:47`

**Question:** Code shows `wsid` defaults to `''` when not provided. Can multiple connections share the same empty wsID, and does this cause security issues?

**Test approach:**

- [x] Connect multiple clients without `wsid` parameter
- [x] Verify whether messages can leak between connections
- [x] Check if connection state becomes confused

**Results:**

| Test | Result | Notes |
| --- | --- | --- |
| Multiple clients with empty wsID | PASS | Connections properly isolated by clientID |
| Same clientID, different wsID | PASS | Old connection correctly replaced |
| Same clientID and same wsID | PASS | Duplicate handled correctly (one closed) |

**Conclusion:** The `wsID` parameter is only used for detecting reconnection of the same client - it's NOT used for routing or message delivery. Connections are keyed by `clientID`, not `wsID`. Multiple clients with empty `wsID` are properly isolated by their distinct `clientID` values.

**Status: VERIFIED - Not a security vulnerability**

---

## Exploratory Testing Areas

### 1. Authentication Edge Cases ✅ TESTED

**Goal:** Find edge cases in JWT/token handling not covered by static review.

**Status:** Tested (see Findings section above)

**Test approach:**

- [x] Malformed JWTs (truncated, wrong algorithm, expired edge cases)
- [x] Token parsing with unexpected characters/encoding
- [ ] Race conditions between token validation and request processing
- [x] Empty vs null vs missing token distinction
- [x] Tokens with unusual claims structures

### 2. Message Parsing Boundaries

**Goal:** Find parsing vulnerabilities through boundary testing.

**Test approach:**

- [ ] Type confusion in message handlers
- [ ] Integer overflow in size/count fields
- [ ] Unicode edge cases in identifiers (table names, column names)
- [ ] Deeply nested JSON structures
- [ ] Messages at exact size boundaries

### 3. Query Engine Fuzzing ✅ TESTED

**Goal:** Find SQL injection or logic bugs through malformed queries.

**Status:** Tested (see Findings section below)

**Test approach:**

- [x] Malformed AST structures that pass Valita validation but break execution
- [x] Deep nesting / recursion in queries
- [x] Edge cases in RLS condition generation
- [x] Column/table names with special characters
- [x] Values that look like SQL but should be escaped
- [x] Subquery edge cases (oracle attack variations)

### 4. State Machine Bugs

**Goal:** Find race conditions and state confusion vulnerabilities.

**Test approach:**

- [ ] Out-of-order protocol messages
- [ ] Reconnection during active operations
- [ ] Concurrent mutations to same data
- [ ] Connection lifecycle edge cases (close during operation)
- [ ] Multiple rapid connect/disconnect cycles

### 5. Internal Query Bypass (ZSP-005 Verification) ✅ TESTED

**Goal:** Confirm clients cannot trigger `internalQuery: true` to bypass RLS.

**Status:** Covered in query-fuzzing.pentest.ts RLS bypass tests

**Location:** `src/services/view-syncer/cvr.ts:82-89`

**Test approach:**

- [x] Attempt to inject `type: 'internal'` in query messages
- [x] Try reserved query IDs (`lmids`, `mutationResults`)
- [x] Fuzz query type determination logic

**Results:** All bypass attempts properly rejected. Reserved query IDs handled correctly.

### 6. Custom Endpoint Security

**Goal:** Find SSRF or validation bypasses in custom mutation/query URLs.

**Location:** `src/custom/fetch.ts`

**Test approach:**

- [ ] URL parsing edge cases (unicode, encoding)
- [ ] DNS rebinding scenarios
- [ ] Response handling edge cases
- [ ] Timeout/retry abuse

---

## Test Priority

| Priority | Area                      | Status | Rationale                              |
| -------- | ------------------------- | ------ | -------------------------------------- |
| 1        | Authentication Edge Cases | ✅ DONE | High impact, complex code path         |
| 2        | Query Engine Fuzzing      | ✅ DONE | SQL injection = critical if found      |
| 3        | ZSP-014 Verification      | ✅ DONE | Not a vulnerability                    |
| 4        | Internal Query Bypass     | ✅ DONE | Covered in query fuzzing RLS tests     |
| 5        | State Machine Bugs        | TODO   | Race conditions hard to find in review |
| 6        | Message Parsing           | TODO   | Lower likelihood but worth exploring   |
| 7        | Custom Endpoint Security  | TODO   | Depends on deployment configuration    |
