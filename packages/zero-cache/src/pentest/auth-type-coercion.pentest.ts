/**
 * Auth Type Coercion Pentest Suite
 *
 * Tests for type confusion and coercion vulnerabilities in Zero's auth system:
 *
 * 1. Claim Type Confusion
 *    - authData cast to Record<string, JSONValue> without validation
 *    - Role as array vs string (`role: ["admin"]` vs `role: "admin"`)
 *    - ID as number vs string (`id: 123` vs `id: "123"`)
 *    - Nested object claims for deep property access
 *
 * 2. Empty Policy Behavior
 *    - Tables with no permissions defined
 *    - Empty conditions array in OR clause
 *    - Broken permission config handling
 *
 * 3. Undefined/Null AuthData Handling
 *    - Undefined authData with field access
 *    - Null claims in policy evaluation
 *    - Missing required claims
 *
 * Reference: read-authorizer.ts:57, write-authorizer.ts:530
 */

/* eslint-disable no-console */
// Console.log is used intentionally in pentest code to flag security findings

import {SignJWT} from 'jose';
import {describe, expect} from 'vitest';
import {test} from '../test/db.ts';
import {startPentestServer} from './helpers/pentest-server.ts';
import {connectSync, waitForConnection, waitForOpenThenClose} from './helpers/ws-client.ts';
import {
  createInsertMutation,
  createUpdateMutation,
  createCRUDPushMessage,
} from './helpers/mutation-helpers.ts';

const TEST_SECRET = 'pentest-type-coercion-secret-32chars!';
const TEST_CLIENT_GROUP = 'type-coercion-test-cg';

/**
 * Creates a JWT with custom claims, allowing for any type of value.
 */
async function createTypeConfusionToken(
  secret: string,
  claims: Record<string, unknown>,
): Promise<string> {
  const secretKey = new TextEncoder().encode(secret);
  const now = Math.floor(Date.now() / 1000);

  return await new SignJWT(claims as Record<string, unknown>)
    .setProtectedHeader({alg: 'HS256'})
    .setIssuedAt(now)
    .setExpirationTime(now + 3600)
    .sign(secretKey);
}

describe('auth type coercion', {timeout: 120000}, () => {
  // ===========================================================================
  // 1. Claim Type Confusion
  // ===========================================================================
  describe('claim type confusion', () => {
    test('role as array instead of string', async ({testDBs}) => {
      const server = await startPentestServer(testDBs, {
        adminPassword: 'test-password',
        nodeEnv: 'production',
        schemaMode: 'mutation-test',
        auth: {secret: TEST_SECRET},
      });

      try {
        // Create token with role as array
        const arrayRoleToken = await createTypeConfusionToken(TEST_SECRET, {
          sub: 'array-role-user',
          role: ['admin'], // Array instead of string "admin"
        });

        const conn = connectSync({
          port: server.port,
          clientGroupID: TEST_CLIENT_GROUP,
          clientID: 'array-role-client',
          userID: 'array-role-user',
          authToken: arrayRoleToken,
        });

        const outcome = await waitForConnection(conn, 5000);

        if (outcome.type === 'opened') {
          // Try to access admin-only table
          const mutation = createInsertMutation(
            'array-role-client',
            1,
            'admin_only',
            {id: 'type-coerce-1', secret: 'array-role-bypass'},
          );
          conn.ws.send(
            JSON.stringify(createCRUDPushMessage(TEST_CLIENT_GROUP, [mutation])),
          );

          await new Promise(resolve => setTimeout(resolve, 2000));

          // If mutation went through with array role, that's a finding
          if (conn.ws.readyState === conn.ws.OPEN) {
            console.log(
              '[INFO] Array role ["admin"] accepted - mutation sent. Check if it executed.',
            );
          }
        } else {
          console.log('[INFO] Array role token rejected at connection level');
        }

        conn.ws.close();
      } finally {
        await server.cleanup();
      }
    });

    test('role with nested array containing admin', async ({testDBs}) => {
      const server = await startPentestServer(testDBs, {
        adminPassword: 'test-password',
        nodeEnv: 'production',
        schemaMode: 'mutation-test',
        auth: {secret: TEST_SECRET},
      });

      try {
        // Try various array structures that might coerce to "admin"
        const tokenVariants: Array<{name: string; claims: Record<string, unknown>}> = [
          {name: 'array-with-admin', claims: {sub: 'u1', role: ['admin', 'user']}},
          {name: 'nested-array', claims: {sub: 'u2', role: [['admin']]}},
          {name: 'object-role', claims: {sub: 'u3', role: {value: 'admin'}}},
          {name: 'object-with-custom-toString', claims: {sub: 'u4', role: {customKey: 'admin'}}},
        ];

        for (const {name, claims} of tokenVariants) {
          try {
            const token = await createTypeConfusionToken(TEST_SECRET, claims);

            const conn = connectSync({
              port: server.port,
              clientGroupID: TEST_CLIENT_GROUP,
              clientID: `coerce-${name}`,
              userID: claims.sub as string,
              authToken: token,
            });

            const outcome = await waitForConnection(conn, 3000);

            if (outcome.type === 'opened') {
              const mutation = createInsertMutation(
                `coerce-${name}`,
                1,
                'admin_only',
                {id: `bypass-${name}`, secret: 'type-confused'},
              );
              conn.ws.send(
                JSON.stringify(createCRUDPushMessage(TEST_CLIENT_GROUP, [mutation])),
              );
              await new Promise(resolve => setTimeout(resolve, 1000));

              console.log(
                `[INFO] ${name}: accepted, ws ${conn.ws.readyState === conn.ws.OPEN ? 'open' : 'closed'}`,
              );
            } else {
              console.log(`[INFO] ${name}: rejected`);
            }

            conn.ws.close();
          } catch (e) {
            console.log(`[INFO] ${name}: error - ${String(e).slice(0, 50)}`);
          }
        }
      } finally {
        await server.cleanup();
      }
    });

    test('sub claim as number instead of string', async ({testDBs}) => {
      const server = await startPentestServer(testDBs, {
        adminPassword: 'test-password',
        nodeEnv: 'production',
        schemaMode: 'mutation-test',
        auth: {secret: TEST_SECRET},
      });

      try {
        // Owner check compares authData.sub with column value
        // If sub is number 1 and column is string "1", comparison might fail or coerce
        const numericSubToken = await createTypeConfusionToken(TEST_SECRET, {
          sub: 1, // Number instead of string "user-1"
        });

        const conn = connectSync({
          port: server.port,
          clientGroupID: TEST_CLIENT_GROUP,
          clientID: 'numeric-sub-client',
          userID: '1',
          authToken: numericSubToken,
        });

        const outcome = await waitForConnection(conn, 5000);

        if (outcome.type === 'opened') {
          // Try to modify owner_only table - should fail since owner_id is string
          const mutation = createUpdateMutation(
            'numeric-sub-client',
            1,
            'owner_only',
            {id: 'own1', owner_id: '1', value: 'numeric-sub-bypass'},
          );
          conn.ws.send(
            JSON.stringify(createCRUDPushMessage(TEST_CLIENT_GROUP, [mutation])),
          );

          await new Promise(resolve => setTimeout(resolve, 2000));

          console.log(
            `[INFO] Numeric sub: ws ${conn.ws.readyState === conn.ws.OPEN ? 'open' : 'closed'}`,
          );
        } else {
          console.log('[INFO] Numeric sub token rejected');
        }

        conn.ws.close();
      } finally {
        await server.cleanup();
      }
    });

    test('claim value comparison edge cases', async ({testDBs}) => {
      const server = await startPentestServer(testDBs, {
        adminPassword: 'test-password',
        nodeEnv: 'production',
        schemaMode: 'mutation-test',
        auth: {secret: TEST_SECRET},
      });

      try {
        // Test comparison edge cases
        const edgeCases = [
          {name: 'null-sub', claims: {sub: null}},
          {name: 'empty-string-sub', claims: {sub: ''}},
          {name: 'zero-sub', claims: {sub: 0}},
          {name: 'false-sub', claims: {sub: false}},
          {name: 'whitespace-sub', claims: {sub: '   '}},
          {name: 'undefined-like-string', claims: {sub: 'undefined'}},
          {name: 'null-string', claims: {sub: 'null'}},
          {name: 'proto-sub', claims: {sub: '__proto__'}},
          {name: 'constructor-sub', claims: {sub: 'constructor'}},
        ];

        for (const {name, claims} of edgeCases) {
          try {
            const token = await createTypeConfusionToken(TEST_SECRET, claims);

            const conn = connectSync({
              port: server.port,
              clientGroupID: TEST_CLIENT_GROUP,
              clientID: `edge-${name}`,
              userID: String(claims.sub ?? ''),
              authToken: token,
            });

            const outcome = await waitForConnection(conn, 3000);

            console.log(
              `[INFO] ${name}: ${outcome.type}`,
              outcome.type === 'closed' ? `(code: ${outcome.code})` : '',
            );

            conn.ws.close();
          } catch (e) {
            console.log(`[INFO] ${name}: error - ${String(e).slice(0, 50)}`);
          }
        }
      } finally {
        await server.cleanup();
      }
    });

    test('deeply nested claim access', async ({testDBs}) => {
      const server = await startPentestServer(testDBs, {
        adminPassword: 'test-password',
        nodeEnv: 'production',
        schemaMode: 'mutation-test',
        auth: {secret: TEST_SECRET},
      });

      try {
        // Test if deeply nested claims can be accessed
        const nestedToken = await createTypeConfusionToken(TEST_SECRET, {
          sub: 'nested-user',
          permissions: {
            tables: {
              admin_only: {
                write: true,
              },
            },
          },
          'role.admin': true, // Dot notation in key
          'role[0]': 'admin', // Array notation in key
        });

        const conn = connectSync({
          port: server.port,
          clientGroupID: TEST_CLIENT_GROUP,
          clientID: 'nested-client',
          userID: 'nested-user',
          authToken: nestedToken,
        });

        const outcome = await waitForConnection(conn, 5000);

        if (outcome.type === 'opened') {
          console.log(
            '[INFO] Nested claims token accepted - check if nested properties are accessible in policies',
          );
        }

        conn.ws.close();
      } finally {
        await server.cleanup();
      }
    });
  });

  // ===========================================================================
  // 2. Empty Policy Behavior
  // ===========================================================================
  describe('empty policy behavior', () => {
    test('mutation to table with no permissions defined', async ({testDBs}) => {
      // The mutation-test schema has readonly_table with only select permission
      // No insert/update/delete - should default to deny
      const server = await startPentestServer(testDBs, {
        adminPassword: 'test-password',
        nodeEnv: 'production',
        schemaMode: 'mutation-test',
        auth: {secret: TEST_SECRET},
      });

      try {
        const token = await createTypeConfusionToken(TEST_SECRET, {
          sub: 'empty-policy-user',
          role: 'admin',
        });

        const conn = connectSync({
          port: server.port,
          clientGroupID: TEST_CLIENT_GROUP,
          clientID: 'empty-policy-client',
          userID: 'empty-policy-user',
          authToken: token,
        });

        const outcome = await waitForConnection(conn, 5000);
        expect(outcome.type).toBe('opened');

        // Try to write to readonly_table (has no write permissions)
        const mutation = createInsertMutation(
          'empty-policy-client',
          1,
          'readonly_table',
          {id: 'empty-policy-bypass', value: 'should-be-blocked'},
        );
        conn.ws.send(
          JSON.stringify(createCRUDPushMessage(TEST_CLIENT_GROUP, [mutation])),
        );

        await new Promise(resolve => setTimeout(resolve, 2000));

        // Connection should stay open but mutation should be blocked
        console.log(
          '[INFO] Empty write policy test:',
          conn.ws.readyState === conn.ws.OPEN ? 'connection open (mutation may have been silently blocked)' : 'connection closed',
        );

        conn.ws.close();
      } finally {
        await server.cleanup();
      }
    });

    test('query to table with no read permissions', async ({testDBs}) => {
      // Note: This tests read permissions, not mutations
      // The multi-permission schema has 'unreadable' table with no rules
      const server = await startPentestServer(testDBs, {
        adminPassword: 'test-password',
        nodeEnv: 'production',
        schemaMode: 'multi-permission',
        auth: {secret: TEST_SECRET},
      });

      try {
        const token = await createTypeConfusionToken(TEST_SECRET, {
          sub: 'no-read-user',
          role: 'admin',
        });

        const conn = connectSync({
          port: server.port,
          clientGroupID: TEST_CLIENT_GROUP,
          clientID: 'no-read-client',
          userID: 'no-read-user',
          authToken: token,
        });

        const outcome = await waitForConnection(conn, 5000);

        if (outcome.type === 'opened') {
          console.log(
            '[INFO] Connected - queries to unreadable table should return empty results',
          );
        }

        conn.ws.close();
      } finally {
        await server.cleanup();
      }
    });
  });

  // ===========================================================================
  // 3. Undefined/Null AuthData Handling
  // ===========================================================================
  describe('undefined authData handling', () => {
    test('connection with no auth token', async ({testDBs}) => {
      const server = await startPentestServer(testDBs, {
        adminPassword: 'test-password',
        nodeEnv: 'production',
        schemaMode: 'mutation-test',
        auth: {secret: TEST_SECRET},
      });

      try {
        // Connect without any token
        const conn = connectSync({
          port: server.port,
          clientGroupID: TEST_CLIENT_GROUP,
          clientID: 'no-auth-client',
          userID: '',
          // No authToken
        });

        const outcome = await waitForConnection(conn, 5000);

        if (outcome.type === 'opened') {
          // Try to access auth-dependent table
          const mutation = createInsertMutation(
            'no-auth-client',
            1,
            'auth_required',
            {id: 'no-auth-test', value: 'should-fail', created_by: ''},
          );
          conn.ws.send(
            JSON.stringify(createCRUDPushMessage(TEST_CLIENT_GROUP, [mutation])),
          );

          await new Promise(resolve => setTimeout(resolve, 2000));

          console.log(
            '[INFO] No auth token - mutation to auth_required:',
            conn.ws.readyState === conn.ws.OPEN
              ? 'sent (should be blocked by authorizer)'
              : 'connection closed',
          );
        } else {
          console.log('[INFO] No auth token - connection rejected');
        }

        conn.ws.close();
      } finally {
        await server.cleanup();
      }
    });

    test('token with missing standard claims', async ({testDBs}) => {
      const server = await startPentestServer(testDBs, {
        adminPassword: 'test-password',
        nodeEnv: 'production',
        schemaMode: 'mutation-test',
        auth: {secret: TEST_SECRET},
      });

      try {
        // Token with no sub, iat, or exp (just bare minimum)
        const secretKey = new TextEncoder().encode(TEST_SECRET);
        const bareToken = await new SignJWT({})
          .setProtectedHeader({alg: 'HS256'})
          .sign(secretKey);

        const conn = connectSync({
          port: server.port,
          clientGroupID: TEST_CLIENT_GROUP,
          clientID: 'bare-token-client',
          userID: '',
          authToken: bareToken,
        });

        const outcome = await waitForOpenThenClose(conn, 5000);

        console.log('[INFO] Bare token (no claims) result:', outcome.type);
        if (outcome.type === 'openedThenClosed') {
          console.log('  Close code:', outcome.closeCode);
        }

        conn.ws.close();
      } finally {
        await server.cleanup();
      }
    });

    test('access authData field that does not exist', async ({testDBs}) => {
      const server = await startPentestServer(testDBs, {
        adminPassword: 'test-password',
        nodeEnv: 'production',
        schemaMode: 'mutation-test',
        auth: {secret: TEST_SECRET},
      });

      try {
        // Token with sub but no role
        const token = await createTypeConfusionToken(TEST_SECRET, {
          sub: 'no-role-user',
          // No 'role' claim
        });

        const conn = connectSync({
          port: server.port,
          clientGroupID: TEST_CLIENT_GROUP,
          clientID: 'no-role-client',
          userID: 'no-role-user',
          authToken: token,
        });

        const outcome = await waitForConnection(conn, 5000);

        if (outcome.type === 'opened') {
          // Try admin_only table (requires role = 'admin')
          // Since role is undefined, comparison should fail
          const mutation = createInsertMutation(
            'no-role-client',
            1,
            'admin_only',
            {id: 'no-role-bypass', secret: 'undefined-role'},
          );
          conn.ws.send(
            JSON.stringify(createCRUDPushMessage(TEST_CLIENT_GROUP, [mutation])),
          );

          await new Promise(resolve => setTimeout(resolve, 2000));

          console.log(
            '[INFO] Undefined role field:',
            conn.ws.readyState === conn.ws.OPEN
              ? 'open (mutation should be blocked)'
              : 'closed',
          );
        }

        conn.ws.close();
      } finally {
        await server.cleanup();
      }
    });
  });

  // ===========================================================================
  // 4. Policy Bypass Attempts
  // ===========================================================================
  describe('policy bypass attempts', () => {
    test('prototype pollution in authData claims', async ({testDBs}) => {
      const server = await startPentestServer(testDBs, {
        adminPassword: 'test-password',
        nodeEnv: 'production',
        schemaMode: 'mutation-test',
        auth: {secret: TEST_SECRET},
      });

      try {
        // Token with prototype pollution attempts
        const pollutionVariants: Array<{name: string; claims: Record<string, unknown>}> = [
          {name: 'proto', claims: {sub: 'proto-user', ['__proto__']: {role: 'admin'}}},
          {name: 'constructor', claims: {sub: 'cons-user', ['constructor']: {prototype: {role: 'admin'}}}},
          {name: 'proto-role', claims: {sub: 'pr-user', ['__proto__.role']: 'admin'}},
        ];

        for (const {name, claims} of pollutionVariants) {
          try {
            const token = await createTypeConfusionToken(TEST_SECRET, claims);

            const conn = connectSync({
              port: server.port,
              clientGroupID: TEST_CLIENT_GROUP,
              clientID: `pollution-${name}`,
              userID: claims.sub as string,
              authToken: token,
            });

            const outcome = await waitForConnection(conn, 3000);

            if (outcome.type === 'opened') {
              const mutation = createInsertMutation(
                `pollution-${name}`,
                1,
                'admin_only',
                {id: `pollution-${name}`, secret: 'polluted'},
              );
              conn.ws.send(
                JSON.stringify(createCRUDPushMessage(TEST_CLIENT_GROUP, [mutation])),
              );
              await new Promise(resolve => setTimeout(resolve, 1000));

              console.log(
                `[INFO] ${name}:`,
                conn.ws.readyState === conn.ws.OPEN ? 'open' : 'closed',
              );
            } else {
              console.log(`[INFO] ${name}: rejected at connection`);
            }

            conn.ws.close();
          } catch (e) {
            console.log(`[INFO] ${name}: error - ${String(e).slice(0, 50)}`);
          }
        }
      } finally {
        await server.cleanup();
      }
    });

    test('SQL injection in claim values', async ({testDBs}) => {
      const server = await startPentestServer(testDBs, {
        adminPassword: 'test-password',
        nodeEnv: 'production',
        schemaMode: 'mutation-test',
        auth: {secret: TEST_SECRET},
      });

      try {
        // SQL injection attempts in claim values
        const sqlInjections = [
          {name: 'or-true', claims: {sub: "' OR '1'='1", role: "admin' OR '1'='1"}},
          {name: 'union', claims: {sub: "' UNION SELECT * FROM admin_only --", role: 'admin'}},
          {name: 'comment', claims: {sub: 'admin --', role: 'admin'}},
          {name: 'semicolon', claims: {sub: "admin'; DROP TABLE admin_only; --", role: 'admin'}},
        ];

        for (const {name, claims} of sqlInjections) {
          try {
            const token = await createTypeConfusionToken(TEST_SECRET, claims);

            const conn = connectSync({
              port: server.port,
              clientGroupID: TEST_CLIENT_GROUP,
              clientID: `sqli-${name}`,
              userID: claims.sub,
              authToken: token,
            });

            const outcome = await waitForConnection(conn, 3000);

            console.log(
              `[INFO] SQL injection ${name}:`,
              outcome.type,
              outcome.type === 'closed' ? `(${outcome.code})` : '',
            );

            conn.ws.close();
          } catch (e) {
            console.log(`[INFO] SQL injection ${name}: error - ${String(e).slice(0, 50)}`);
          }
        }
      } finally {
        await server.cleanup();
      }
    });

    test('Unicode normalization in claim values', async ({testDBs}) => {
      const server = await startPentestServer(testDBs, {
        adminPassword: 'test-password',
        nodeEnv: 'production',
        schemaMode: 'mutation-test',
        auth: {secret: TEST_SECRET},
      });

      try {
        // Unicode variants that might normalize to "admin"
        const unicodeVariants = [
          {name: 'cyrillic-a', claims: {sub: 'u1', role: '\u0430dmin'}}, // Cyrillic 'а'
          {name: 'fullwidth', claims: {sub: 'u2', role: 'ａｄｍｉｎ'}}, // Fullwidth
          {name: 'combining', claims: {sub: 'u3', role: 'a\u0308dmin'}}, // Combining diaeresis
          {name: 'zero-width', claims: {sub: 'u4', role: 'ad\u200Bmin'}}, // Zero-width space
          {name: 'confusable', claims: {sub: 'u5', role: 'аdmіn'}}, // Mixed Cyrillic
        ];

        for (const {name, claims} of unicodeVariants) {
          try {
            const token = await createTypeConfusionToken(TEST_SECRET, claims);

            const conn = connectSync({
              port: server.port,
              clientGroupID: TEST_CLIENT_GROUP,
              clientID: `unicode-${name}`,
              userID: claims.sub,
              authToken: token,
            });

            const outcome = await waitForConnection(conn, 3000);

            if (outcome.type === 'opened') {
              const mutation = createInsertMutation(
                `unicode-${name}`,
                1,
                'admin_only',
                {id: `unicode-${name}`, secret: 'unicode-bypass'},
              );
              conn.ws.send(
                JSON.stringify(createCRUDPushMessage(TEST_CLIENT_GROUP, [mutation])),
              );
              await new Promise(resolve => setTimeout(resolve, 1000));

              // If mutation worked, the unicode role was treated as "admin"
              console.log(
                `[INFO] Unicode ${name} (${claims.role}):`,
                conn.ws.readyState === conn.ws.OPEN ? 'open' : 'closed',
              );
            } else {
              console.log(`[INFO] Unicode ${name}: rejected`);
            }

            conn.ws.close();
          } catch (e) {
            console.log(`[INFO] Unicode ${name}: error`);
          }
        }
      } finally {
        await server.cleanup();
      }
    });

    test('case sensitivity in role comparison', async ({testDBs}) => {
      const server = await startPentestServer(testDBs, {
        adminPassword: 'test-password',
        nodeEnv: 'production',
        schemaMode: 'mutation-test',
        auth: {secret: TEST_SECRET},
      });

      try {
        // Case variants of "admin"
        const caseVariants = ['Admin', 'ADMIN', 'aDmIn', 'ADmin', 'admiN'];

        for (const role of caseVariants) {
          const token = await createTypeConfusionToken(TEST_SECRET, {
            sub: `case-${role}`,
            role,
          });

          const conn = connectSync({
            port: server.port,
            clientGroupID: TEST_CLIENT_GROUP,
            clientID: `case-${role}`,
            userID: `case-${role}`,
            authToken: token,
          });

          const outcome = await waitForConnection(conn, 3000);

          if (outcome.type === 'opened') {
            const mutation = createInsertMutation(
              `case-${role}`,
              1,
              'admin_only',
              {id: `case-${role}`, secret: 'case-bypass'},
            );
            conn.ws.send(
              JSON.stringify(createCRUDPushMessage(TEST_CLIENT_GROUP, [mutation])),
            );
            await new Promise(resolve => setTimeout(resolve, 1000));

            console.log(
              `[INFO] Role "${role}":`,
              conn.ws.readyState === conn.ws.OPEN ? 'open' : 'closed',
            );
          }

          conn.ws.close();
        }
      } finally {
        await server.cleanup();
      }
    });
  });
});
