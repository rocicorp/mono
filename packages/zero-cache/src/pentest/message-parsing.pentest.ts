/**
 * Message Parsing Pentest Suite
 *
 * Tests for type confusion, resource exhaustion, Unicode edge cases,
 * and boundary conditions in WebSocket message handling.
 *
 * Target Components:
 * - JSON Parsing: connection.ts:186 (no depth limit)
 * - Base64 Decoding: connect.ts:83 (no size limit)
 * - Integer Parsing: url-params.ts:28 (no bounds check)
 * - Message Dispatch: syncer-ws-message-handler.ts:82-222
 * - Identifier Handling: mutagen.ts:382 (Unicode confusion)
 */

/* eslint-disable no-console */
// Console.log is used intentionally in pentest code to flag security findings
// oxlint-disable eslint-plugin-jest(no-conditional-expect)

import {describe, expect} from 'vitest';
import WebSocket from 'ws';
import {PROTOCOL_VERSION} from '../../../zero-protocol/src/protocol-version.ts';
import {encodeSecProtocols} from '../../../zero-protocol/src/connect.ts';
import {test} from '../test/db.ts';
import {startPentestServer} from './helpers/pentest-server.ts';
import {
  createConnection,
  closeAllConnections,
} from './helpers/state-machine-helpers.ts';
import {
  createDeeplyNestedObject,
  createDeeplyNestedArray,
  createDeeplyNestedJSON,
  createLargeBase64Payload,
  createMalformedBase64,
  createIntegerBoundaryValues,
  createUnicodeConfusionPayloads,
  createOversizedPush,
  createMutationWithManyOps,
  createOversizedQueryPatch,
  createTypeConfusionMessages,
  createInvalidMutationStructures,
  createSizeBoundaryMessages,
  createFieldSizeBoundaries,
  createMalformedProtocolHeaders,
  createQueryParamAttacks,
} from './helpers/message-parsing-helpers.ts';

describe('message parsing', {timeout: 120000}, () => {
  // ==========================================================================
  // JSON Depth DoS Testing
  // Target: connection.ts:186 - JSON.parse() has no depth limits
  // ==========================================================================
  describe('JSON depth DoS', () => {
    test('deeply nested objects (1000 levels)', async ({testDBs}) => {
      const server = await startPentestServer(testDBs, {
        adminPassword: 'test-password',
        nodeEnv: 'production',
      });

      try {
        const conn = createConnection({
          port: server.port,
          clientGroupID: 'test-cg',
          clientID: 'depth-test',
          wsID: 'depth-ws',
        });

        await conn.opened;

        // Send a deeply nested JSON object as a message
        const deepObject = createDeeplyNestedObject(1000);
        const malformedMessage = ['ping', deepObject];
        conn.ws.send(JSON.stringify(malformedMessage));

        // Wait for response or close
        await new Promise(r => setTimeout(r, 2000));

        // Connection should either:
        // 1. Still be open and functional (parsed successfully)
        // 2. Closed gracefully (rejected the message)
        // It should NOT: crash the server or hang
        if (conn.isOpen()) {
          // Verify connection is still responsive
          conn.send(['ping', {}]);
          const pong = await conn.waitForMessage('pong', 3000);
          if (!pong) {
            console.log(
              '[FINDING] Connection unresponsive after deep nested object',
            );
          }
        } else {
          const closeInfo = await conn.closed;
          // Graceful close is acceptable
          expect(closeInfo.code).toBeGreaterThanOrEqual(1000);
        }

        conn.close();
      } finally {
        await server.cleanup();
      }
    });

    test('deeply nested arrays (1000 levels)', async ({testDBs}) => {
      const server = await startPentestServer(testDBs, {
        adminPassword: 'test-password',
        nodeEnv: 'production',
      });

      try {
        const conn = createConnection({
          port: server.port,
          clientGroupID: 'test-cg',
          clientID: 'array-depth-test',
          wsID: 'array-depth-ws',
        });

        await conn.opened;

        const deepArray = createDeeplyNestedArray(1000);
        conn.ws.send(JSON.stringify(deepArray));

        await new Promise(r => setTimeout(r, 2000));

        // Verify server is still responsive
        if (conn.isOpen()) {
          conn.send(['ping', {}]);
          const pong = await conn.waitForMessage('pong', 3000);
          if (!pong) {
            console.log(
              '[FINDING] Connection unresponsive after deep nested array',
            );
          }
        }

        conn.close();
      } finally {
        await server.cleanup();
      }
    });

    test('deeply nested JSON string (5000 levels)', async ({testDBs}) => {
      const server = await startPentestServer(testDBs, {
        adminPassword: 'test-password',
        nodeEnv: 'production',
      });

      try {
        const conn = createConnection({
          port: server.port,
          clientGroupID: 'test-cg',
          clientID: 'json-depth-test',
          wsID: 'json-depth-ws',
        });

        await conn.opened;

        // Send raw JSON string with extreme nesting
        const deepJson = createDeeplyNestedJSON(5000);
        conn.ws.send(deepJson);

        await new Promise(r => setTimeout(r, 2000));

        // Server should handle gracefully
        if (conn.isOpen()) {
          conn.send(['ping', {}]);
          const pong = await conn.waitForMessage('pong', 3000);
          expect(pong).toBeDefined();
        }

        conn.close();
      } finally {
        await server.cleanup();
      }
    });

    test('server handles multiple deep nesting attacks', async ({testDBs}) => {
      const server = await startPentestServer(testDBs, {
        adminPassword: 'test-password',
        nodeEnv: 'production',
      });

      try {
        const conn = createConnection({
          port: server.port,
          clientGroupID: 'test-cg',
          clientID: 'multi-depth-test',
          wsID: 'multi-depth-ws',
        });

        await conn.opened;

        // Send multiple deeply nested messages rapidly
        for (let i = 0; i < 10; i++) {
          const deep = createDeeplyNestedObject(500 + i * 50);
          conn.ws.send(JSON.stringify(['ping', deep]));
        }

        await new Promise(r => setTimeout(r, 3000));

        // Server should still be responsive
        const testConn = createConnection({
          port: server.port,
          clientGroupID: 'test-cg-2',
          clientID: 'post-depth-test',
          wsID: 'post-depth-ws',
        });

        await testConn.opened;
        testConn.send(['ping', {}]);
        const pong = await testConn.waitForMessage('pong', 3000);
        expect(pong).toBeDefined();

        closeAllConnections([conn, testConn]);
      } finally {
        await server.cleanup();
      }
    });
  });

  // ==========================================================================
  // Base64 Header Testing
  // Target: connect.ts:83 - atob() expands without size checks
  // ==========================================================================
  describe('Base64 header attacks', () => {
    test('large base64 in sec-websocket-protocol (100KB)', async ({
      testDBs,
    }) => {
      const server = await startPentestServer(testDBs, {
        adminPassword: 'test-password',
        nodeEnv: 'production',
      });

      try {
        const url =
          `ws://localhost:${server.port}/sync/v${PROTOCOL_VERSION}/connect` +
          `?clientGroupID=test-cg&clientID=b64-test&wsid=b64-ws` +
          `&userID=&schemaVersion=1&baseCookie=&ts=${Date.now()}&lmid=0`;

        // Create large base64 payload
        const largeB64 = createLargeBase64Payload(100 * 1024);

        let connectionResult: 'opened' | 'error' | 'timeout' = 'timeout';

        try {
          const ws = new WebSocket(url, largeB64);

          const result = await new Promise<'opened' | 'error' | 'timeout'>(
            resolve => {
              const timeout = setTimeout(() => resolve('timeout'), 5000);
              ws.on('open', () => {
                clearTimeout(timeout);
                resolve('opened');
              });
              ws.on('error', () => {
                clearTimeout(timeout);
                resolve('error');
              });
            },
          );
          connectionResult = result;

          ws.close();
        } catch {
          connectionResult = 'error';
        }

        // Large base64 should be rejected or handled without crashing
        if (connectionResult === 'opened') {
          console.log(
            '[NOTE] Server accepted 100KB base64 protocol header - check for memory usage',
          );
        }

        // Server should still be responsive
        const testConn = createConnection({
          port: server.port,
          clientGroupID: 'test-cg',
          clientID: 'post-b64-test',
          wsID: 'post-b64-ws',
        });

        await testConn.opened;
        testConn.send(['ping', {}]);
        const pong = await testConn.waitForMessage('pong', 3000);
        expect(pong).toBeDefined();

        testConn.close();
      } finally {
        await server.cleanup();
      }
    });

    test('malformed base64 variants', async ({testDBs}) => {
      const server = await startPentestServer(testDBs, {
        adminPassword: 'test-password',
        nodeEnv: 'production',
      });

      try {
        const malformedVariants = createMalformedBase64();

        for (const variant of malformedVariants) {
          const url =
            `ws://localhost:${server.port}/sync/v${PROTOCOL_VERSION}/connect` +
            `?clientGroupID=test-cg&clientID=malformed-b64&wsid=malformed-ws` +
            `&userID=&schemaVersion=1&baseCookie=&ts=${Date.now()}&lmid=0`;

          try {
            const ws = new WebSocket(url, variant);

            await new Promise<void>(resolve => {
              const timeout = setTimeout(() => {
                ws.close();
                resolve();
              }, 2000);
              ws.on('open', () => {
                clearTimeout(timeout);
                ws.close();
                resolve();
              });
              ws.on('error', () => {
                clearTimeout(timeout);
                resolve();
              });
              ws.on('close', () => {
                clearTimeout(timeout);
                resolve();
              });
            });
          } catch {
            // Expected for malformed protocols
          }
        }

        // Server should still be responsive after malformed attempts
        const testConn = createConnection({
          port: server.port,
          clientGroupID: 'test-cg',
          clientID: 'post-malformed-test',
          wsID: 'post-malformed-ws',
        });

        await testConn.opened;
        testConn.send(['ping', {}]);
        const pong = await testConn.waitForMessage('pong', 3000);
        expect(pong).toBeDefined();

        testConn.close();
      } finally {
        await server.cleanup();
      }
    });

    test('malformed protocol header structures', async ({testDBs}) => {
      const server = await startPentestServer(testDBs, {
        adminPassword: 'test-password',
        nodeEnv: 'production',
      });

      try {
        const malformedHeaders = createMalformedProtocolHeaders();

        for (const [name, header] of Object.entries(malformedHeaders)) {
          if (!header) continue; // Skip empty

          const url =
            `ws://localhost:${server.port}/sync/v${PROTOCOL_VERSION}/connect` +
            `?clientGroupID=test-cg&clientID=header-test&wsid=header-ws-${name}` +
            `&userID=&schemaVersion=1&baseCookie=&ts=${Date.now()}&lmid=0`;

          try {
            const ws = new WebSocket(url, header);

            await new Promise<void>(resolve => {
              const timeout = setTimeout(() => {
                ws.close();
                resolve();
              }, 2000);
              ws.on('open', () => {
                clearTimeout(timeout);
                ws.close();
                resolve();
              });
              ws.on('error', () => {
                clearTimeout(timeout);
                resolve();
              });
              ws.on('close', () => {
                clearTimeout(timeout);
                resolve();
              });
            });
          } catch {
            // Expected for malformed
          }
        }

        // Server should still be responsive
        const testConn = createConnection({
          port: server.port,
          clientGroupID: 'test-cg',
          clientID: 'post-header-test',
          wsID: 'post-header-ws',
        });

        await testConn.opened;
        testConn.send(['ping', {}]);
        const pong = await testConn.waitForMessage('pong', 3000);
        expect(pong).toBeDefined();

        testConn.close();
      } finally {
        await server.cleanup();
      }
    });
  });

  // ==========================================================================
  // Integer Parsing Testing
  // Target: url-params.ts:28 - parseInt() without bounds
  // ==========================================================================
  describe('Integer overflow/coercion', () => {
    test('integer boundary values in URL params', async ({testDBs}) => {
      const server = await startPentestServer(testDBs, {
        adminPassword: 'test-password',
        nodeEnv: 'production',
      });

      try {
        const boundaryValues = createIntegerBoundaryValues();

        for (const [name, value] of Object.entries(boundaryValues)) {
          // Test in 'ts' parameter
          const url =
            `ws://localhost:${server.port}/sync/v${PROTOCOL_VERSION}/connect` +
            `?clientGroupID=test-cg&clientID=int-test-${name}&wsid=int-ws` +
            `&userID=&schemaVersion=1&baseCookie=&ts=${value}&lmid=0`;

          const protocol = encodeSecProtocols(undefined, undefined);

          try {
            const ws = new WebSocket(url, protocol);

            const result = await new Promise<'opened' | 'error' | 'closed'>(
              resolve => {
                const timeout = setTimeout(() => {
                  ws.close();
                  resolve('closed');
                }, 2000);
                ws.on('open', () => {
                  clearTimeout(timeout);
                  ws.close();
                  resolve('opened');
                });
                ws.on('error', () => {
                  clearTimeout(timeout);
                  resolve('error');
                });
                ws.on('close', () => {
                  clearTimeout(timeout);
                  resolve('closed');
                });
              },
            );

            // Log interesting results
            if (
              result === 'opened' &&
              (name === 'maxSafeIntegerPlus1' ||
                name === 'negativeOne' ||
                name === 'nan')
            ) {
              console.log(
                `[NOTE] ts=${value} (${name}) accepted - verify handling`,
              );
            }
          } catch {
            // Expected for invalid values
          }
        }

        // Server should still work
        const testConn = createConnection({
          port: server.port,
          clientGroupID: 'test-cg',
          clientID: 'post-int-test',
          wsID: 'post-int-ws',
        });

        await testConn.opened;
        testConn.send(['ping', {}]);
        const pong = await testConn.waitForMessage('pong', 3000);
        expect(pong).toBeDefined();

        testConn.close();
      } finally {
        await server.cleanup();
      }
    });

    test('integer boundary values in lmid param', async ({testDBs}) => {
      const server = await startPentestServer(testDBs, {
        adminPassword: 'test-password',
        nodeEnv: 'production',
      });

      try {
        const attacks = createQueryParamAttacks();

        for (const [name, params] of Object.entries(attacks)) {
          const url =
            `ws://localhost:${server.port}/sync/v${PROTOCOL_VERSION}/connect` +
            `?clientGroupID=test-cg&clientID=lmid-test-${name}&wsid=lmid-ws` +
            `&userID=&schemaVersion=1&baseCookie=` +
            `&ts=${params.ts}&lmid=${params.lmid}`;

          const protocol = encodeSecProtocols(undefined, undefined);

          try {
            const ws = new WebSocket(url, protocol);

            await new Promise<void>(resolve => {
              const timeout = setTimeout(() => {
                ws.close();
                resolve();
              }, 2000);
              ws.on('open', () => {
                clearTimeout(timeout);
                ws.close();
                resolve();
              });
              ws.on('error', () => {
                clearTimeout(timeout);
                resolve();
              });
              ws.on('close', () => {
                clearTimeout(timeout);
                resolve();
              });
            });
          } catch {
            // Expected for invalid
          }
        }

        // Verify server responsive
        const testConn = createConnection({
          port: server.port,
          clientGroupID: 'test-cg',
          clientID: 'post-lmid-test',
          wsID: 'post-lmid-ws',
        });

        await testConn.opened;
        expect(testConn.isOpen()).toBe(true);
        testConn.close();
      } finally {
        await server.cleanup();
      }
    });
  });

  // ==========================================================================
  // Unbounded Array/String Testing
  // Target: push.ts:104, syncer-ws-message-handler.ts:110
  // ==========================================================================
  describe('Unbounded array/string attacks', () => {
    test('push with many mutations (1000)', async ({testDBs}) => {
      const server = await startPentestServer(testDBs, {
        adminPassword: 'test-password',
        nodeEnv: 'production',
      });

      try {
        const conn = createConnection({
          port: server.port,
          clientGroupID: 'test-cg',
          clientID: 'many-mutations',
          wsID: 'many-mutations-ws',
        });

        await conn.opened;

        // Send push with 1000 mutations
        const push = createOversizedPush('many-mutations', 1000);
        conn.send(push);

        // Wait for processing
        await new Promise(r => setTimeout(r, 5000));

        // Server should handle gracefully (may reject or process)
        if (conn.isOpen()) {
          conn.send(['ping', {}]);
          const pong = await conn.waitForMessage('pong', 5000);
          if (!pong) {
            console.log(
              '[FINDING] Connection unresponsive after 1000 mutations',
            );
          }
        }

        conn.close();
      } finally {
        await server.cleanup();
      }
    });

    test('single mutation with many ops (10000)', async ({testDBs}) => {
      const server = await startPentestServer(testDBs, {
        adminPassword: 'test-password',
        nodeEnv: 'production',
      });

      try {
        const conn = createConnection({
          port: server.port,
          clientGroupID: 'test-cg',
          clientID: 'many-ops',
          wsID: 'many-ops-ws',
        });

        await conn.opened;

        // Send mutation with 10000 ops
        const push = createMutationWithManyOps('many-ops', 10000);
        conn.send(push);

        await new Promise(r => setTimeout(r, 5000));

        // Check responsiveness
        if (conn.isOpen()) {
          conn.send(['ping', {}]);
          const pong = await conn.waitForMessage('pong', 5000);
          if (!pong) {
            console.log('[FINDING] Connection unresponsive after 10000 ops');
          }
        }

        conn.close();
      } finally {
        await server.cleanup();
      }
    });

    test('changeDesiredQueries with many queries (5000)', async ({testDBs}) => {
      const server = await startPentestServer(testDBs, {
        adminPassword: 'test-password',
        nodeEnv: 'production',
      });

      try {
        const conn = createConnection({
          port: server.port,
          clientGroupID: 'test-cg',
          clientID: 'many-queries',
          wsID: 'many-queries-ws',
        });

        await conn.opened;

        // First init connection
        conn.send([
          'initConnection',
          {
            desiredQueriesPatch: [],
          },
        ]);

        await new Promise(r => setTimeout(r, 1000));

        // Then send 5000 queries
        const queries = createOversizedQueryPatch(5000);
        conn.send(queries);

        await new Promise(r => setTimeout(r, 5000));

        if (conn.isOpen()) {
          conn.send(['ping', {}]);
          const pong = await conn.waitForMessage('pong', 5000);
          if (!pong) {
            console.log('[FINDING] Connection unresponsive after 5000 queries');
          }
        }

        conn.close();
      } finally {
        await server.cleanup();
      }
    });

    test('oversized string fields', async ({testDBs}) => {
      const server = await startPentestServer(testDBs, {
        adminPassword: 'test-password',
        nodeEnv: 'production',
      });

      try {
        const conn = createConnection({
          port: server.port,
          clientGroupID: 'test-cg',
          clientID: 'oversized-string',
          wsID: 'oversized-string-ws',
        });

        await conn.opened;

        const fieldBoundaries = createFieldSizeBoundaries();

        for (const [name, message] of Object.entries(fieldBoundaries)) {
          conn.send(message);
          await new Promise(r => setTimeout(r, 500));

          if (!conn.isOpen()) {
            console.log(
              `[NOTE] Connection closed after sending ${name} message`,
            );
            break;
          }
        }

        if (conn.isOpen()) {
          conn.send(['ping', {}]);
          const pong = await conn.waitForMessage('pong', 3000);
          expect(pong).toBeDefined();
        }

        conn.close();
      } finally {
        await server.cleanup();
      }
    });
  });

  // ==========================================================================
  // Unicode Confusion Testing
  // Target: mutagen.ts:382 - Table names without normalization
  // ==========================================================================
  describe('Unicode confusion attacks', () => {
    test('Unicode homoglyphs in identifiers', async ({testDBs}) => {
      const server = await startPentestServer(testDBs, {
        adminPassword: 'test-password',
        nodeEnv: 'production',
      });

      try {
        const conn = createConnection({
          port: server.port,
          clientGroupID: 'test-cg',
          clientID: 'unicode-test',
          wsID: 'unicode-ws',
        });

        await conn.opened;

        // Initialize connection
        conn.send([
          'initConnection',
          {
            desiredQueriesPatch: [],
          },
        ]);

        await new Promise(r => setTimeout(r, 1000));

        const unicodePayloads = createUnicodeConfusionPayloads();

        // Test each Unicode confusion payload as a table name in a query
        for (const [name, unicodeName] of Object.entries(unicodePayloads)) {
          // Skip payloads that would break JSON
          if (name === 'nullByte' || name === 'invalidSurrogate') {
            continue;
          }

          try {
            conn.send([
              'changeDesiredQueries',
              {
                desiredQueriesPatch: [
                  {
                    op: 'put' as const,
                    hash: `unicode-query-${name}`,
                    ast: {
                      table: unicodeName,
                      orderBy: [['id', 'asc' as const]],
                    },
                    ttl: undefined,
                  },
                ],
              },
            ]);

            await new Promise(r => setTimeout(r, 200));

            if (!conn.isOpen()) {
              console.log(`[NOTE] Connection closed after ${name} identifier`);
              break;
            }
          } catch {
            // Some payloads may fail to serialize
          }
        }

        // Verify server still responsive
        if (conn.isOpen()) {
          conn.send(['ping', {}]);
          const pong = await conn.waitForMessage('pong', 3000);
          expect(pong).toBeDefined();
        }

        conn.close();
      } finally {
        await server.cleanup();
      }
    });

    test('Unicode in mutation table names', async ({testDBs}) => {
      const server = await startPentestServer(testDBs, {
        adminPassword: 'test-password',
        nodeEnv: 'production',
      });

      try {
        const conn = createConnection({
          port: server.port,
          clientGroupID: 'test-cg',
          clientID: 'unicode-mutation',
          wsID: 'unicode-mutation-ws',
        });

        await conn.opened;

        const unicodePayloads = createUnicodeConfusionPayloads();

        // Test Unicode in mutation table names
        for (const [name, unicodeName] of Object.entries(unicodePayloads)) {
          // Skip problematic payloads
          if (
            name === 'nullByte' ||
            name === 'invalidSurrogate' ||
            name === 'longUnicode'
          ) {
            continue;
          }

          try {
            conn.send([
              'push',
              {
                clientGroupID: 'test-cg',
                mutations: [
                  {
                    type: 'crud' as const,
                    id: 1,
                    clientID: 'unicode-mutation',
                    name: '_zero_crud',
                    args: [
                      {
                        ops: [
                          {
                            op: 'insert' as const,
                            tableName: unicodeName,
                            primaryKey: ['id'],
                            value: {id: 'test', value: 'test'},
                          },
                        ],
                      },
                    ],
                    timestamp: Date.now(),
                  },
                ],
                pushVersion: 1,
                schemaVersion: 1,
                timestamp: Date.now(),
                requestID: `unicode-${name}`,
              },
            ]);

            await new Promise(r => setTimeout(r, 200));
          } catch {
            // Expected to fail for invalid identifiers
          }
        }

        // Verify server responsive
        if (conn.isOpen()) {
          conn.send(['ping', {}]);
          const pong = await conn.waitForMessage('pong', 3000);
          expect(pong).toBeDefined();
        }

        conn.close();
      } finally {
        await server.cleanup();
      }
    });
  });

  // ==========================================================================
  // Type Confusion Testing
  // Target: syncer-ws-message-handler.ts:82-222
  // ==========================================================================
  describe('Type confusion attacks', () => {
    test('type confusion in message structure', async ({testDBs}) => {
      const server = await startPentestServer(testDBs, {
        adminPassword: 'test-password',
        nodeEnv: 'production',
      });

      try {
        const conn = createConnection({
          port: server.port,
          clientGroupID: 'test-cg',
          clientID: 'type-confusion',
          wsID: 'type-confusion-ws',
        });

        await conn.opened;

        const confusionMessages = createTypeConfusionMessages();

        for (let i = 0; i < confusionMessages.length; i++) {
          const msg = confusionMessages[i];
          try {
            const serialized = JSON.stringify(msg);
            conn.ws.send(serialized);
            await new Promise(r => setTimeout(r, 200));

            if (!conn.isOpen()) {
              console.log(
                `[NOTE] Connection closed after type confusion message #${i}`,
              );
              break;
            }
          } catch {
            // Some messages can't be serialized (circular, symbols, etc.)
          }
        }

        // Verify server responsive
        if (conn.isOpen()) {
          conn.send(['ping', {}]);
          const pong = await conn.waitForMessage('pong', 3000);
          expect(pong).toBeDefined();
        }

        conn.close();
      } finally {
        await server.cleanup();
      }
    });

    test('invalid mutation structures', async ({testDBs}) => {
      const server = await startPentestServer(testDBs, {
        adminPassword: 'test-password',
        nodeEnv: 'production',
      });

      try {
        const conn = createConnection({
          port: server.port,
          clientGroupID: 'test-cg',
          clientID: 'invalid-mutation',
          wsID: 'invalid-mutation-ws',
        });

        await conn.opened;

        const invalidMutations = createInvalidMutationStructures();

        for (let i = 0; i < invalidMutations.length; i++) {
          const msg = invalidMutations[i];
          try {
            const serialized = JSON.stringify(msg);
            conn.ws.send(serialized);
            await new Promise(r => setTimeout(r, 300));

            if (!conn.isOpen()) {
              console.log(
                `[NOTE] Connection closed after invalid mutation #${i}`,
              );
              break;
            }
          } catch {
            // Expected for some invalid structures
          }
        }

        // Verify server responsive
        if (conn.isOpen()) {
          conn.send(['ping', {}]);
          const pong = await conn.waitForMessage('pong', 3000);
          expect(pong).toBeDefined();
        }

        conn.close();
      } finally {
        await server.cleanup();
      }
    });

    test('prototype pollution attempts', async ({testDBs}) => {
      const server = await startPentestServer(testDBs, {
        adminPassword: 'test-password',
        nodeEnv: 'production',
      });

      try {
        const conn = createConnection({
          port: server.port,
          clientGroupID: 'test-cg',
          clientID: 'proto-pollution',
          wsID: 'proto-pollution-ws',
        });

        await conn.opened;

        // Try various prototype pollution payloads
        const pollutionAttempts = [
          // Direct __proto__
          ['push', {__proto__: {admin: true}, clientGroupID: 'test-cg'}],
          // Constructor prototype
          [
            'push',
            {constructor: {prototype: {admin: true}}, clientGroupID: 'test-cg'},
          ],
          // Nested __proto__
          [
            'push',
            {
              clientGroupID: 'test-cg',
              mutations: [{__proto__: {polluted: true}}],
            },
          ],
          // In args
          [
            'push',
            {
              clientGroupID: 'test-cg',
              mutations: [
                {
                  type: 'custom',
                  id: 1,
                  clientID: 'c',
                  name: '__proto__',
                  args: [{polluted: true}],
                  timestamp: Date.now(),
                },
              ],
              pushVersion: 1,
              schemaVersion: 1,
              timestamp: Date.now(),
              requestID: 'proto-test',
            },
          ],
        ];

        for (const msg of pollutionAttempts) {
          conn.ws.send(JSON.stringify(msg));
          await new Promise(r => setTimeout(r, 300));
        }

        // Verify server responsive and not polluted
        if (conn.isOpen()) {
          conn.send(['ping', {}]);
          const pong = await conn.waitForMessage('pong', 3000);
          expect(pong).toBeDefined();
        }

        conn.close();
      } finally {
        await server.cleanup();
      }
    });
  });

  // ==========================================================================
  // Size Boundary Testing
  // Target: WebSocket message handling
  // ==========================================================================
  describe('Size boundary attacks', () => {
    test('messages at WebSocket frame boundaries', async ({testDBs}) => {
      const server = await startPentestServer(testDBs, {
        adminPassword: 'test-password',
        nodeEnv: 'production',
      });

      try {
        const conn = createConnection({
          port: server.port,
          clientGroupID: 'test-cg',
          clientID: 'size-boundary',
          wsID: 'size-boundary-ws',
        });

        await conn.opened;

        const boundaryMessages = createSizeBoundaryMessages();

        for (const [name, message] of Object.entries(boundaryMessages)) {
          // Skip empty/invalid JSON that would cause errors
          if (
            name === 'empty' ||
            name === 'whitespaceOnly' ||
            name === 'partialJson' ||
            name === 'unclosedString' ||
            name === 'unclosedArray'
          ) {
            // Test these separately as raw strings
            conn.ws.send(message);
            await new Promise(r => setTimeout(r, 200));
            continue;
          }

          conn.ws.send(message);
          await new Promise(r => setTimeout(r, 200));

          if (!conn.isOpen()) {
            console.log(`[NOTE] Connection closed after ${name} message`);
            break;
          }
        }

        // Verify server responsive
        if (conn.isOpen()) {
          conn.send(['ping', {}]);
          const pong = await conn.waitForMessage('pong', 3000);
          expect(pong).toBeDefined();
        }

        conn.close();
      } finally {
        await server.cleanup();
      }
    });

    test('malformed JSON variants', async ({testDBs}) => {
      const server = await startPentestServer(testDBs, {
        adminPassword: 'test-password',
        nodeEnv: 'production',
      });

      try {
        const conn = createConnection({
          port: server.port,
          clientGroupID: 'test-cg',
          clientID: 'malformed-json',
          wsID: 'malformed-json-ws',
        });

        await conn.opened;

        const malformedJson = [
          // Not JSON at all
          'not json',
          // Truncated
          '{"trunc',
          // Trailing comma
          '["ping", {}],',
          // Double comma
          '["ping",, {}]',
          // Unquoted key
          '[ping, {}]',
          // Single quotes
          "['ping', {}]",
          // Trailing junk
          '["ping", {}] extra',
          // BOM character
          '\uFEFF["ping", {}]',
          // Null bytes
          '["ping", {}\x00]',
          // Very long string key
          `{"${'x'.repeat(100000)}": "value"}`,
          // Deeply recursive but valid
          '{"a":'.repeat(100) + '1' + '}'.repeat(100),
        ];

        for (const json of malformedJson) {
          conn.ws.send(json);
          await new Promise(r => setTimeout(r, 200));

          if (!conn.isOpen()) {
            // Reconnect
            break;
          }
        }

        // Server should be responsive
        const testConn = createConnection({
          port: server.port,
          clientGroupID: 'test-cg-2',
          clientID: 'post-malformed',
          wsID: 'post-malformed-ws',
        });

        await testConn.opened;
        testConn.send(['ping', {}]);
        const pong = await testConn.waitForMessage('pong', 3000);
        expect(pong).toBeDefined();

        closeAllConnections([conn, testConn]);
      } finally {
        await server.cleanup();
      }
    });

    test('empty and minimal messages', async ({testDBs}) => {
      const server = await startPentestServer(testDBs, {
        adminPassword: 'test-password',
        nodeEnv: 'production',
      });

      try {
        const conn = createConnection({
          port: server.port,
          clientGroupID: 'test-cg',
          clientID: 'empty-msg',
          wsID: 'empty-msg-ws',
        });

        await conn.opened;

        // Various empty/minimal messages
        const minimalMessages = [
          '', // Empty
          '[]', // Empty array
          '{}', // Empty object
          'null', // Null
          '0', // Number
          'true', // Boolean
          '""', // Empty string
          '[[]]', // Nested empty
          '[null]', // Array with null
          '[""]', // Array with empty string
        ];

        for (const msg of minimalMessages) {
          conn.ws.send(msg);
          await new Promise(r => setTimeout(r, 200));
        }

        // Should still be responsive
        if (conn.isOpen()) {
          conn.send(['ping', {}]);
          const pong = await conn.waitForMessage('pong', 3000);
          expect(pong).toBeDefined();
        }

        conn.close();
      } finally {
        await server.cleanup();
      }
    });
  });

  // ==========================================================================
  // Production JSON Validation Bypass Testing
  // Target: config.ts:9 - skipAssertJSONValue in production
  // ==========================================================================
  describe('Production JSON validation bypass', () => {
    test('deeply nested JSON in production mode', async ({testDBs}) => {
      // This test specifically targets the fact that JSON validation
      // is bypassed in production mode (skipAssertJSONValue = true)
      const server = await startPentestServer(testDBs, {
        adminPassword: 'test-password',
        nodeEnv: 'production', // Critical: production mode
      });

      try {
        const conn = createConnection({
          port: server.port,
          clientGroupID: 'test-cg',
          clientID: 'prod-json-test',
          wsID: 'prod-json-ws',
        });

        await conn.opened;

        // In production, isJSONValue validation is skipped
        // This means deeply nested JSON goes through unvalidated
        const deepNested = createDeeplyNestedObject(500);
        const pushWithDeep = [
          'push',
          {
            clientGroupID: 'test-cg',
            mutations: [
              {
                type: 'custom' as const,
                id: 1,
                clientID: 'prod-json-test',
                name: 'testMutation',
                args: [deepNested], // Deep nesting in args
                timestamp: Date.now(),
              },
            ],
            pushVersion: 1,
            schemaVersion: 1,
            timestamp: Date.now(),
            requestID: 'deep-prod-test',
          },
        ];

        conn.ws.send(JSON.stringify(pushWithDeep));

        await new Promise(r => setTimeout(r, 2000));

        // Server should handle without crash
        if (conn.isOpen()) {
          conn.send(['ping', {}]);
          const pong = await conn.waitForMessage('pong', 3000);
          expect(pong).toBeDefined();
        }

        conn.close();
      } finally {
        await server.cleanup();
      }
    });
  });
});
