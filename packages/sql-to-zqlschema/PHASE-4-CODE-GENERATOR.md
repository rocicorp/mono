# Phase 4: Code Generator

## Goal

Build the code generator that produces valid Zero schema TypeScript code from the mapped tables and inferred relationships. This is the final phase that ties everything together.

## Prerequisites

- Phase 1 complete (introspection)
- Phase 2 complete (type mapping)
- Phase 3 complete (relationship inference)

## Files to Create/Modify

```
packages/sql-to-zqlschema/
├── src/
│   ├── code-generator.ts     # Code generation logic
│   ├── index.ts              # Public API exports
│   └── cli.ts                # CLI entry point (optional)
├── test/
│   ├── code-generator.test.ts    # Unit tests
│   └── integration.pg.test.ts    # Full integration test
```

## Implementation Plan

### Step 1: Extend Types (`src/types.ts`)

```typescript
/**
 * Code generator options
 */
export interface CodeGeneratorOptions {
  /** Include relationship definitions (default: true) */
  includeRelationships?: boolean;

  /** How to handle enums: 'enumeration' uses enumeration<T>(), 'string' uses string() */
  enumStyle?: 'enumeration' | 'string';

  /** Name for the exported schema constant (default: 'schema') */
  exportName?: string;

  /** Generate TypeScript types for tables (default: false) */
  includeTypes?: boolean;

  /** Add the createBuilder export (default: true) */
  includeBuilder?: boolean;

  /** Schema name for .from() mapping (default: omit if 'public') */
  schemaName?: string;

  /** Custom header comment */
  headerComment?: string;

  /** Import path for @rocicorp/zero (default: '@rocicorp/zero') */
  zeroImportPath?: string;
}

/**
 * Complete input for code generation
 */
export interface CodeGeneratorInput {
  tables: MappedTable[];
  enums: IntrospectedEnum[];
  relationships: TableRelationships[];
  schemaName: string;
}
```

### Step 2: Code Generator (`src/code-generator.ts`)

```typescript
import type {
  CodeGeneratorOptions,
  CodeGeneratorInput,
  MappedTable,
  MappedColumn,
  IntrospectedEnum,
  TableRelationships,
  InferredRelationship,
} from './types.ts';

const DEFAULT_OPTIONS: Required<CodeGeneratorOptions> = {
  includeRelationships: true,
  enumStyle: 'enumeration',
  exportName: 'schema',
  includeTypes: false,
  includeBuilder: true,
  schemaName: 'public',
  headerComment: '// Generated by sql-to-zqlschema - DO NOT EDIT',
  zeroImportPath: '@rocicorp/zero',
};

/**
 * Generate Zero schema TypeScript code
 */
export function generateCode(
  input: CodeGeneratorInput,
  options: CodeGeneratorOptions = {},
): string {
  const opts = {...DEFAULT_OPTIONS, ...options};
  const parts: string[] = [];

  // Header comment
  if (opts.headerComment) {
    parts.push(opts.headerComment);
    parts.push('');
  }

  // Imports
  parts.push(generateImports(input, opts));
  parts.push('');

  // Enum types (if using enumeration style)
  if (opts.enumStyle === 'enumeration' && input.enums.length > 0) {
    parts.push(generateEnumTypes(input.enums));
    parts.push('');
  }

  // Table definitions
  parts.push('// Table definitions');
  for (const table of input.tables) {
    parts.push(generateTable(table, input.enums, opts));
    parts.push('');
  }

  // Relationship definitions
  if (opts.includeRelationships && input.relationships.length > 0) {
    parts.push('// Relationships');
    for (const tableRels of input.relationships) {
      parts.push(generateRelationships(tableRels, input.tables));
      parts.push('');
    }
  }

  // Schema export
  parts.push(generateSchemaExport(input, opts));

  // Builder export
  if (opts.includeBuilder) {
    parts.push('');
    parts.push(`export const builder = createBuilder(${opts.exportName});`);
  }

  return parts.join('\n');
}

function generateImports(
  input: CodeGeneratorInput,
  opts: Required<CodeGeneratorOptions>,
): string {
  const imports: string[] = [];

  // Always needed
  imports.push('createSchema');
  imports.push('table');

  // Column types used
  const usedTypes = new Set<string>();
  for (const table of input.tables) {
    for (const col of table.columns) {
      usedTypes.add(col.zeroType);
      if (col.isEnum && opts.enumStyle === 'enumeration') {
        usedTypes.add('enumeration');
      }
    }
  }

  if (usedTypes.has('string')) imports.push('string');
  if (usedTypes.has('number')) imports.push('number');
  if (usedTypes.has('boolean')) imports.push('boolean');
  if (usedTypes.has('json')) imports.push('json');
  if (usedTypes.has('enumeration')) imports.push('enumeration');

  // Relationships
  if (opts.includeRelationships && input.relationships.length > 0) {
    imports.push('relationships');
  }

  // Builder
  if (opts.includeBuilder) {
    imports.push('createBuilder');
  }

  imports.sort();

  return `import {\n  ${imports.join(',\n  ')},\n} from '${opts.zeroImportPath}';`;
}

function generateEnumTypes(enums: IntrospectedEnum[]): string {
  const lines: string[] = ['// Enum types'];

  for (const e of enums) {
    const typeName = pascalCase(e.name);
    const values = e.values.map(v => `'${escapeString(v)}'`).join(' | ');
    lines.push(`type ${typeName} = ${values};`);
  }

  return lines.join('\n');
}

function generateTable(
  table: MappedTable,
  enums: IntrospectedEnum[],
  opts: Required<CodeGeneratorOptions>,
): string {
  const lines: string[] = [];

  // Table variable declaration
  lines.push(
    `const ${camelCase(table.name)} = table('${escapeString(table.name)}')`,
  );

  // .from() for non-public schemas
  if (opts.schemaName !== 'public') {
    lines.push(`  .from('${opts.schemaName}.${escapeString(table.name)}')`);
  }

  // .columns()
  lines.push('  .columns({');

  for (const col of table.columns) {
    const colDef = generateColumn(col, enums, opts);
    lines.push(`    ${col.name}: ${colDef},`);
  }

  lines.push('  })');

  // .primaryKey()
  const pkArgs = table.primaryKey.map(k => `'${escapeString(k)}'`).join(', ');
  lines.push(`  .primaryKey(${pkArgs});`);

  return lines.join('\n');
}

function generateColumn(
  col: MappedColumn,
  enums: IntrospectedEnum[],
  opts: Required<CodeGeneratorOptions>,
): string {
  let colType: string;

  if (col.isEnum && opts.enumStyle === 'enumeration') {
    const typeName = pascalCase(col.enumName!);
    colType = `enumeration<${typeName}>()`;
  } else {
    colType = `${col.zeroType}()`;
  }

  if (col.isOptional) {
    colType += '.optional()';
  }

  return colType;
}

function generateRelationships(
  tableRels: TableRelationships,
  tables: MappedTable[],
): string {
  const tableName = camelCase(tableRels.sourceTable);
  const lines: string[] = [];

  // Determine which relationship functions are needed
  const hasOne = tableRels.relationships.some(
    r => r.cardinality === 'one' && !r.through,
  );
  const hasMany = tableRels.relationships.some(
    r => r.cardinality === 'many' || r.through,
  );

  const destructure: string[] = [];
  if (hasOne) destructure.push('one');
  if (hasMany) destructure.push('many');

  lines.push(
    `const ${tableName}Relationships = relationships(${tableName}, ({${destructure.join(', ')}}) => ({`,
  );

  for (const rel of tableRels.relationships) {
    lines.push(`  ${rel.name}: ${generateRelationship(rel, tables)},`);
  }

  lines.push('}));');

  return lines.join('\n');
}

function generateRelationship(
  rel: InferredRelationship,
  tables: MappedTable[],
): string {
  const destTableVar = camelCase(rel.destTable);

  if (rel.through) {
    // Many-to-many through junction table
    const junctionTableVar = camelCase(rel.through.junctionTable);

    return `many(
    {
      sourceField: [${rel.sourceFields.map(f => `'${f}'`).join(', ')}],
      destField: [${rel.through.junctionSourceFields.map(f => `'${f}'`).join(', ')}],
      destSchema: ${junctionTableVar},
    },
    {
      sourceField: [${rel.through.junctionDestFields.map(f => `'${f}'`).join(', ')}],
      destField: [${rel.destFields.map(f => `'${f}'`).join(', ')}],
      destSchema: ${destTableVar},
    },
  )`;
  }

  const fn = rel.cardinality === 'one' ? 'one' : 'many';

  return `${fn}({
    sourceField: [${rel.sourceFields.map(f => `'${f}'`).join(', ')}],
    destField: [${rel.destFields.map(f => `'${f}'`).join(', ')}],
    destSchema: ${destTableVar},
  })`;
}

function generateSchemaExport(
  input: CodeGeneratorInput,
  opts: Required<CodeGeneratorOptions>,
): string {
  const tableVars = input.tables.map(t => camelCase(t.name));
  const relVars = input.relationships.map(
    r => `${camelCase(r.sourceTable)}Relationships`,
  );

  const lines: string[] = [];
  lines.push(`export const ${opts.exportName} = createSchema({`);
  lines.push(`  tables: [${tableVars.join(', ')}],`);

  if (opts.includeRelationships && relVars.length > 0) {
    lines.push(`  relationships: [${relVars.join(', ')}],`);
  }

  lines.push('});');

  return lines.join('\n');
}

// Utility functions

function camelCase(str: string): string {
  return str
    .replace(/[-_]([a-z])/g, (_, letter) => letter.toUpperCase())
    .replace(/^[A-Z]/, letter => letter.toLowerCase());
}

function pascalCase(str: string): string {
  const camel = camelCase(str);
  return camel.charAt(0).toUpperCase() + camel.slice(1);
}

function escapeString(str: string): string {
  return str.replace(/\\/g, '\\\\').replace(/'/g, "\\'");
}
```

### Step 3: Public API (`src/index.ts`)

```typescript
// Types
export type {
  IntrospectedSchema,
  IntrospectedTable,
  IntrospectedColumn,
  IntrospectedEnum,
  IntrospectedForeignKey,
  IntrospectedUniqueConstraint,
  IntrospectOptions,
  MappedTable,
  MappedColumn,
  TypeMapperOptions,
  InferredRelationship,
  TableRelationships,
  RelationshipInferrerOptions,
  CodeGeneratorOptions,
  CodeGeneratorInput,
} from './types.ts';

// Functions
export {introspect} from './introspector.ts';
export {
  mapSchema,
  mapTable,
  mapColumn,
  mapPgTypeToZero,
} from './type-mapper.ts';
export {
  inferRelationships,
  isOneToOneRelationship,
} from './relationship-inferrer.ts';
export {generateCode} from './code-generator.ts';

/**
 * High-level API: Generate Zero schema from PostgreSQL connection
 */
export async function generateSchemaFromDatabase(
  options: IntrospectOptions &
    TypeMapperOptions &
    RelationshipInferrerOptions &
    CodeGeneratorOptions,
): Promise<string> {
  // Step 1: Introspect
  const introspected = await introspect(options);

  // Step 2: Map types
  const mapped = mapSchema(introspected, options);

  // Log warnings
  if (mapped.warnings.length > 0) {
    for (const w of mapped.warnings) {
      console.warn(`Warning: ${w.table}.${w.column}: ${w.message}`);
    }
  }

  // Step 3: Infer relationships
  const relationships = inferRelationships(introspected, options);

  // Step 4: Generate code
  const code = generateCode(
    {
      tables: mapped.tables,
      enums: mapped.enums,
      relationships,
      schemaName: introspected.schemaName,
    },
    options,
  );

  return code;
}
```

### Step 4: Unit Tests (`test/code-generator.test.ts`)

```typescript
import {describe, test, expect} from 'vitest';
import {generateCode} from '../src/code-generator.ts';
import type {CodeGeneratorInput} from '../src/types.ts';

const makeInput = (
  overrides: Partial<CodeGeneratorInput> = {},
): CodeGeneratorInput => ({
  schemaName: 'public',
  tables: [],
  enums: [],
  relationships: [],
  ...overrides,
});

describe('generateCode', () => {
  describe('imports', () => {
    test('generates minimal imports for simple schema', () => {
      const input = makeInput({
        tables: [
          {
            schema: 'public',
            name: 'users',
            columns: [
              {
                name: 'id',
                zeroType: 'string',
                isOptional: false,
                isEnum: false,
                enumName: null,
                enumValues: null,
                pgType: 'text',
                warnings: [],
              },
            ],
            primaryKey: ['id'],
          },
        ],
      });

      const code = generateCode(input, {
        includeRelationships: false,
        includeBuilder: false,
      });

      expect(code).toContain('import {');
      expect(code).toContain('createSchema');
      expect(code).toContain('string');
      expect(code).toContain('table');
      expect(code).not.toContain('number');
      expect(code).not.toContain('relationships');
    });

    test('includes all used types', () => {
      const input = makeInput({
        tables: [
          {
            schema: 'public',
            name: 'test',
            columns: [
              {
                name: 'id',
                zeroType: 'string',
                isOptional: false,
                isEnum: false,
                enumName: null,
                enumValues: null,
                pgType: 'text',
                warnings: [],
              },
              {
                name: 'count',
                zeroType: 'number',
                isOptional: true,
                isEnum: false,
                enumName: null,
                enumValues: null,
                pgType: 'integer',
                warnings: [],
              },
              {
                name: 'active',
                zeroType: 'boolean',
                isOptional: false,
                isEnum: false,
                enumName: null,
                enumValues: null,
                pgType: 'boolean',
                warnings: [],
              },
              {
                name: 'data',
                zeroType: 'json',
                isOptional: true,
                isEnum: false,
                enumName: null,
                enumValues: null,
                pgType: 'jsonb',
                warnings: [],
              },
            ],
            primaryKey: ['id'],
          },
        ],
      });

      const code = generateCode(input, {includeRelationships: false});

      expect(code).toContain('string');
      expect(code).toContain('number');
      expect(code).toContain('boolean');
      expect(code).toContain('json');
    });
  });

  describe('table definitions', () => {
    test('generates basic table', () => {
      const input = makeInput({
        tables: [
          {
            schema: 'public',
            name: 'users',
            columns: [
              {
                name: 'id',
                zeroType: 'string',
                isOptional: false,
                isEnum: false,
                enumName: null,
                enumValues: null,
                pgType: 'text',
                warnings: [],
              },
              {
                name: 'name',
                zeroType: 'string',
                isOptional: true,
                isEnum: false,
                enumName: null,
                enumValues: null,
                pgType: 'text',
                warnings: [],
              },
            ],
            primaryKey: ['id'],
          },
        ],
      });

      const code = generateCode(input, {includeRelationships: false});

      expect(code).toContain("const users = table('users')");
      expect(code).toContain('id: string()');
      expect(code).toContain('name: string().optional()');
      expect(code).toContain(".primaryKey('id')");
    });

    test('generates composite primary key', () => {
      const input = makeInput({
        tables: [
          {
            schema: 'public',
            name: 'userRoles',
            columns: [
              {
                name: 'userID',
                zeroType: 'string',
                isOptional: false,
                isEnum: false,
                enumName: null,
                enumValues: null,
                pgType: 'text',
                warnings: [],
              },
              {
                name: 'roleID',
                zeroType: 'string',
                isOptional: false,
                isEnum: false,
                enumName: null,
                enumValues: null,
                pgType: 'text',
                warnings: [],
              },
            ],
            primaryKey: ['userID', 'roleID'],
          },
        ],
      });

      const code = generateCode(input, {includeRelationships: false});

      expect(code).toContain(".primaryKey('userID', 'roleID')");
    });

    test('generates enumeration columns', () => {
      const input = makeInput({
        tables: [
          {
            schema: 'public',
            name: 'users',
            columns: [
              {
                name: 'id',
                zeroType: 'string',
                isOptional: false,
                isEnum: false,
                enumName: null,
                enumValues: null,
                pgType: 'text',
                warnings: [],
              },
              {
                name: 'role',
                zeroType: 'string',
                isOptional: false,
                isEnum: true,
                enumName: 'user_role',
                enumValues: ['admin', 'user'],
                pgType: 'user_role',
                warnings: [],
              },
            ],
            primaryKey: ['id'],
          },
        ],
        enums: [
          {schema: 'public', name: 'user_role', values: ['admin', 'user']},
        ],
      });

      const code = generateCode(input, {enumStyle: 'enumeration'});

      expect(code).toContain("type UserRole = 'admin' | 'user';");
      expect(code).toContain('role: enumeration<UserRole>()');
    });

    test('generates string for enums when enumStyle is string', () => {
      const input = makeInput({
        tables: [
          {
            schema: 'public',
            name: 'users',
            columns: [
              {
                name: 'id',
                zeroType: 'string',
                isOptional: false,
                isEnum: false,
                enumName: null,
                enumValues: null,
                pgType: 'text',
                warnings: [],
              },
              {
                name: 'role',
                zeroType: 'string',
                isOptional: false,
                isEnum: true,
                enumName: 'user_role',
                enumValues: ['admin', 'user'],
                pgType: 'user_role',
                warnings: [],
              },
            ],
            primaryKey: ['id'],
          },
        ],
        enums: [
          {schema: 'public', name: 'user_role', values: ['admin', 'user']},
        ],
      });

      const code = generateCode(input, {enumStyle: 'string'});

      expect(code).not.toContain('type UserRole');
      expect(code).toContain('role: string()');
    });
  });

  describe('relationships', () => {
    test('generates one relationship', () => {
      const input = makeInput({
        tables: [
          {
            schema: 'public',
            name: 'users',
            columns: [
              {
                name: 'id',
                zeroType: 'string',
                isOptional: false,
                isEnum: false,
                enumName: null,
                enumValues: null,
                pgType: 'text',
                warnings: [],
              },
            ],
            primaryKey: ['id'],
          },
          {
            schema: 'public',
            name: 'posts',
            columns: [
              {
                name: 'id',
                zeroType: 'string',
                isOptional: false,
                isEnum: false,
                enumName: null,
                enumValues: null,
                pgType: 'text',
                warnings: [],
              },
              {
                name: 'authorID',
                zeroType: 'string',
                isOptional: false,
                isEnum: false,
                enumName: null,
                enumValues: null,
                pgType: 'text',
                warnings: [],
              },
            ],
            primaryKey: ['id'],
          },
        ],
        relationships: [
          {
            sourceTable: 'posts',
            relationships: [
              {
                sourceTable: 'posts',
                name: 'author',
                cardinality: 'one',
                sourceFields: ['authorID'],
                destTable: 'users',
                destFields: ['id'],
              },
            ],
          },
        ],
      });

      const code = generateCode(input);

      expect(code).toContain(
        'const postsRelationships = relationships(posts, ({one}) => ({',
      );
      expect(code).toContain('author: one({');
      expect(code).toContain("sourceField: ['authorID']");
      expect(code).toContain("destField: ['id']");
      expect(code).toContain('destSchema: users');
    });

    test('generates many-to-many through junction', () => {
      const input = makeInput({
        tables: [
          {
            schema: 'public',
            name: 'users',
            columns: [
              {
                name: 'id',
                zeroType: 'string',
                isOptional: false,
                isEnum: false,
                enumName: null,
                enumValues: null,
                pgType: 'text',
                warnings: [],
              },
            ],
            primaryKey: ['id'],
          },
          {
            schema: 'public',
            name: 'roles',
            columns: [
              {
                name: 'id',
                zeroType: 'string',
                isOptional: false,
                isEnum: false,
                enumName: null,
                enumValues: null,
                pgType: 'text',
                warnings: [],
              },
            ],
            primaryKey: ['id'],
          },
          {
            schema: 'public',
            name: 'userRoles',
            columns: [
              {
                name: 'userID',
                zeroType: 'string',
                isOptional: false,
                isEnum: false,
                enumName: null,
                enumValues: null,
                pgType: 'text',
                warnings: [],
              },
              {
                name: 'roleID',
                zeroType: 'string',
                isOptional: false,
                isEnum: false,
                enumName: null,
                enumValues: null,
                pgType: 'text',
                warnings: [],
              },
            ],
            primaryKey: ['userID', 'roleID'],
          },
        ],
        relationships: [
          {
            sourceTable: 'users',
            relationships: [
              {
                sourceTable: 'users',
                name: 'roles',
                cardinality: 'many',
                sourceFields: ['id'],
                destTable: 'roles',
                destFields: ['id'],
                through: {
                  junctionTable: 'userRoles',
                  junctionSourceFields: ['userID'],
                  junctionDestFields: ['roleID'],
                },
              },
            ],
          },
        ],
      });

      const code = generateCode(input);

      expect(code).toContain('roles: many(');
      expect(code).toContain('destSchema: userRoles');
      expect(code).toContain('destSchema: roles');
    });
  });

  describe('schema export', () => {
    test('exports schema with tables and relationships', () => {
      const input = makeInput({
        tables: [
          {
            schema: 'public',
            name: 'users',
            columns: [
              {
                name: 'id',
                zeroType: 'string',
                isOptional: false,
                isEnum: false,
                enumName: null,
                enumValues: null,
                pgType: 'text',
                warnings: [],
              },
            ],
            primaryKey: ['id'],
          },
        ],
        relationships: [
          {
            sourceTable: 'users',
            relationships: [],
          },
        ],
      });

      const code = generateCode(input, {exportName: 'mySchema'});

      expect(code).toContain('export const mySchema = createSchema({');
      expect(code).toContain('tables: [users]');
      expect(code).toContain('relationships: [usersRelationships]');
    });

    test('exports builder', () => {
      const input = makeInput({
        tables: [
          {
            schema: 'public',
            name: 'test',
            columns: [
              {
                name: 'id',
                zeroType: 'string',
                isOptional: false,
                isEnum: false,
                enumName: null,
                enumValues: null,
                pgType: 'text',
                warnings: [],
              },
            ],
            primaryKey: ['id'],
          },
        ],
      });

      const code = generateCode(input, {
        includeBuilder: true,
        exportName: 'schema',
      });

      expect(code).toContain('export const builder = createBuilder(schema)');
    });
  });

  describe('options', () => {
    test('uses custom header comment', () => {
      const input = makeInput({
        tables: [
          {
            schema: 'public',
            name: 'test',
            columns: [
              {
                name: 'id',
                zeroType: 'string',
                isOptional: false,
                isEnum: false,
                enumName: null,
                enumValues: null,
                pgType: 'text',
                warnings: [],
              },
            ],
            primaryKey: ['id'],
          },
        ],
      });

      const code = generateCode(input, {headerComment: '// Custom header'});

      expect(code.startsWith('// Custom header')).toBe(true);
    });

    test('uses custom import path', () => {
      const input = makeInput({
        tables: [
          {
            schema: 'public',
            name: 'test',
            columns: [
              {
                name: 'id',
                zeroType: 'string',
                isOptional: false,
                isEnum: false,
                enumName: null,
                enumValues: null,
                pgType: 'text',
                warnings: [],
              },
            ],
            primaryKey: ['id'],
          },
        ],
      });

      const code = generateCode(input, {zeroImportPath: '../zero'});

      expect(code).toContain("from '../zero'");
    });
  });
});
```

### Step 5: Integration Test (`test/integration.pg.test.ts`)

```typescript
import {describe, test, expect, beforeAll, afterAll} from 'vitest';
import postgres from 'postgres';
import {generateSchemaFromDatabase} from '../src/index.ts';

describe('integration', () => {
  let sql: postgres.Sql;
  const TEST_SCHEMA = 'sql_to_zql_integration';

  beforeAll(async () => {
    sql = postgres(
      process.env.DATABASE_URL ?? 'postgresql://localhost:5432/postgres',
    );

    await sql.unsafe(`
      DROP SCHEMA IF EXISTS ${TEST_SCHEMA} CASCADE;
      CREATE SCHEMA ${TEST_SCHEMA};

      CREATE TYPE ${TEST_SCHEMA}.user_role AS ENUM ('admin', 'user', 'guest');

      CREATE TABLE ${TEST_SCHEMA}.users (
        id VARCHAR PRIMARY KEY,
        name VARCHAR(100),
        email TEXT NOT NULL,
        role ${TEST_SCHEMA}.user_role NOT NULL DEFAULT 'user',
        created_at TIMESTAMPTZ DEFAULT NOW()
      );

      CREATE TABLE ${TEST_SCHEMA}.projects (
        id VARCHAR PRIMARY KEY,
        name VARCHAR(255) NOT NULL,
        owner_id VARCHAR NOT NULL REFERENCES ${TEST_SCHEMA}.users(id),
        is_active BOOLEAN DEFAULT true
      );

      CREATE TABLE ${TEST_SCHEMA}.project_members (
        project_id VARCHAR NOT NULL REFERENCES ${TEST_SCHEMA}.projects(id),
        user_id VARCHAR NOT NULL REFERENCES ${TEST_SCHEMA}.users(id),
        PRIMARY KEY (project_id, user_id)
      );
    `);
  });

  afterAll(async () => {
    await sql.unsafe(`DROP SCHEMA IF EXISTS ${TEST_SCHEMA} CASCADE`);
    await sql.end();
  });

  test('generates complete schema', async () => {
    const code = await generateSchemaFromDatabase({
      client: sql,
      schema: TEST_SCHEMA,
    });

    // Check imports
    expect(code).toContain('import {');
    expect(code).toContain('createSchema');
    expect(code).toContain('createBuilder');
    expect(code).toContain('string');
    expect(code).toContain('number');
    expect(code).toContain('boolean');
    expect(code).toContain('enumeration');
    expect(code).toContain('relationships');

    // Check enum type
    expect(code).toContain("type UserRole = 'admin' | 'user' | 'guest'");

    // Check tables
    expect(code).toContain("const users = table('users')");
    expect(code).toContain("const projects = table('projects')");
    expect(code).toContain("const projectMembers = table('projectMembers')");

    // Check columns
    expect(code).toContain('id: string()');
    expect(code).toContain('name: string().optional()');
    expect(code).toContain('email: string()');
    expect(code).toContain('role: enumeration<UserRole>()');
    expect(code).toContain('createdAt: number().optional()');
    expect(code).toContain('isActive: boolean().optional()');

    // Check relationships
    expect(code).toContain('projectsRelationships');
    expect(code).toContain('owner: one({');

    // Check many-to-many through junction
    expect(code).toContain('usersRelationships');
    expect(code).toContain('projects: many(');

    // Check schema export
    expect(code).toContain('export const schema = createSchema({');
    expect(code).toContain('tables: [');
    expect(code).toContain('relationships: [');

    // Check builder
    expect(code).toContain('export const builder = createBuilder(schema)');
  });

  test('generates valid TypeScript', async () => {
    const code = await generateSchemaFromDatabase({
      client: sql,
      schema: TEST_SCHEMA,
    });

    // Basic syntax check - no obvious errors
    expect(code).not.toContain('undefined');
    expect(code).not.toContain('null,');

    // Balanced braces/brackets
    const openBraces = (code.match(/\{/g) ?? []).length;
    const closeBraces = (code.match(/\}/g) ?? []).length;
    expect(openBraces).toBe(closeBraces);

    const openBrackets = (code.match(/\[/g) ?? []).length;
    const closeBrackets = (code.match(/\]/g) ?? []).length;
    expect(openBrackets).toBe(closeBrackets);

    const openParens = (code.match(/\(/g) ?? []).length;
    const closeParens = (code.match(/\)/g) ?? []).length;
    expect(openParens).toBe(closeParens);
  });
});
```

## Acceptance Criteria

1. **Imports**: Generates correct imports based on used types
2. **Enum types**: Generates TypeScript type aliases for enums
3. **Tables**: Generates valid table definitions with all columns
4. **Column types**: Uses correct Zero type functions
5. **Optional columns**: Adds `.optional()` to nullable columns
6. **Primary keys**: Generates single and composite primary keys
7. **Relationships**: Generates `one()` and `many()` relationships
8. **Junction tables**: Generates proper two-hop many-to-many relationships
9. **Schema export**: Exports schema with tables and relationships
10. **Builder**: Optionally exports createBuilder
11. **Integration**: End-to-end test produces valid output

## Output Format

The generated code should match the style of `apps/zbugs/shared/schema.ts`:

```typescript
// Generated by sql-to-zqlschema - DO NOT EDIT

import {
  boolean,
  createBuilder,
  createSchema,
  enumeration,
  number,
  relationships,
  string,
  table,
} from '@rocicorp/zero';

// Enum types
type UserRole = 'admin' | 'user' | 'guest';

// Table definitions
const users = table('users')
  .columns({
    id: string(),
    name: string().optional(),
    role: enumeration<UserRole>(),
  })
  .primaryKey('id');

// ... more tables

// Relationships
const projectsRelationships = relationships(projects, ({one}) => ({
  owner: one({
    sourceField: ['ownerId'],
    destField: ['id'],
    destSchema: users,
  }),
}));

// ... more relationships

export const schema = createSchema({
  tables: [users, projects],
  relationships: [projectsRelationships],
});

export const builder = createBuilder(schema);
```

## Dependencies

- Phases 1-3
- vitest for testing

## Notes

- Generated code should be formatted (consider running prettier post-generation)
- Column names are kept as-is (camelCase conversion could be added as option)
- Table variable names use camelCase of table name
- This phase completes the core functionality
