---
title: Get Started
slug: /
---

The easiest way to get started is with our Todo starter app. This app is a good way to play with Replicache, but it is _also_ a great foundation on which to build your own app using Replicache. Since it is simple and has all the pieces you'll need already in place, you can clone it and then start evolving it to suit your own needs.

# Prerequisites

1. [Node.js](https://nodejs.dev/) v14.19.1 or greater. Check which version you have by running `node --version` on the command line. If you don't have Node or the version is old, install at https://nodejs.dev/download.
2. Install PostgreSQL. On MacOS, we recommend using [Postgres.app](https://postgresapp.com/). For other OSes and options, see [Postgres Downloads](https://www.postgresql.org/download/).
3. [Sign up for a free pusher.com account](https://pusher.com/) and create a new "channels" app.

# Install

**Note:** These instructions assume you installed PostgreSQL via Postgres.app on MacOS. If you installed some other way, or configured PostgreSQL specially, you may additionally need to set the `PGUSER` and `PGPASSWORD` environment variables.

```bash
# Get the code and install
npx degit rocicorp/replicache-todo myapp
cd myapp
npm install

export PGDATABASE="myapp"

# Get a Replicache license key. The command below will ask you a few quick
# questions and then print out your key.
npx replicache get-license

export NEXT_PUBLIC_REPLICACHE_LICENSE_KEY="<your license key>"

# Get the Pusher environment variables from the "App Keys" section
# of the Pusher App UI. See: https://i.imgur.com/7DNmTKZ.png
export NEXT_PUBLIC_PUSHER_APP_ID=<appid>
export NEXT_PUBLIC_PUSHER_KEY=<pusherkey>
export NEXT_PUBLIC_PUSHER_SECRET=<pushersecret>
export NEXT_PUBLIC_PUSHER_CLUSTER=<pushercluster>

# Create a new database for Repliear
psql -d postgres -c "create database $PGDATABASE"

npm run dev
```

You now have a simple todo app powered by Replicache, <a href="https://nextjs.org/">Next.js</a>, <a href="https://www.postgresql.org/">Postgres</a>, and <a href="https://pusher.com/">Pusher</a>.

<p class="text--center">
  <img src="/img/setup/todo.webp" width="650"/>
</p>

Open the app in a browser window, copy the resulting url, and open a second browser window to it. With the two windows side-by-side, add some items in one window and see them reflected in the other. Tada! Instant UI and Realtime Sync!

## A Quick Tour of the Starter App

- **[`backend/`](https://github.com/rocicorp/replicache-todo/blob/main/backend)** contains a simple, generic Replicache server that stores data in Postgres. You don't need to worry about this directory for now -- you only need to modify it for more advanced cases. If you're curious, you can learn more at [How Replicache Works](how-it-works.md).
- **[`frontend/`](https://github.com/rocicorp/replicache-todo/blob/main/frontend)** contains the UI. This is mostly a standard React/Next.js application.
- **[`frontend/todo.ts`](https://github.com/rocicorp/replicache-todo/blob/main/frontend/todo.ts)** defines the `Todo` entity and a simple crud interface for reading and writing it.
- **[`frontend/mutators.ts`](https://github.com/rocicorp/replicache-todo/blob/main/frontend/mutators.ts)** defines the _mutators_ for this application. This is how you write data using Replicache. Call these functions from the UI to add or modify data. The mutations will be pushed to the server in the background automatically.
- **[`frontend/app.tsx`](https://github.com/rocicorp/replicache-todo/blob/main/frontend/app.tsx)** subscribes to all the todos in the app using `useSubscribe()`. This is how you typically build UI using Replicache: the hook will re-fire when the result of the subscription changes, either due to local (optimistic) changes, or changes that were synced from the server. This app is simple so it just has one subscription, but bigger apps will often have a handful â€” one for each major view.

## My First Replicache Feature

Let's see how easy it is to add a full-stack feature using Replicache. We will add an "urgent" flag to our Todos, and the ability to toggle and persist this property.

### Modify the Model

First let's add the `urgent` boolean to the Todo model. The example app uses [zod](https://github.com/colinhacks/zod) to describe the shape of the domain objects.

```ts title="frontend/todo.ts"
import {z} from 'zod';
import {entitySchema, generate, Update} from '@rocicorp/rails';

export const todoSchema = entitySchema.extend({
  text: z.string(),
  completed: z.boolean(),
  sort: z.number(),

  // add this property
  urgent: z.optional(z.boolean()),
});
```

### Add a Mutator

We need to ensure that we have a mutator that can handle the new logic.

The example app already has create, update, and delete mutators generated by the [`@rocicorp/rails`](https://www.npmjs.com/package/@rocicorp/rails) helper library. The `updateTodo` mutator already handles any fields, so there's nothing to do here ðŸŽ‰.

This pattern of reusing CRUD mutators for simple actions is common in Replicache apps â€” specific mutators are written to handle more specialized logic.

```ts title="frontend/todo.ts"
export const [createTodo, getTodo, updateTodo, deleteTodo, listTodos] =
  generate('todo', todoSchema);
```

```ts title="frontend/mutators.ts"
import {createTodo, updateTodo, deleteTodo} from './todo';

export const mutators = {
  createTodo,
  updateTodo,
  deleteTodo,
};
```

### Add a Toggle Button

We need to add a UI element so that the user can toggle the "urgent" flag. This is simple to do since the mutator we need is already available in this component as `onUpdate`.

```tsx title="frontend/todo-item.tsx"
<div className="view">
  ...
  {/* add this button to the view div */}
  <button
    style={{all: 'revert'}}
    onClick={() => onUpdate({id, urgent: !todo.urgent})}
  >
    !
  </button>
  ...
  <button className="destroy" onClick={() => onDelete()} />
</div>
```

At this point, we have actually finished the basic plumbing of our feature. Clicking on this button will: 1) change the state of our app (immediately), 2) persist that change, and 3) cause that change to be synchronized _in real time_ to other browsers.

### Show the "urgent" flag in the UI

Just to prove to ourselves that this is happening, let's render some text when the `urgent` flag is set:

```tsx title="frontend/todo-item.tsx"
<label onDoubleClick={handleDoubleClick}>
  {/* Add the URGENT label if urgent flag is set */}
  {todo.text} {todo.urgent && '(URGENT!)'}
</label>
```

It's not beautiful, but you get the idea. In summary, developers can often implement a feature by writing relatively simple code in one place. The data changes associated with that feature will automatically be full-stack and synchronized to other instances of the app.

## Next

To understand the big picture of how to use Replicache, see [How Replicache Works](./how-it-works.md).
