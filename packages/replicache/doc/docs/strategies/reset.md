---
title: The Reset Strategy
slug: /strategies/reset
---

# ðŸ¤ª The Reset Strategy

The Reset Strategy is the easiest possible backend strategy: it sends the entire client view on every pull response, so no patch calculation is necessary at all.

Sending the entire client view this way is very inefficient, and therefore this approach is not recommended for anything but early development or the tiniest production applications.

It's still useful for learning Replicache, or for a starting point to understand other strategies.

## How it Works

### Schema

In addition to your own normal domain data, your backend database will need to store an additional `ReplicacheClient` entity to support Replicache. This entity tracks intances of Replicache that have synced with the server.

```yaml
# An instance of the Replicache JS class that has synced with the server.
ReplicacheClient
  # Unique ID for client, generated by Replicache.
  id: string
  # Last mutation processed from this client.
  lastMutationID: uint
```

### Push

In an exclusive (serializable) database transaction:

<ol>
    <li>Read the <code>lastMutationID</code> for the calling client. If no such client exists, create one and default its <code>lastMutationID</code> to zero.</li>
    <li>Iterate through the pushed mutations. For each one:
        <ol>
            <li>Validate the mutation ID:
                <ol>
                    <li>If the mutation ID is smaller than the next expected mutation ID, this mutation has been processed. Skip it.</li>
                    <li>If the mutation ID is greater than the next expected mutation ID, there has been a critical error on either the client or server. This client can no longer sync. Log an error, abort transaction, exit push, and return HTTP 400 to client.</li>
                </ol>
            </li>
            <li>Process the mutation. Make whatever changes necessary to the backend database.</li>
            <li>Update the <code>lastMutationID</code> for the calling client.</li>
        </ol>
    </li>
    <li>Commit the transaction.</li>
</ol>

:::caution

It is important that the push happen in a serializable transaction, and that the `lastMutationID` is updated atomically as part of this transaction. If this requirement is violated users can experience data loss.

:::

### On Pull

In an exclusive (serializable) database transaction:

<ol>
    <li>Read the <code>lastMutationID</code> for the calling client, or default to zero if no such client exists.</li>
    <li>Read all entities needed for the requesting client's Client View from the database. This can be any arbitrary query of the database, including auth, filters, etc.</li>
    <li>Return <code>PullResponse</code> to the client:
        <ul>
            <li><code>lastMutationID</code>: lastMutationID for requesting client, or zero.</li>
            <li><code>cookie</code>: <code>null</code> (cookie not used by this strategy).</li>
            <li><code>patch</code>: Send a <em>reset patch</em>: a <code>clear</code> op followed by <code>put</code> ops for each entity in the Client View.</li>
        </ul>
    </li>
</ol>

## Challenges

Needless to say this isn't a practical strategy for almost any real application. It's presented here mainly for educational reasons.

## Read Authorization

Because of the fact that this returns a reset patch, read authorizaton works naturally. Just update the query used to build the patch in the pull response to obey whatever auth rules you like.

## Early Exit

There is no need to process every mutation submitted to the push endpoint. You can exit early as long as <code>lastMutationID</code> is set to whatever the last processed mutation was. This can ocassionally be useful if clients can accumulate large amounts of mutations while offline and you want to keep the runtime of the push handler under some limit.

## Batch Size

Similarly you don't need to process all the mutations in a single transaction. Within the push handler you can split the mutation processing into as many transaction as you like. You just need to repeat the entire algorithm (including re-reading the `lastMutationID` at start, and re-writing it at end) inside each transaction.

## Partial Sync

Imagine that we are building a game and we want to sync only recently used levels, to reduce data downloaded to device. To do so, we might add a new entity:

```yaml
# A browser profile that is syncing via Replicache.
ReplicacheProfile
  # Unique ID for profile, generated by Replicache.
  id: string
  # First level to sync.
  syncStartLevel: number
  # Last level to sync.
  syncEndLevel: number
```

Also add a mutator that updates this window. There is no need for this mutator to even run client-side:

```ts
const r = new Replicache({
  // ...
  mutators: {
    // ...
    changeSyncWindow: async (
        tx,
        {startLevel, endLevel}: {startLevel: number, endLevel: number}) {
      // noop, runs only on server
    }
  }
})
```

Implement the mutation on the server-side to change the persistent sync window. For example, if the database was SQL this mutator might look like:

```ts
async function changeSyncWindow(
    dbTX,
    {profileID, startLevel, endLevel}:
        {profileID: string, startLevel: number, endLevel: number} {
  await dbTX.query(`
      update ReplicacheProfile set
          syncStartLevel = ?,
          syncEndLevel = ?
      where profileID = ?`,
      profileID,
      startLevel,
      endLevel);
})
```

On push: as part of the push transaction, initialize the row in `ReplicacheProfile` if necessary, setting the sync window to whatever the default is. Execute mutators, including the `changeSyncWindow`, as normal.

On pull: Only read and return the part of the client view that matches the current sync window. Because of the `op:clear` at the beginning of the patch, this naturally handles changes to the sync window.

## Examples

The Get Started Guide [starts out with the Reset Strategy](/byob/client-view#serving-the-client-view) (using static data) before implementing dynamic pull.
