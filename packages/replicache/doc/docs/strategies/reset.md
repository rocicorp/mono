---
title: Reset Strategy
slug: /strategies/reset
---

# ðŸ¤ª The Reset Strategy

The Reset Strategy is the easiest possible: it sends the entire client view on every pull response, so no patch calculation is necessary at all.

Sending the entire client view on each pull this way is very inefficient, so this approach is not usually recommended. That said, we do have customers that use this strategy in production, and it works if your data changes infrequently or is very small.

## Schema

In addition to your own normal domain data, your backend database will need to store two additional entities to support Replicache. We describe these entities here using TypeScript, but they'd typically be rows in a database.

```ts
// A group of related ReplicacheClients. Typically there is one per browser
// profile.
type ReplicacheClientGroup = {
  // Globally unique ID, generated by Replicache.
  id: string;

  // Optional, but required if the application is authenticated. The userID
  // that created this ReplicacheClientGroup.
  userID: any;
};

// An instance of the Replicache JS class that has ever synced with the server.
type ReplicacheClient = {
  // Globally unique ID, generated by Replicache.
  id: string;

  // The ClientGroup this client is part of.
  clientGroupID: string;

  // Last mutation the server has processed from this client.
  lastMutationID: number;
};
```

### Push

Replicache sends a [`PushRequest`](/reference/server-push#http-request-body) to the push endpoint. The endpoint should:

1. Create a new `ReplicacheClientGroup` if necessary.
1. Verify the requesting user owns the specified `ReplicacheClientGroup`.

Then, for each mutation described in the `PushRequest`:

3. Create a new `ReplicacheClient` if necessary.
4. Validate the `ReplicacheClient` is part of the requested `ReplicacheClientGroup`.
5. Validate the received mutation ID is the next expected mutation ID from this client.
6. Run the applicable business logic to apply the mutation.
7. Update the `lastMutationID` of the client to store that the mutation was processed.

It is important that each mutation is processed within a serializable transaction, so that the `lastMutationID` is updated atomically with the changes made by the mutation.

## Pull

Replicache sends a [`PullRequest`](/reference/server-pull#http-request-body) to the pull endpoint. The endpoint should:

<ol>
  <li>Verify that requesting user owns the requested <code>ReplicacheClientGroup</code>.</li>
  <li>Return a <code><a href="/reference/server-pull#http-response-body">PullResponse</a></code> with:
    <ul>
      <li>Some monotonically increasing <code>cookie</code>.</li>
      <li>The <code>lastMutatationID</code> for every client in the client group.</li>
      <li>A patch which clears the client view and replaces it with the entire current client view.</li>
    </ul>
  </li>
</ol>

## Example

We do not currently have an example of this strategy.

## Variations

### Read Authorization

Because of the fact that this returns a reset patch, read authorizaton works naturally. Just update the query used to build the patch in the pull response to obey whatever auth rules you like.

### Early Exit

There is no need to process every mutation submitted to the push endpoint. You can exit early as long as <code>lastMutationID</code> is set to whatever the last processed mutation was. This can ocassionally be useful if clients can accumulate large amounts of mutations while offline and you want to keep the runtime of the push handler under some limit.

### Batching

You don't need to process each mutation in its own transaction. The entire push can be run inside one transaction, or you can do smaller batches.

### Partial Sync

Imagine that we are building a game and we want to sync only recently used levels, to reduce data downloaded to device. To do so, we might add a new entity:

```ts
# A browser profile that is syncing via Replicache.
type ReplicacheProfile = {
  // Unique ID for profile, generated by Replicache.
  id: string;
  // First level to sync.
  syncStartLevel: number;
  // Last level to sync.
  syncEndLevel: number;
};
```

Also add a mutator that updates this window. There is no need for this mutator to even run client-side:

```ts
const r = new Replicache({
  // ...
  mutators: {
    // ...
    changeSyncWindow: async (
        tx,
        {startLevel, endLevel}: {startLevel: number, endLevel: number}) {
      // noop, runs only on server
    }
  }
})
```

Implement the mutation on the server-side to change the persistent sync window.

On push, as part of the push transaction, initialize the row in `ReplicacheProfile` if necessary, setting the sync window to whatever the default is. Execute mutators, including the `changeSyncWindow`, as normal.

On pull, only read and return the part of the client view that matches the current sync window. Because of the `op:clear` at the beginning of the patch, this naturally handles changes to the sync window.
