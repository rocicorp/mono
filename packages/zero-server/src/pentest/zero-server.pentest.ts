/**
 * Zero-Server Penetration Testing Suite
 *
 * Tests mutation processing security focusing on:
 * - Prototype pollution via mutator path resolution
 * - SQL injection in CRUD operations
 * - Mutation ID (LMID) tracking and boundary conditions
 * - Client isolation
 * - Error message information leakage
 */

/* eslint-disable no-console */
// Console.log is used intentionally in pentest code to flag security findings
// oxlint-disable eslint-plugin-jest(no-conditional-expect)
// oxlint-disable eslint-plugin-jest(valid-describe-callback)

import {describe, expect} from 'vitest';
import {
  getClientsTableDefinition,
  getMutationsTableDefinition,
} from '../../../zero-cache/src/services/change-source/pg/schema/shard.ts';
import {test} from '../../../zero-cache/src/test/db.ts';
import type {PostgresDB} from '../../../zero-cache/src/types/pg.ts';
import type {ReadonlyJSONValue} from '../../../shared/src/json.ts';
import {ErrorKind} from '../../../zero-protocol/src/error-kind.ts';
import {ErrorReason} from '../../../zero-protocol/src/error-reason.ts';
import type {PushBody} from '../../../zero-protocol/src/push.ts';
import {PostgresJSConnection} from '../adapters/postgresjs.ts';
import {PushProcessor} from '../push-processor.ts';
import {ZQLDatabase} from '../zql-database.ts';
import {
  createBoundaryMutationIDs,
  createClientIDPayloads,
  createCRUDAttackPayloads,
  createPrototypePollutionNames,
  createSQLInjectionPayloads,
  makeSingleMutation,
} from './helpers/mutation-helpers.ts';

const params = {
  schema: 'zero_pentest',
  appID: 'zero',
};

describe('zero-server pentest', {timeout: 120000}, () => {
  describe('prototype pollution via mutator path', () => {
    test('prototype pollution attempts are rejected', async ({testDBs}) => {
      const pg = await testDBs.create('zs-pentest-proto');
      await setupTestSchema(pg);

      const processor = createProcessor(pg);

      // Track which mutators actually get called
      const calledMutators: string[] = [];
      const trackedMutators = {
        safe: {
          mutator: () => {
            calledMutators.push('safe.mutator');
            return Promise.resolve();
          },
        },
      };

      const pollutionNames = createPrototypePollutionNames();

      for (const [name, path] of Object.entries(pollutionNames)) {
        // Reset the track
        calledMutators.length = 0;

        const push = makeSingleMutation('cg', 'client', 1, path);

        // We expect the processor to fail to find the mutator
        // (assertion error), NOT to execute prototype methods
        const result = await processor.process(trackedMutators, params, push);

        // Verify the response indicates failure (assertion error)
        // The processor should throw an assertion error for unknown mutators
        if ('kind' in result && result.kind === ErrorKind.PushFailed) {
          // Expected: could not find mutator
          expect(result.reason).toBe(ErrorReason.Internal);
          // The error message should indicate the mutator wasn't found
          // NOT that a prototype method was called
        } else if ('mutations' in result) {
          // If it somehow succeeded, check it didn't call wrong things
          console.log(
            `[FINDING] Prototype pollution path "${name}" (${path}) returned success`,
          );
          console.log('Called mutators:', calledMutators);
        }

        // Verify no prototype pollution occurred on Object.prototype
        expect(
          Object.prototype.hasOwnProperty.call(Object.prototype, 'polluted'),
        ).toBe(false);
        expect((Object.prototype as Record<string, unknown>)['isAdmin']).toBe(
          undefined,
        );
      }

      await testDBs.drop(pg);
    });

    test('hasOwnProperty/toString cannot be invoked as mutators', async ({
      testDBs,
    }) => {
      const pg = await testDBs.create('zs-pentest-builtin');
      await setupTestSchema(pg);

      const processor = createProcessor(pg);
      const mutators = {
        normal: () => Promise.resolve(),
      };

      // These built-in methods exist on all objects due to prototype chain
      const builtins = [
        'hasOwnProperty',
        'toString',
        'valueOf',
        'isPrototypeOf',
        'propertyIsEnumerable',
        'toLocaleString',
      ];

      for (const builtin of builtins) {
        const push = makeSingleMutation('cg', 'client', 1, builtin);
        const result = await processor.process(mutators, params, push);

        // Built-in methods should either:
        // 1. Fail with "could not find mutator" (if getValueAtPath returns undefined)
        // 2. Fail with type error (if it returns the function but it's not async)
        // They should NOT successfully execute
        if ('mutations' in result && result.mutations.length > 0) {
          const mutation = result.mutations[0];
          if (!('error' in mutation.result)) {
            console.log(
              `[CRITICAL] Built-in method "${builtin}" executed as mutator!`,
            );
          }
        }
      }

      await testDBs.drop(pg);
    });

    test('nested prototype access is blocked', async ({testDBs}) => {
      const pg = await testDBs.create('zs-pentest-nested-proto');
      await setupTestSchema(pg);

      const processor = createProcessor(pg);

      // Create mutators with nested structure
      const mutators = {
        level1: {
          level2: {
            safe: () => Promise.resolve(),
          },
        },
      };

      // Try to escape the nesting via prototype
      const attackPaths = [
        'level1.__proto__.polluted',
        'level1.level2.__proto__.isAdmin',
        'level1.constructor.prototype.pwned',
        '__proto__.level1.level2',
      ];

      for (const path of attackPaths) {
        const push = makeSingleMutation('cg', 'client', 1, path);
        const result = await processor.process(mutators, params, push);

        // Should fail to find mutator
        if ('kind' in result && result.kind === ErrorKind.PushFailed) {
          // Expected behavior
        } else {
          console.log(
            `[FINDING] Nested prototype path "${path}" returned unexpected result`,
          );
        }
      }

      // Verify no pollution
      expect(
        (Object.prototype as Record<string, unknown>)['polluted'],
      ).toBeUndefined();
      expect(
        (Object.prototype as Record<string, unknown>)['isAdmin'],
      ).toBeUndefined();
      expect(
        (Object.prototype as Record<string, unknown>)['pwned'],
      ).toBeUndefined();

      await testDBs.drop(pg);
    });
  });

  describe('mutation ID boundary attacks', () => {
    test('mutation ID boundary conditions', async ({testDBs}) => {
      const pg = await testDBs.create('zs-pentest-mid-boundary');
      await setupTestSchema(pg);

      const processor = createProcessor(pg);
      const mutators = {
        test: () => Promise.resolve(),
      };

      const boundaries = createBoundaryMutationIDs();

      // First, process a valid mutation to establish baseline
      const baseline = await processor.process(
        mutators,
        params,
        makeSingleMutation('cg', 'client', 1, 'test'),
      );
      expect('mutations' in baseline).toBe(true);

      // Now test boundary conditions
      for (const [name, value] of Object.entries(boundaries)) {
        // Skip the baseline case
        if (value === 1) continue;

        const push: PushBody = {
          pushVersion: 1,
          clientGroupID: 'cg-boundary',
          requestID: `pentest-${name}`,
          schemaVersion: 1,
          timestamp: Date.now(),
          mutations: [
            {
              type: 'custom',
              clientID: 'client-boundary',
              id: value as number, // Some values will cause issues
              name: 'test',
              timestamp: Date.now(),
              args: [],
            },
          ],
        };

        try {
          const result = await processor.process(mutators, params, push);

          // Negative IDs should be rejected (out of order)
          if (typeof value === 'number' && value < 0) {
            if ('mutations' in result) {
              console.log(
                `[FINDING] Negative mutation ID ${value} was accepted`,
              );
            }
          }

          // NaN/Infinity should be rejected
          if (typeof value === 'number' && !Number.isFinite(value)) {
            if (
              'mutations' in result &&
              !('error' in result.mutations[0].result)
            ) {
              console.log(`[FINDING] ${name} mutation ID was accepted`);
            }
          }
        } catch {
          // Some values may cause parse errors - that's acceptable
          // as long as it doesn't crash the server
        }
      }

      await testDBs.drop(pg);
    });

    test('rapid replay of same mutation ID', async ({testDBs}) => {
      const pg = await testDBs.create('zs-pentest-mid-replay');
      await setupTestSchema(pg);

      const processor = createProcessor(pg);
      let callCount = 0;
      const mutators = {
        track: () => {
          callCount++;
          return Promise.resolve();
        },
      };

      // Process mutation ID 1
      await processor.process(
        mutators,
        params,
        makeSingleMutation('cg', 'client', 1, 'track'),
      );
      expect(callCount).toBe(1);

      // Rapidly replay mutation ID 1 multiple times
      const replayPromises = Array.from({length: 10}, () =>
        processor.process(
          mutators,
          params,
          makeSingleMutation('cg', 'client', 1, 'track'),
        ),
      );

      const results = await Promise.all(replayPromises);

      // All replays should return "alreadyProcessed"
      for (const result of results) {
        if ('mutations' in result) {
          expect(result.mutations[0].result).toHaveProperty(
            'error',
            'alreadyProcessed',
          );
        }
      }

      // Mutator should only have been called once
      expect(callCount).toBe(1);

      await testDBs.drop(pg);
    });

    test('concurrent mutations from same client', async ({testDBs}) => {
      const pg = await testDBs.create('zs-pentest-mid-concurrent');
      await setupTestSchema(pg);

      const processor = createProcessor(pg);
      const mutators = {
        test: () => Promise.resolve(),
      };

      // Send mutations 1, 2, 3 concurrently
      const concurrent = [1, 2, 3].map(id =>
        processor.process(
          mutators,
          params,
          makeSingleMutation('cg', 'client', id, 'test'),
        ),
      );

      const results = await Promise.all(concurrent);

      // At least one should succeed, others may be out-of-order
      // depending on timing
      const succeeded = results.filter(r => 'mutations' in r);
      const failed = results.filter(r => 'kind' in r);

      // The important thing is no crashes and proper error handling
      expect(succeeded.length + failed.length).toBe(3);

      await testDBs.drop(pg);
    });
  });

  describe('SQL injection in CRUD operations', () => {
    test('SQL injection payloads in values are properly escaped', async ({
      testDBs,
    }) => {
      const pg = await testDBs.create('zs-pentest-sqli-values');
      await setupTestSchema(pg);
      await setupDataTable(pg);

      // Create a ZQLDatabase with schema for CRUD
      const schema = {
        tables: {
          pentestData: {
            name: 'pentest_data',
            columns: {
              id: {type: 'string' as const},
              value: {type: 'string' as const, optional: true},
              numericVal: {type: 'number' as const, optional: true},
            },
            primaryKey: ['id'] as const,
          },
        },
        relationships: {},
        version: 1,
      };

      const db = new ZQLDatabase(new PostgresJSConnection(pg), schema);
      const processor = new PushProcessor(db);

      const injectionPayloads = createSQLInjectionPayloads();

      // Test each injection payload as a value in insert
      for (const [name, payload] of Object.entries(injectionPayloads)) {
        // Skip complex objects for this test
        if (typeof payload !== 'string') continue;

        const mutators = {
          insert: async (tx: unknown) => {
            const transaction = tx as {
              mutate: {
                pentestData: {
                  insert: (v: {id: string; value: string}) => Promise<void>;
                };
              };
            };
            await transaction.mutate.pentestData.insert({
              id: `sqli-${name}`,
              value: payload,
            });
          },
        };

        let mutationId = 1;
        const push = makeSingleMutation(
          'cg',
          'sqli-client',
          mutationId++,
          'insert',
        );

        try {
          const result = await processor.process(mutators, params, push);

          // Should succeed (payload stored as literal string)
          if (
            'mutations' in result &&
            !('error' in result.mutations[0].result)
          ) {
            // Verify the data was stored as literal string, not executed
            const stored =
              await pg`SELECT value FROM pentest_data WHERE id = ${`sqli-${name}`}`;
            if (stored.length > 0) {
              // Good: data stored as literal
              expect(stored[0].value).toBe(payload);
            }
          }
        } catch {
          // Some payloads may cause legitimate errors (e.g., very long strings)
          // but should NOT execute SQL
        }
      }

      // Verify injection didn't drop any tables
      const tableExists = await pg`
        SELECT EXISTS (
          SELECT FROM information_schema.tables
          WHERE table_name = 'pentest_data'
        ) as exists
      `;
      expect(tableExists[0].exists).toBe(true);

      await testDBs.drop(pg);
    });

    test('SQL injection in primary key values', async ({testDBs}) => {
      const pg = await testDBs.create('zs-pentest-sqli-pk');
      await setupTestSchema(pg);
      await setupDataTable(pg);

      const schema = {
        tables: {
          pentestData: {
            name: 'pentest_data',
            columns: {
              id: {type: 'string' as const},
              value: {type: 'string' as const, optional: true},
            },
            primaryKey: ['id'] as const,
          },
        },
        relationships: {},
        version: 1,
      };

      const db = new ZQLDatabase(new PostgresJSConnection(pg), schema);
      const processor = new PushProcessor(db);

      const crudPayloads = createCRUDAttackPayloads();

      for (const [_name, payload] of Object.entries(crudPayloads)) {
        const pk = (payload as Record<string, unknown>).id;
        if (typeof pk !== 'string') continue;

        let mutationId = 1;
        const mutators = {
          insertPK: async (tx: unknown) => {
            const transaction = tx as {
              mutate: {
                pentestData: {
                  insert: (v: {
                    id: string;
                    value?: string | undefined;
                  }) => Promise<void>;
                };
              };
            };
            await transaction.mutate.pentestData.insert({
              id: pk,
              value: 'test',
            });
          },
        };

        const push = makeSingleMutation(
          'cg',
          'pk-client',
          mutationId++,
          'insertPK',
        );

        try {
          await processor.process(mutators, params, push);
        } catch {
          // Errors are acceptable as long as no SQL injection occurred
        }
      }

      // Verify no SQL injection occurred
      const tableExists = await pg`
        SELECT EXISTS (
          SELECT FROM information_schema.tables
          WHERE table_name = 'pentest_data'
        ) as exists
      `;
      expect(tableExists[0].exists).toBe(true);

      await testDBs.drop(pg);
    });

    test('NULL bytes in values are handled', async ({testDBs}) => {
      const pg = await testDBs.create('zs-pentest-sqli-null');
      await setupTestSchema(pg);
      await setupDataTable(pg);

      const schema = {
        tables: {
          pentestData: {
            name: 'pentest_data',
            columns: {
              id: {type: 'string' as const},
              value: {type: 'string' as const, optional: true},
            },
            primaryKey: ['id'] as const,
          },
        },
        relationships: {},
        version: 1,
      };

      const db = new ZQLDatabase(new PostgresJSConnection(pg), schema);
      const processor = new PushProcessor(db);

      const nullBytePayloads = [
        'before\x00after',
        '\x00start',
        'end\x00',
        'multiple\x00null\x00bytes',
        "inject\x00'; DROP TABLE users; --",
      ];

      for (const payload of nullBytePayloads) {
        let mutationId = 1;
        const mutators = {
          insertNull: async (tx: unknown) => {
            const transaction = tx as {
              mutate: {
                pentestData: {
                  insert: (v: {id: string; value: string}) => Promise<void>;
                };
              };
            };
            await transaction.mutate.pentestData.insert({
              id: `null-${mutationId}`,
              value: payload,
            });
          },
        };

        const push = makeSingleMutation(
          'cg',
          'null-client',
          mutationId++,
          'insertNull',
        );

        try {
          await processor.process(mutators, params, push);
        } catch {
          // PostgreSQL may reject NULL bytes - that's acceptable
        }
      }

      await testDBs.drop(pg);
    });
  });

  describe('client isolation', () => {
    test('client A mutation cannot affect client B LMID', async ({testDBs}) => {
      const pg = await testDBs.create('zs-pentest-isolation');
      await setupTestSchema(pg);

      const processor = createProcessor(pg);
      const mutators = {
        test: () => Promise.resolve(),
      };

      // Client A processes mutation 1
      await processor.process(
        mutators,
        params,
        makeSingleMutation('cg', 'clientA', 1, 'test'),
      );

      // Client B processes mutation 1 (should succeed, different client)
      const resultB = await processor.process(
        mutators,
        params,
        makeSingleMutation('cg', 'clientB', 1, 'test'),
      );

      // Client B's mutation should succeed
      expect('mutations' in resultB).toBe(true);
      if ('mutations' in resultB) {
        expect(resultB.mutations[0].result).not.toHaveProperty('error');
      }

      // Verify each client has its own LMID
      const clientA =
        await pg`SELECT "lastMutationID" FROM zero_pentest.clients WHERE "clientID" = 'clientA'`;
      const clientB =
        await pg`SELECT "lastMutationID" FROM zero_pentest.clients WHERE "clientID" = 'clientB'`;

      expect(clientA[0].lastMutationID).toBe(1n);
      expect(clientB[0].lastMutationID).toBe(1n);

      await testDBs.drop(pg);
    });

    test('same clientID in different clientGroups are isolated', async ({
      testDBs,
    }) => {
      const pg = await testDBs.create('zs-pentest-cg-isolation');
      await setupTestSchema(pg);

      const processor = createProcessor(pg);
      const mutators = {
        test: () => Promise.resolve(),
      };

      // Same clientID in different clientGroups
      await processor.process(
        mutators,
        params,
        makeSingleMutation('groupA', 'client', 1, 'test'),
      );
      await processor.process(
        mutators,
        params,
        makeSingleMutation('groupA', 'client', 2, 'test'),
      );

      // Different group, same client ID - should start at 1
      const result = await processor.process(
        mutators,
        params,
        makeSingleMutation('groupB', 'client', 1, 'test'),
      );

      expect('mutations' in result).toBe(true);
      if ('mutations' in result) {
        expect(result.mutations[0].result).not.toHaveProperty('error');
      }

      await testDBs.drop(pg);
    });

    test('client ID with injection payloads', async ({testDBs}) => {
      const pg = await testDBs.create('zs-pentest-client-inject');
      await setupTestSchema(pg);

      const processor = createProcessor(pg);
      const mutators = {
        test: () => Promise.resolve(),
      };

      const clientPayloads = createClientIDPayloads();

      for (const [_name, clientID] of Object.entries(clientPayloads)) {
        try {
          const push = makeSingleMutation('cg', clientID, 1, 'test');
          const result = await processor.process(mutators, params, push);

          // Empty clientID may be rejected or accepted
          // Injection payloads should be stored as literals
          if (
            'mutations' in result &&
            !('error' in result.mutations[0].result)
          ) {
            // Verify it was stored as literal
            const stored =
              await pg`SELECT "clientID" FROM zero_pentest.clients WHERE "clientGroupID" = 'cg' AND "clientID" = ${clientID}`;
            if (stored.length > 0) {
              expect(stored[0].clientID).toBe(clientID);
            }
          }
        } catch {
          // Some payloads may cause errors - acceptable
        }
      }

      // Verify no SQL injection occurred
      const clients =
        await pg`SELECT COUNT(*) as count FROM zero_pentest.clients`;
      // Should have some rows but not have dropped the table
      expect(Number(clients[0].count)).toBeGreaterThanOrEqual(0);

      await testDBs.drop(pg);
    });
  });

  describe('error message leakage', () => {
    test('unknown mutator errors do not leak internal details', async ({
      testDBs,
    }) => {
      const pg = await testDBs.create('zs-pentest-error-leak');
      await setupTestSchema(pg);

      const processor = createProcessor(pg);
      const mutators = {
        known: () => Promise.resolve(),
      };

      const push = makeSingleMutation('cg', 'client', 1, 'nonexistent.mutator');
      const result = await processor.process(mutators, params, push);

      if ('kind' in result && result.kind === ErrorKind.PushFailed) {
        // Error message should not leak:
        // - File paths
        // - Stack traces
        // - Internal variable names
        // - Database connection strings
        const message = result.message || '';
        expect(message).not.toMatch(/\/.*\.(ts|js)/); // No file paths
        expect(message).not.toMatch(/at\s+\w+\s+\(/); // No stack traces
        expect(message).not.toMatch(/postgres:\/\//); // No connection strings
      }

      await testDBs.drop(pg);
    });

    test('database errors do not leak connection details', async ({
      testDBs,
    }) => {
      const pg = await testDBs.create('zs-pentest-db-error-leak');
      await setupTestSchema(pg);

      const processor = createProcessor(pg);
      const mutators = {
        // oxlint-disable-next-line eslint(require-await)
        causeDbError: async () => {
          // This will fail - can't query during mutation
          throw new Error('Intentional test error');
        },
      };

      const push = makeSingleMutation('cg', 'client', 1, 'causeDbError');
      const result = await processor.process(mutators, params, push);

      if ('mutations' in result && 'error' in result.mutations[0].result) {
        const errorResult = result.mutations[0].result;
        if ('message' in errorResult) {
          const message = errorResult.message || '';
          expect(message).not.toMatch(/postgres:\/\//);
          expect(message).not.toMatch(/password/i);
          expect(message).not.toMatch(/host.*port/i);
        }
      }

      await testDBs.drop(pg);
    });

    test('constraint violations do not leak schema details', async ({
      testDBs,
    }) => {
      const pg = await testDBs.create('zs-pentest-constraint-leak');
      await setupTestSchema(pg);
      await setupDataTable(pg);

      // Insert initial data
      await pg`INSERT INTO pentest_data (id, value) VALUES ('existing', 'test')`;

      const schema = {
        tables: {
          pentestData: {
            name: 'pentest_data',
            columns: {
              id: {type: 'string' as const},
              value: {type: 'string' as const, optional: true},
            },
            primaryKey: ['id'] as const,
          },
        },
        relationships: {},
        version: 1,
      };

      const db = new ZQLDatabase(new PostgresJSConnection(pg), schema);
      const processor = new PushProcessor(db);

      const mutators = {
        dupInsert: async (tx: unknown) => {
          const transaction = tx as {
            mutate: {
              pentestData: {
                insert: (v: {id: string; value: string}) => Promise<void>;
              };
            };
          };
          // This should fail due to duplicate key
          await transaction.mutate.pentestData.insert({
            id: 'existing',
            value: 'duplicate',
          });
        },
      };

      const push = makeSingleMutation('cg', 'client', 1, 'dupInsert');
      const result = await processor.process(mutators, params, push);

      // Should have an error, but error should not expose full constraint name
      // or internal schema details
      if ('mutations' in result && 'error' in result.mutations[0].result) {
        const errorResult = result.mutations[0].result;
        if ('message' in errorResult && errorResult.message) {
          // Acceptable to mention "duplicate" or "constraint"
          // Not acceptable to leak full constraint name like "pentest_data_pkey"
          // (though this depends on how errors are wrapped)
        }
      }

      await testDBs.drop(pg);
    });
  });

  describe('input validation', () => {
    test('deeply nested args do not cause stack overflow', async ({
      testDBs,
    }) => {
      const pg = await testDBs.create('zs-pentest-deep-args');
      await setupTestSchema(pg);

      const processor = createProcessor(pg);
      const mutators = {
        nested: () => Promise.resolve(),
      };

      // Create deeply nested object - use type assertion for pentest purposes
      type DeepJSON = {readonly [key: string]: DeepJSON | string | undefined};
      let deepObject: DeepJSON = {value: 'leaf'};
      for (let i = 0; i < 1000; i++) {
        deepObject = {nested: deepObject};
      }

      const push: PushBody = {
        pushVersion: 1,
        clientGroupID: 'cg',
        requestID: 'deep-test',
        schemaVersion: 1,
        timestamp: Date.now(),
        mutations: [
          {
            type: 'custom',
            clientID: 'client',
            id: 1,
            name: 'nested',
            timestamp: Date.now(),
            // Type assertion needed for pentest - we intentionally test edge cases
            args: [deepObject as unknown as ReadonlyJSONValue],
          },
        ],
      };

      // Should handle gracefully (either process or reject, but not crash)
      try {
        const result = await processor.process(mutators, params, push);
        // Success or failure is fine, just no crash
        expect(result).toBeDefined();
      } catch (_error) {
        // Stack overflow would be caught here - acceptable
        expect(_error).toBeDefined();
      }

      await testDBs.drop(pg);
    });

    test('very large args array is handled', async ({testDBs}) => {
      const pg = await testDBs.create('zs-pentest-large-args');
      await setupTestSchema(pg);

      const processor = createProcessor(pg);
      const mutators = {
        largeArgs: () => Promise.resolve(),
      };

      // Large args array
      const largeArgs = Array.from({length: 10000}, (_, i) => ({
        index: i,
        data: 'x'.repeat(100),
      }));

      const push: PushBody = {
        pushVersion: 1,
        clientGroupID: 'cg',
        requestID: 'large-test',
        schemaVersion: 1,
        timestamp: Date.now(),
        mutations: [
          {
            type: 'custom',
            clientID: 'client',
            id: 1,
            name: 'largeArgs',
            timestamp: Date.now(),
            args: largeArgs,
          },
        ],
      };

      // Should handle without OOM
      const result = await processor.process(mutators, params, push);
      expect(result).toBeDefined();

      await testDBs.drop(pg);
    });

    test('mutation with special characters in name', async ({testDBs}) => {
      const pg = await testDBs.create('zs-pentest-special-name');
      await setupTestSchema(pg);

      const processor = createProcessor(pg);

      // Valid mutators with special but safe characters
      const mutators = {
        'normal_underscore': () => Promise.resolve(),
        'hyphen-name': () => Promise.resolve(),
        'namespace': {
          nested_name: () => Promise.resolve(),
        },
      };

      // Test invalid/dangerous mutation names
      const dangerousNames = [
        '../../../etc/passwd',
        'name\x00injection',
        'name\nwith\nnewlines',
        '<script>alert(1)</script>',
        '${process.exit(1)}',
        'name; rm -rf /',
      ];

      for (const name of dangerousNames) {
        const push = makeSingleMutation('cg', 'client', 1, name);
        const result = await processor.process(mutators, params, push);

        // Should fail to find mutator (not execute anything dangerous)
        if ('kind' in result) {
          expect(result.kind).toBe(ErrorKind.PushFailed);
        }
      }

      await testDBs.drop(pg);
    });
  });
});

// Helper functions

async function setupTestSchema(pg: PostgresDB) {
  await pg.unsafe(`
    CREATE SCHEMA IF NOT EXISTS zero_pentest;
    ${getClientsTableDefinition('zero_pentest')}
    ${getMutationsTableDefinition('zero_pentest')}
  `);
}

async function setupDataTable(pg: PostgresDB) {
  await pg.unsafe(`
    CREATE TABLE IF NOT EXISTS pentest_data (
      id TEXT PRIMARY KEY,
      value TEXT,
      numeric_val INTEGER
    );
  `);
}

function createProcessor(pg: PostgresDB) {
  return new PushProcessor(
    new ZQLDatabase(new PostgresJSConnection(pg), {
      tables: {},
      relationships: {},
      version: 1,
    }),
  );
}
