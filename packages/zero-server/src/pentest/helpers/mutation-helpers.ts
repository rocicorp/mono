/**
 * Pentest payload generators for zero-server mutation processing.
 *
 * Provides attack vectors for:
 * - Prototype pollution via mutator path traversal
 * - SQL injection in CRUD operations
 * - Mutation ID boundary conditions
 * - Client isolation bypass attempts
 */

import type {ReadonlyJSONValue} from '../../../../shared/src/json.ts';
import type {PushBody} from '../../../../zero-protocol/src/push.ts';

/**
 * Prototype pollution attack vectors for mutator path resolution.
 * Tests `getValueAtPath(mutators, key, /\.|\|/)` which uses `part in current`.
 */
export function createPrototypePollutionNames(): Record<string, string> {
  return {
    // Direct prototype access
    '__proto__': '__proto__',
    'prototype': 'prototype',
    'constructor': 'constructor',

    // Prototype chain traversal
    '__proto__.polluted': '__proto__.polluted',
    '__proto__|polluted': '__proto__|polluted',
    'constructor.prototype': 'constructor.prototype',
    'constructor|prototype': 'constructor|prototype',
    'constructor.prototype.isAdmin': 'constructor.prototype.isAdmin',

    // Built-in method hijacking
    'hasOwnProperty': 'hasOwnProperty',
    'toString': 'toString',
    'valueOf': 'valueOf',
    'isPrototypeOf': 'isPrototypeOf',
    '__defineGetter__': '__defineGetter__',
    '__defineSetter__': '__defineSetter__',
    '__lookupGetter__': '__lookupGetter__',
    '__lookupSetter__': '__lookupSetter__',

    // Nested prototype pollution
    'foo.__proto__.bar': 'foo.__proto__.bar',
    'foo|__proto__|bar': 'foo|__proto__|bar',
    'a.b.__proto__.c': 'a.b.__proto__.c',
    'a.constructor.prototype.b': 'a.constructor.prototype.b',

    // Mixed separator attacks
    '__proto__|constructor': '__proto__|constructor',
    'constructor.__proto__': 'constructor.__proto__',
  };
}

/**
 * SQL injection payloads for CRUD operations.
 * Tests parameterized query handling in custom.ts INSERT/UPDATE/DELETE.
 */
export function createSQLInjectionPayloads(): Record<string, unknown> {
  return {
    // Classic SQL injection
    dropTable: "'; DROP TABLE users; --",
    unionSelect: "' UNION SELECT * FROM pg_user; --",
    orTrue: "' OR '1'='1",
    orTrueComment: "' OR '1'='1' --",
    semicolonCmd: "'; SELECT pg_sleep(5); --",

    // Comment injection
    lineComment: 'value --',
    blockComment: 'value /* */',
    nestedComment: 'value /* /* nested */ */',

    // NULL byte injection
    nullByte: 'value\x00injected',
    nullByteEnd: 'value\x00',

    // Unicode escape
    unicodeEscape: '\\u0027 OR 1=1 --',
    unicodeQuote: '\u0027 OR 1=1 --',

    // JSONB injection (tests JSON handling)
    jsonInjection: {key: "'; DROP TABLE users; --"},
    jsonNestedInjection: {nested: {value: "' OR '1'='1"}},
    jsonArrayInjection: ["'; DROP TABLE users; --", 'normal'],

    // Very long strings
    longString: 'A'.repeat(1_000_000),
    longStringWithInjection: 'A'.repeat(999_990) + "'; DROP TABLE users; --",

    // Special characters
    backslash: 'value\\',
    doubleQuote: 'value"injected',
    backtick: 'value`injected',
    dollarQuote: 'value$$injected$$',

    // PostgreSQL specific
    pgCopy: "COPY (SELECT * FROM users) TO '/tmp/pwned'",
    pgExtension: 'CREATE EXTENSION IF NOT EXISTS pg_read_file',
  };
}

/**
 * Boundary condition mutation IDs for LMID tracking tests.
 * Tests bigint handling in zql-database.ts.
 */
export function createBoundaryMutationIDs(): Record<
  string,
  number | bigint | string
> {
  return {
    // Normal values
    zero: 0,
    one: 1,
    typical: 1000,

    // Negative values (should fail validation or be rejected)
    negativeOne: -1,
    negativeLarge: -9999999999,

    // JavaScript integer boundaries
    maxSafeInteger: Number.MAX_SAFE_INTEGER, // 2^53 - 1
    beyondSafeInteger: Number.MAX_SAFE_INTEGER + 1, // Precision loss
    beyondSafeInteger2: Number.MAX_SAFE_INTEGER + 2, // Same as +1 due to precision
    minSafeInteger: Number.MIN_SAFE_INTEGER,

    // BigInt boundaries (postgres bigint is signed 64-bit)
    bigintMax: 9223372036854775807n, // 2^63 - 1
    bigintMaxMinus1: 9223372036854775806n,

    // Type coercion attacks
    nan: NaN,
    infinity: Infinity,
    negativeInfinity: -Infinity,
    fractional: 1.5,
    negFractional: -1.5,

    // String coercion
    stringNumber: '42',
    stringWithSpaces: ' 42 ',
    scientificNotation: '1e10',

    // Boolean coercion
    boolTrue: true as unknown as number,
    boolFalse: false as unknown as number,

    // Null/undefined coercion (will be cast)
    nullValue: null as unknown as number,
  };
}

/**
 * Client ID payloads for isolation testing.
 */
export function createClientIDPayloads(): Record<string, string> {
  return {
    // SQL injection in client ID
    sqlInjection: "'; DROP TABLE clients; --",
    orTrue: "client' OR '1'='1",

    // Very long client IDs
    veryLong: 'c'.repeat(10000),

    // Empty/whitespace
    empty: '',
    whitespace: '   ',
    newlines: 'client\nid',
    tabs: 'client\tid',
    nullBytes: 'client\x00id',

    // Unicode
    unicode: 'client\u200Bid', // Zero-width space
    rtlOverride: '\u202Eclient', // Right-to-left override
    homoglyph: 'cl\u0456ent', // Cyrillic i

    // Path traversal (unlikely but test)
    pathTraversal: '../../../etc/passwd',
    dotdot: '..%2F..%2F',
  };
}

/**
 * Create a push body for testing mutations.
 */
export function makePushBody(
  clientGroupID: string,
  clientID: string,
  mutations: Array<{
    id: number;
    name: string;
    args?: ReadonlyJSONValue[] | undefined;
  }>,
): PushBody {
  return {
    pushVersion: 1,
    clientGroupID,
    requestID: `pentest-${Date.now()}`,
    schemaVersion: 1,
    timestamp: Date.now(),
    mutations: mutations.map(m => ({
      type: 'custom' as const,
      clientID,
      id: m.id,
      name: m.name,
      timestamp: Date.now(),
      args: (m.args ?? []) as ReadonlyJSONValue[],
    })),
  };
}

/**
 * Create a single mutation push body.
 */
export function makeSingleMutation(
  clientGroupID: string,
  clientID: string,
  mutationID: number,
  mutatorName: string,
  args?: ReadonlyJSONValue[] | undefined,
): PushBody {
  return makePushBody(clientGroupID, clientID, [
    {id: mutationID, name: mutatorName, args: args ?? []},
  ]);
}

/**
 * Create mutation payloads that target CRUD operations.
 */
export function createCRUDAttackPayloads(): Record<
  string,
  Record<string, unknown>
> {
  return {
    // Primary key injection
    pkSQLInjection: {id: "x' OR '1'='1"},
    pkNullByte: {id: 'normal\x00injected'},
    pkVeryLong: {id: 'a'.repeat(100000)},

    // Column name spoofing (if dynamically constructed)
    columnInjection: {
      'id': 'normal',
      '"; DROP TABLE users; --': 'attack',
    },

    // Value injection in various types
    stringInjection: {
      id: 'test',
      value: "'; DELETE FROM users WHERE '1'='1",
    },
    numericInjection: {
      id: 'test',
      numericVal: '1; DROP TABLE users; --',
    },
    jsonInjection: {
      id: 'test',
      jsonCol: {malicious: "'; DROP TABLE--"},
    },

    // Type confusion
    intAsString: {id: 'test', numericVal: '999'},
    stringAsInt: {id: 123, value: 'test'},
    arrayAsValue: {id: 'test', value: ['a', 'b', 'c']},
    objectAsString: {id: 'test', value: {nested: 'object'}},

    // NULL handling
    explicitNull: {id: 'test', value: null},
    undefinedValue: {id: 'test', value: undefined},

    // Empty values
    emptyString: {id: 'test', value: ''},
    emptyArray: {id: 'test', arrayCol: []},
    emptyObject: {id: 'test', jsonCol: {}},
  };
}

/**
 * Error message leakage test cases.
 * These trigger various error conditions to check for information disclosure.
 */
export function createErrorLeakagePayloads(): Record<string, unknown> {
  return {
    // Trigger database errors
    nonexistentTable: {op: 'insert', table: 'nonexistent_table_xyz'},
    invalidColumn: {op: 'insert', column: 'nonexistent_column'},

    // Constraint violation
    duplicatePK: {op: 'insert', id: 'existing_id'},
    fkViolation: {op: 'insert', foreignKey: 'nonexistent_ref'},

    // Type errors
    typeError: {op: 'insert', value: Symbol('test')},

    // Large payloads to trigger errors
    oversizedPayload: {data: 'x'.repeat(100_000_000)},
  };
}
