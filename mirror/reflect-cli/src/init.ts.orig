<<<<<<< HEAD
import {Firestore} from '@google-cloud/firestore';
import {CreateRequest, create} from 'mirror-protocol/src/app.js';
import {App, appDataConverter, appPath} from 'mirror-schema/src/app.js';
import {releaseChannelSchema} from 'mirror-schema/src/server.js';
import {must} from 'shared/src/must.js';
import * as v from 'shared/src/valita.js';
import {readAppConfig, writeAppConfig} from './app-config.js';
import {authenticate} from './auth-config.js';
import {getFirebaseConfig} from './firebase.js';
import {getExistingAppsForUser} from './get-existing-apps-for-user.js';
import {makeRequester} from './requester.js';
import type {CommonYargsArgv, YargvToInterface} from './yarg-types.js';

export function initOptions(yargs: CommonYargsArgv) {
  return yargs
    .option('name', {
      describe: 'The name of existing app to use',
      type: 'string',
    })
    .option('channel', {
      describe: 'Which channel to use',
      choices: ['stable', 'canary'],
      default: 'stable',
    })
    .option('new', {
      describe: 'Create a new app',
      type: 'boolean',
    });
}

type InitHandlerArgs = YargvToInterface<ReturnType<typeof initOptions>>;

export async function initHandler(yargs: InitHandlerArgs) {
  const user = await authenticate();

  const userID = user.uid;

  const {name, new: newApp} = yargs;
  const {channel} = yargs;
  v.assert(channel, releaseChannelSchema);

  if (newApp) {
    if (name) {
      console.error('Cannot use --name with --new');
      process.exit(1);
    }
    await createNewApp(userID, channel);
    return;
  }

  const settings = getFirebaseConfig(yargs.stack);
  const firestore = new Firestore(settings);

  const appConfig = readAppConfig();
  if (!name && appConfig) {
    // Load the app from firebase to ensure it still exists.
    const app = await getApp(firestore, appConfig.appID);
    console.log(`Using app with name ${app.name}`);
    return;
  }

  // Check if user is already member of a team that has apps.
  const existingAppsForUser = await getExistingAppsForUser(firestore, userID);

  if (name) {
    // Check if the name flag is valid.
    const app = existingAppsForUser.find(app => app.name === name);
    if (!app) {
      console.error(`No app with name ${name} found.`);
      process.exit(1);
    }

    writeAppConfig({appID: app.appID});
    console.log(`Using app with name ${app.name}`);
    return;
  }

  if (existingAppsForUser.length === 0) {
    // New app.
    console.log('User is not member of any team(s) that has apps.');
    console.log('Creating new app.');
    await createNewApp(userID, channel);
    return;
  }

  if (existingAppsForUser.length === 1) {
    // User is only member of one team with apps. Use that app.
    console.log('User is member of team with a single app. Using that app.');
    writeAppConfig({appID: existingAppsForUser[0].appID});
    return;
  }

  // User is member of multiple teams with apps. Check if name flag is set
  // and present in list of apps.
  console.log('User is member of team(s) with multiple apps:');
  console.log('');

  for (const app of existingAppsForUser) {
    console.log(
      `  ${app.name} (appID: ${app.appID}, channel: ${app.serverReleaseChannel})`,
    );
  }
  console.log('');
  console.log('Please specify which app to use with --name flag.');
  process.exit(1);
}

async function createNewApp(userID: string, channel: 'canary' | 'stable') {
  const data: CreateRequest = {
    requester: makeRequester(userID),
    serverReleaseChannel: channel,
  };

  const {appID, name: appName} = await create(data);
  writeAppConfig({appID});
  console.log(`Created app ${appID} (${appName})`);
}

function getApp(firestore: Firestore, appID: string): Promise<App> {
  const docRef = firestore.doc(appPath(appID)).withConverter(appDataConverter);

  return firestore.runTransaction(
    async txn => {
      const doc = await txn.get(docRef);
      if (!doc.exists) {
        throw new Error(`App with appID ${appID} does not exist`);
      }

      return must(doc.data());
    },
    {readOnly: true},
=======
import type {CommonYargsArgv, YargvToInterface} from './yarg-types.js';
import color from 'picocolors';
import fs from 'node:fs';
import path from 'node:path';
import {fileURLToPath} from 'node:url';
import validateProjectName from 'validate-npm-package-name';

export function initOptions(yargs: CommonYargsArgv) {
  return yargs.option('name', {
    describe: 'Name of the app',
    type: 'string',
    demandOption: true,
  });
}

const templateDir = path.resolve(
  fileURLToPath(import.meta.url),
  '../..',
  `template`,
);

type InitHandlerArgs = YargvToInterface<ReturnType<typeof initOptions>>;

export function initHandler(yargs: InitHandlerArgs) {
  const {name} = yargs;
  const invalidPackageNameReason = isValidPackageName(name);
  if (invalidPackageNameReason) {
    console.log(
      color.red(
        `Invalid project name: ${color.bgWhite(
          name,
        )} - (${invalidPackageNameReason})`,
      ),
    );
    process.exit(1);
  }
  console.log(color.green(`Creating folder: ${color.bgWhite(name)}`));
  copyDir(templateDir, name);
  updateProjectName(name);
  console.log(color.green('Finished initializing your reflect project ðŸŽ‰'));
}

function copy(src: string, dest: string) {
  const stat = fs.statSync(src);
  if (stat.isDirectory()) {
    copyDir(src, dest);
  } else {
    fs.copyFileSync(src, dest);
  }
}

function copyDir(srcDir: string, destDir: string) {
  fs.mkdirSync(destDir, {recursive: true});
  for (const file of fs.readdirSync(srcDir)) {
    const srcFile = path.resolve(srcDir, file);
    const destFile = path.resolve(destDir, file);
    copy(srcFile, destFile);
  }
}

function editFile(file: string, callback: (content: string) => string) {
  const content = fs.readFileSync(file, 'utf-8');
  fs.writeFileSync(file, callback(content), 'utf-8');
}

function isValidPackageName(projectName: string): string | void {
  const nameValidation = validateProjectName(projectName);
  if (!nameValidation.validForNewPackages) {
    return [
      ...(nameValidation.errors || []),
      ...(nameValidation.warnings || []),
    ].join('\n');
  }
}

function updateProjectName(targetDir: string) {
  const packageJsonPath = path.resolve(targetDir, 'package.json');
  editFile(packageJsonPath, content =>
    content.replace(
      /"name": "reflect-template-example"/,
      `"name": "${targetDir}"`,
    ),
>>>>>>> 82046982 (start of init)
  );
}
