CREATE TABLE "comment" (
	"id" varchar PRIMARY KEY NOT NULL,
	"issueID" varchar,
	"created" double precision,
	"body" text NOT NULL,
	"creatorID" varchar
);
--> statement-breakpoint
CREATE TABLE "emoji" (
	"id" varchar PRIMARY KEY NOT NULL,
	"value" varchar NOT NULL,
	"annotation" varchar,
	"subjectID" varchar NOT NULL,
	"creatorID" varchar,
	"created" double precision DEFAULT (EXTRACT(epoch FROM CURRENT_TIMESTAMP) * (1000)::numeric),
	CONSTRAINT "emoji_subjectID_creatorID_value_key" UNIQUE("value","subjectID","creatorID")
);
--> statement-breakpoint
CREATE TABLE "issue" (
	"id" varchar PRIMARY KEY NOT NULL,
	"shortID" integer GENERATED BY DEFAULT AS IDENTITY (sequence name "issue_shortID_seq" INCREMENT BY 1 MINVALUE 1 MAXVALUE 2147483647 START WITH 3000 CACHE 1),
	"title" varchar(128) NOT NULL,
	"open" boolean NOT NULL,
	"modified" double precision DEFAULT (EXTRACT(epoch FROM CURRENT_TIMESTAMP) * (1000)::numeric),
	"created" double precision DEFAULT (EXTRACT(epoch FROM CURRENT_TIMESTAMP) * (1000)::numeric),
	"creatorID" varchar NOT NULL,
	"assigneeID" varchar,
	"description" varchar(10240) DEFAULT '',
	"visibility" varchar DEFAULT 'public' NOT NULL
);
--> statement-breakpoint
CREATE TABLE "issueLabel" (
	"labelID" varchar NOT NULL,
	"issueID" varchar NOT NULL,
	CONSTRAINT "issueLabel_pkey" PRIMARY KEY("labelID","issueID")
);
--> statement-breakpoint
CREATE TABLE "issueNotifications" (
	"userID" varchar NOT NULL,
	"issueID" varchar NOT NULL,
	"subscribed" boolean DEFAULT true,
	"created" double precision DEFAULT (EXTRACT(epoch FROM CURRENT_TIMESTAMP) * (1000)::numeric),
	CONSTRAINT "issueNotifications_pkey" PRIMARY KEY("userID","issueID")
);
--> statement-breakpoint
CREATE TABLE "label" (
	"id" varchar PRIMARY KEY NOT NULL,
	"name" varchar NOT NULL
);
--> statement-breakpoint
CREATE TABLE "user" (
	"id" varchar PRIMARY KEY NOT NULL,
	"login" varchar NOT NULL,
	"name" varchar,
	"avatar" varchar,
	"role" varchar DEFAULT 'user' NOT NULL,
	"githubID" integer NOT NULL,
	"email" varchar
);
--> statement-breakpoint
CREATE TABLE "userPref" (
	"key" varchar NOT NULL,
	"value" varchar NOT NULL,
	"userID" varchar NOT NULL,
	CONSTRAINT "userPref_pkey" PRIMARY KEY("key","userID")
);
--> statement-breakpoint
CREATE TABLE "viewState" (
	"userID" varchar NOT NULL,
	"issueID" varchar NOT NULL,
	"viewed" double precision,
	CONSTRAINT "viewState_pkey" PRIMARY KEY("userID","issueID")
);
--> statement-breakpoint
ALTER TABLE "comment" ADD CONSTRAINT "comment_issueID_fkey" FOREIGN KEY ("issueID") REFERENCES "public"."issue"("id") ON DELETE cascade ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "comment" ADD CONSTRAINT "comment_creatorID_fkey" FOREIGN KEY ("creatorID") REFERENCES "public"."user"("id") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "emoji" ADD CONSTRAINT "emoji_creatorID_fkey" FOREIGN KEY ("creatorID") REFERENCES "public"."user"("id") ON DELETE cascade ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "issue" ADD CONSTRAINT "issue_creatorID_fkey" FOREIGN KEY ("creatorID") REFERENCES "public"."user"("id") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "issue" ADD CONSTRAINT "issue_assigneeID_fkey" FOREIGN KEY ("assigneeID") REFERENCES "public"."user"("id") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "issueLabel" ADD CONSTRAINT "issueLabel_labelID_fkey" FOREIGN KEY ("labelID") REFERENCES "public"."label"("id") ON DELETE no action ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "issueLabel" ADD CONSTRAINT "issueLabel_issueID_fkey" FOREIGN KEY ("issueID") REFERENCES "public"."issue"("id") ON DELETE cascade ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "issueNotifications" ADD CONSTRAINT "issueNotifications_userID_fkey" FOREIGN KEY ("userID") REFERENCES "public"."user"("id") ON DELETE cascade ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "issueNotifications" ADD CONSTRAINT "issueNotifications_issueID_fkey" FOREIGN KEY ("issueID") REFERENCES "public"."issue"("id") ON DELETE cascade ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "userPref" ADD CONSTRAINT "userPref_userID_fkey" FOREIGN KEY ("userID") REFERENCES "public"."user"("id") ON DELETE cascade ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "viewState" ADD CONSTRAINT "viewState_userID_fkey" FOREIGN KEY ("userID") REFERENCES "public"."user"("id") ON DELETE cascade ON UPDATE no action;--> statement-breakpoint
ALTER TABLE "viewState" ADD CONSTRAINT "viewState_issueID_fkey" FOREIGN KEY ("issueID") REFERENCES "public"."issue"("id") ON DELETE cascade ON UPDATE no action;--> statement-breakpoint
CREATE INDEX "comment_issueid_idx" ON "comment" USING btree ("issueID");--> statement-breakpoint
CREATE INDEX "emoji_created_idx" ON "emoji" USING btree ("created");--> statement-breakpoint
CREATE INDEX "emoji_subject_id_idx" ON "emoji" USING btree ("subjectID");--> statement-breakpoint
CREATE INDEX "issue_created_idx" ON "issue" USING btree ("created");--> statement-breakpoint
CREATE INDEX "issue_modified_idx" ON "issue" USING btree ("modified");--> statement-breakpoint
CREATE INDEX "issue_open_modified_idx" ON "issue" USING btree ("open","modified");--> statement-breakpoint
CREATE INDEX "issuelabel_issueid_idx" ON "issueLabel" USING btree ("issueID");--> statement-breakpoint
CREATE UNIQUE INDEX "user_githubid_idx" ON "user" USING btree ("githubID");--> statement-breakpoint
CREATE UNIQUE INDEX "user_login_idx" ON "user" USING btree ("login");

----> BEGIN manual modification for triggers
CREATE OR REPLACE FUNCTION update_modified_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.modified = (EXTRACT(EPOCH FROM CURRENT_TIMESTAMP) * 1000);
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER issue_set_last_modified
BEFORE INSERT OR UPDATE ON issue
FOR EACH ROW
EXECUTE FUNCTION update_modified_column();

CREATE OR REPLACE FUNCTION issue_set_created_on_insert()
RETURNS TRIGGER AS $$
BEGIN
    NEW.created = (EXTRACT(EPOCH FROM CURRENT_TIMESTAMP) * 1000);
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER issue_set_created_on_insert_trigger
BEFORE INSERT ON issue
FOR EACH ROW
EXECUTE FUNCTION issue_set_created_on_insert();


CREATE OR REPLACE FUNCTION update_issue_modified_time()
RETURNS TRIGGER AS $$
BEGIN
    UPDATE issue
    SET modified = EXTRACT(EPOCH FROM CURRENT_TIMESTAMP) * 1000
    WHERE id = NEW."issueID";
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_issue_modified_time_on_comment
AFTER INSERT ON comment
FOR EACH ROW
EXECUTE FUNCTION update_issue_modified_time();

CREATE OR REPLACE FUNCTION comment_set_created_on_insert()
RETURNS TRIGGER AS $$
BEGIN
    NEW.created = (EXTRACT(EPOCH FROM CURRENT_TIMESTAMP) * 1000);
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER comment_set_created_on_insert_trigger
BEFORE INSERT ON comment
FOR EACH ROW
EXECUTE FUNCTION comment_set_created_on_insert();

CREATE OR REPLACE FUNCTION validate_comment_body_length()
RETURNS TRIGGER AS $$
BEGIN
  IF NEW.body IS NOT NULL THEN
    -- The launch post has a special case maxlength of 1024 because trolls
    IF NEW."issueID" = 'duuW9Nyj5cTNLlimp9Qje' AND LENGTH(NEW.body) > 1024 THEN
      RAISE EXCEPTION 'Column value exceeds maximum allowed length of %', 1024;
    END IF;
    -- Length chosen because we have some old comments that are ~44KB.
    IF LENGTH(NEW.body) > 64*1024 THEN
      RAISE EXCEPTION 'Column value exceeds maximum allowed length of %', 64*1024;
    END IF;
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER check_comment_body_length
BEFORE INSERT OR UPDATE ON comment
FOR EACH ROW
EXECUTE FUNCTION validate_comment_body_length();


CREATE OR REPLACE FUNCTION emoji_check_subject_id()
RETURNS TRIGGER AS $$
BEGIN
    -- Check if subjectID exists in the issue table
    IF EXISTS (SELECT 1 FROM issue WHERE id = NEW."subjectID") THEN
        NULL; -- Do nothing
    ELSIF EXISTS (SELECT 1 FROM comment WHERE id = NEW."subjectID") THEN
        NULL; -- Do nothing
    ELSE
        RAISE EXCEPTION 'id ''%'' does not exist in issue or comment', NEW."subjectID";
    END IF;
    
    PERFORM update_issue_modified_on_emoji_change(NEW."subjectID");

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER emoji_check_subject_id_update_trigger
BEFORE INSERT OR UPDATE ON emoji
FOR EACH ROW
EXECUTE FUNCTION emoji_check_subject_id();

CREATE OR REPLACE FUNCTION emoji_set_created_on_insert()
RETURNS TRIGGER AS $$
BEGIN
    NEW.created = EXTRACT(EPOCH FROM CURRENT_TIMESTAMP) * 1000;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER emoji_set_created_on_insert_trigger
BEFORE INSERT ON emoji
FOR EACH ROW
EXECUTE FUNCTION emoji_set_created_on_insert();

-- Delete emoji when issue is deleted
CREATE OR REPLACE FUNCTION delete_emoji_on_issue_delete()
RETURNS TRIGGER AS $$
BEGIN
    DELETE FROM emoji WHERE "subjectID" = OLD.id;
    RETURN OLD;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER delete_emoji_on_issue_delete_trigger
AFTER DELETE ON issue
FOR EACH ROW
EXECUTE FUNCTION delete_emoji_on_issue_delete();

-- Delete emoji when comment is deleted
CREATE OR REPLACE FUNCTION delete_emoji_on_comment_delete()
RETURNS TRIGGER AS $$
BEGIN
    DELETE FROM emoji WHERE "subjectID" = OLD.id;
    RETURN OLD;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER delete_emoji_on_comment_delete_trigger
AFTER DELETE ON comment
FOR EACH ROW
EXECUTE FUNCTION delete_emoji_on_comment_delete();

-- When an emoji is added or deleted we find the issue and update the modified time
CREATE OR REPLACE FUNCTION update_issue_modified_on_emoji_change("subjectID" VARCHAR)
RETURNS VOID AS $$
BEGIN
    UPDATE issue
    SET modified = EXTRACT(EPOCH FROM CURRENT_TIMESTAMP) * 1000
    FROM (
        SELECT issue.id AS id
        FROM issue JOIN comment ON issue.id=comment."issueID"
        WHERE comment.id = "subjectID" OR issue.id = "subjectID"
    ) AS subquery
    WHERE issue.id = subquery.id;
END;   
$$ LANGUAGE plpgsql;
----> END manual modification for triggers
----> BEGIN manual modification for publication
CREATE PUBLICATION zero_zbugs
  FOR TABLE
    issue,
    "viewState",
    comment,
    label,
    "issueLabel",
    emoji,
    "userPref",
    "issueNotifications",
    "user" (
      id,
      login,
      name,
      avatar,
      role,
      "githubID"
    );
----> END manual modification for publication